"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferAptosCoins = exports.createV1Token = exports.sendTxWithPayer = exports.createV1TokenWithFeePayer = exports.createTestCollectionAndMint = exports.createTestCollection = exports.mintTestToken = exports.BUYER_PK = exports.DEFAULT_PK = exports.generateTestAptosState = exports.createTestAptosState = void 0;
const tslib_1 = require("tslib");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const aptos_wallet_1 = require("@rarible/aptos-wallet");
const sdk_common_1 = require("@rarible/sdk-common");
const nft_1 = require("../../nft/nft");
const config_1 = require("../../config");
function createTestAptosState(privateKey = exports.DEFAULT_PK) {
    const pk = new ts_sdk_1.Ed25519PrivateKey(privateKey);
    const account = ts_sdk_1.Account.fromPrivateKey({ privateKey: pk });
    const APTOS_NETWORK = ts_sdk_1.Network.TESTNET;
    const config = new ts_sdk_1.AptosConfig({ network: APTOS_NETWORK });
    const envConfig = (0, config_1.getEnvConfig)(APTOS_NETWORK);
    const aptos = new ts_sdk_1.Aptos(config);
    const wallet = new aptos_wallet_1.AptosGenericSdkWallet(aptos, account);
    return {
        aptos,
        account,
        wallet,
        config: envConfig,
        transferAPT: transferAptosCoins.bind(null, { aptos, wallet }),
    };
}
exports.createTestAptosState = createTestAptosState;
function generateTestAptosState() {
    const account = ts_sdk_1.Account.generate();
    console.log("pk", account.privateKey.toString());
    console.log("address", account.accountAddress.toString());
    const APTOS_NETWORK = ts_sdk_1.Network.TESTNET;
    const config = new ts_sdk_1.AptosConfig({ network: APTOS_NETWORK });
    const envConfig = (0, config_1.getEnvConfig)(APTOS_NETWORK);
    const aptos = new ts_sdk_1.Aptos(config);
    const wallet = new aptos_wallet_1.AptosGenericSdkWallet(aptos, account);
    return {
        aptos,
        account,
        wallet,
        config: envConfig,
        transferAPT: transferAptosCoins.bind(null, { aptos, wallet }),
    };
}
exports.generateTestAptosState = generateTestAptosState;
//0x484e284d3b98ce736b6b6de27127176bafe30942d949f30b0ab59a17007ccf37
exports.DEFAULT_PK = "0x229eea52e53be5a6fd1ba00e660fc632cdb47ffe8f777a847daa8220553c5511";
//0xa4576f0bc3f835b5b45b4e49da280779b6352f2083fe28c94386468731b3fd3c
exports.BUYER_PK = "0x15b7dde0584838dd033894bfaa9f64013206ff3f82d9d325e1479cab4709e43c";
function mintTestToken(state, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mintClass = new nft_1.AptosNft(state.aptos, new aptos_wallet_1.AptosGenericSdkWallet(state.aptos, state.account), state.config);
        const randomId = Math.floor(Math.random() * 1000000);
        const uri = "ipfs://QmWYpMyoaUGNRSQbwhw97xM8tcRWm4Et598qtzmzsau7ch/";
        const tokenName = `Mytoken #${randomId}`;
        let mintResult, tokenAddress;
        if (!options || ((0, sdk_common_1.isObjectLike)(options) && "collectionName" in options)) {
            mintResult = yield mintClass.mintWithCollectionName({
                collectionName: (options === null || options === void 0 ? void 0 : options.collectionName) || "Test collection 1016",
                name: tokenName,
                description: `Description of Mytoken #${randomId}`,
                uri,
            });
            tokenAddress = mintResult.tokenAddress;
        }
        else if ((0, sdk_common_1.isObjectLike)(options) && "collectionAddress" in options) {
            mintResult = yield mintClass.mintWithCollectionAddress({
                collectionAddress: options === null || options === void 0 ? void 0 : options.collectionAddress,
                name: tokenName,
                description: `Description of Mytoken #${randomId}`,
                uri,
            });
            tokenAddress = mintResult.tokenAddress;
        }
        else {
            throw new Error("Unexpected options");
        }
        return { tokenAddress, tokenName: mintResult.tokenName || tokenName };
    });
}
exports.mintTestToken = mintTestToken;
function createTestCollection(state) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const deploy = new nft_1.AptosNft(state.aptos, state.wallet, state.config);
        const randomId = Math.floor(Math.random() * 100000000);
        const uri = "ipfs://QmWYpMyoaUGNRSQbwhw97xM8tcRWm4Et598qtzmzsau7ch/";
        const collectionName = `Test collection #${randomId}`;
        const { rariDropAddress, aptosCollectionAddress } = yield deploy.createCollection({
            name: collectionName,
            description: "description",
            uri,
        });
        return {
            rariDropAddress,
            aptosCollectionAddress,
            collectionName,
        };
    });
}
exports.createTestCollection = createTestCollection;
function createTestCollectionAndMint(state) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { rariDropAddress, aptosCollectionAddress, collectionName } = yield createTestCollection(state);
        const { tokenAddress, tokenName } = yield mintTestToken(state, {
            collectionAddress: rariDropAddress,
        });
        return {
            rariDropAddress,
            aptosCollectionAddress,
            collectionAddress: aptosCollectionAddress,
            collectionName,
            tokenAddress,
            tokenName,
        };
    });
}
exports.createTestCollectionAndMint = createTestCollectionAndMint;
function createV1TokenWithFeePayer(feePayerState, state) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const createV1NftTx = yield state.aptos.transaction.build.simple({
            sender: state.account.accountAddress.toString(),
            withFeePayer: true,
            data: {
                function: `0x1cd6ec749dfd85537f41ea6c07c135532c87ba02b13a709286e352a004657c3a::create_nft_with_resource_account::mint_event_ticket`,
                typeArguments: [],
                functionArguments: [],
            },
        });
        return sendTxWithPayer(feePayerState, state, createV1NftTx);
    });
}
exports.createV1TokenWithFeePayer = createV1TokenWithFeePayer;
function sendTxWithPayer(feePayerState, state, transaction) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const senderAuthenticator = state.aptos.transaction.sign({
            signer: state.account,
            transaction,
        });
        const feePayerAuthenticator = state.aptos.transaction.signAsFeePayer({
            signer: feePayerState.account,
            transaction,
        });
        const commitedTx = yield state.aptos.transaction.submit.simple({
            transaction,
            senderAuthenticator: senderAuthenticator,
            feePayerAuthenticator: feePayerAuthenticator,
        });
        return state.aptos.waitForTransaction({
            transactionHash: commitedTx.hash,
        });
    });
}
exports.sendTxWithPayer = sendTxWithPayer;
function createV1Token(state) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const rawTx = {
            function: `0x1cd6ec749dfd85537f41ea6c07c135532c87ba02b13a709286e352a004657c3a::create_nft_with_resource_account::mint_event_ticket`,
            typeArguments: [],
            arguments: [],
        };
        const pendingTx = yield state.wallet.signAndSubmitTransaction(rawTx);
        const commitedTx = yield state.aptos.waitForTransaction({
            transactionHash: pendingTx.hash,
        });
        if (!("events" in commitedTx)) {
            throw new Error("Mint transaction should consist 'events' field");
        }
        const collectionEvent = commitedTx.events.find(e => e === null || e === void 0 ? void 0 : e.type.includes("0x3::token::MintTokenEvent"));
        if (collectionEvent) {
            return {
                tx: commitedTx,
                propertyVersion: +collectionEvent.sequence_number + 1,
                collectionName: "Test Collection V1 - Rarible",
                tokenName: "Crypto Cats N2",
                creator: "0x1cd6ec749dfd85537f41ea6c07c135532c87ba02b13a709286e352a004657c3a",
            };
        }
        throw new Error("Mint event has not been found");
    });
}
exports.createV1Token = createV1Token;
/**
 *
 * @param state Sender state
 * @param to Receipent
 * @param amount Integer
 */
function transferAptosCoins(state, to, amount) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transferData = {
            function: "0x1::aptos_account::transfer_coins",
            typeArguments: ["0x1::aptos_coin::AptosCoin"],
            arguments: [to, amount],
        };
        const pendingTx = yield state.wallet.signAndSubmitTransaction(transferData);
        return state.aptos.waitForTransaction({
            transactionHash: pendingTx.hash,
        });
    });
}
exports.transferAptosCoins = transferAptosCoins;
