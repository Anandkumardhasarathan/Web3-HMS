"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosNft = void 0;
const tslib_1 = require("tslib");
const sdk_common_1 = require("@rarible/sdk-common");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const common_1 = require("../common");
class AptosNft {
    constructor(aptos, wallet, config) {
        this.aptos = aptos;
        this.wallet = wallet;
        this.config = config;
        this.createNativeCollection = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transaction = {
                arguments: [
                    options.description,
                    common_1.MAX_U64_INT,
                    options.name,
                    options.uri,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    true,
                    "0",
                    "1",
                ],
                function: "0x4::aptos_token::create_collection",
                type: "entry_function_payload",
                typeArguments: [],
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            const tx = yield this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
            const collectionChange = tx.changes.find(state => {
                return (state.type === "write_resource" &&
                    "data" in state &&
                    typeof state.data === "object" &&
                    state.data !== null &&
                    "type" in state.data &&
                    (0, ts_sdk_1.isString)(state.data.type) &&
                    state.data.type.includes("collection::Collection"));
            });
            if (!(collectionChange && "address" in collectionChange)) {
                throw new Error("Collection address has not been found");
            }
            return {
                tx,
                collectionAddress: collectionChange.address,
            };
        });
        this.createCollection = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const royaltiesAddress = (yield (0, common_1.getRequiredWallet)(this.wallet).getAccountInfo()).address;
            const royaltyPointsDenominator = "10000";
            const royaltyPointsNumerator = "0";
            const publicSaleMintTime = Math.floor(Date.now() / 1000);
            const publicSaleMintPrice = "0";
            const totalSupply = "10000";
            const collectionMutateSetting = [false, false, false];
            const tokenMutateSetting = [false, false, false, false, false];
            // used to generate unique collection address
            const collectionSeed = (0, common_1.makeId)(7);
            const maxPerWallet = 2;
            const isOpenEdition = false;
            const endTime = Math.floor(Date.now() / 1000) + 1000000;
            const platformFee = 100;
            const maxPerTransaction = 2;
            const openeditionLimit = 0;
            const transaction = {
                function: `${this.config.raribleDropMachineAddress}::rari_drop_machine::init_collection`,
                typeArguments: [],
                arguments: [
                    options.name,
                    options.description,
                    options.uri,
                    royaltiesAddress,
                    royaltyPointsDenominator,
                    royaltyPointsNumerator,
                    publicSaleMintTime,
                    publicSaleMintPrice,
                    totalSupply,
                    collectionMutateSetting,
                    tokenMutateSetting,
                    maxPerWallet,
                    collectionSeed,
                    isOpenEdition,
                    endTime,
                    platformFee,
                    maxPerTransaction,
                    openeditionLimit,
                ],
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            const tx = yield this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
            if (!("events" in tx)) {
                throw new Error("Create collection tx don't consist 'events' field");
            }
            const collectionEvent = tx.events.find(e => e === null || e === void 0 ? void 0 : e.type.includes("events::CollectionCreated"));
            if (!collectionEvent) {
                throw new Error("Collection create event has not been found");
            }
            if (!(collectionEvent && "data" in collectionEvent)) {
                throw new Error("Collection data has not been found");
            }
            return {
                tx,
                collectionAddress: (0, sdk_common_1.normalizeAptosAddress)(collectionEvent.data.rari_drop_address),
                rariDropAddress: (0, sdk_common_1.normalizeAptosAddress)(collectionEvent.data.rari_drop_address),
                aptosCollectionAddress: (0, sdk_common_1.normalizeAptosAddress)(collectionEvent.data.aptos_collection_address),
            };
        });
        this.mintWithCollectionName = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const transaction = {
                function: "0x4::aptos_token::mint",
                typeArguments: [],
                arguments: [options.collectionName, options.description, options.name, options.uri, [], [], []],
                type: "entry_function_payload",
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            const tx = yield this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
            const identifierEvent = tx.changes.find((e) => { var _a; return ((_a = e === null || e === void 0 ? void 0 : e.data) === null || _a === void 0 ? void 0 : _a.type) === "0x4::token::TokenIdentifiers"; });
            let tokenName;
            if (identifierEvent) {
                tokenName = (_c = (_b = (_a = identifierEvent === null || identifierEvent === void 0 ? void 0 : identifierEvent.data) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.value;
            }
            const mintChange = tx.changes.find(changeItem => (0, common_1.isChangeBelongsToType)(changeItem, type => type.includes("token::Token")));
            if (!mintChange || !("address" in mintChange)) {
                throw new Error("Collection address has not been found");
            }
            return {
                tx,
                tokenAddress: (0, sdk_common_1.normalizeAptosAddress)(mintChange.address),
                tokenName,
            };
        });
        this.mintWithCollectionAddress = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _d, _e, _f;
            const rawTx = {
                function: `${this.config.raribleDropMachineAddress}::rari_drop_machine::mint_script`,
                typeArguments: [],
                arguments: [options.collectionAddress],
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(rawTx);
            const commitedTx = yield this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
            if (!("events" in commitedTx)) {
                throw new Error("Mint transaction should consist 'events' field");
            }
            const mintEvent = commitedTx.events.find(e => e.type === "0x4::collection::Mint");
            if (!mintEvent) {
                throw new Error("Mint event has not been found");
            }
            const identifierEvent = commitedTx.changes.find((e) => { var _a; return ((_a = e === null || e === void 0 ? void 0 : e.data) === null || _a === void 0 ? void 0 : _a.type) === "0x4::token::TokenIdentifiers"; });
            let tokenName;
            if (identifierEvent) {
                tokenName = (_f = (_e = (_d = identifierEvent === null || identifierEvent === void 0 ? void 0 : identifierEvent.data) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.name) === null || _f === void 0 ? void 0 : _f.value;
            }
            return {
                tx: commitedTx,
                tokenAddress: (0, sdk_common_1.normalizeAptosAddress)(mintEvent.data.token),
                tokenName,
            };
        });
        this.transfer = (tokenAddress, to) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transaction = {
                function: "0x1::object::transfer",
                typeArguments: ["0x4::token::Token"],
                arguments: [tokenAddress, to],
                type: "entry_function_payload",
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            return this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
        });
        this.burn = (tokenAddress) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transaction = {
                function: "0x4::aptos_token::burn",
                typeArguments: ["0x4::token::Token"],
                arguments: [tokenAddress],
                type: "entry_function_payload",
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            return this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
        });
        this.burnV1Token = (creatorAddress, collectionName, tokenName, propertyVersion, amount) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transaction = {
                function: "0x3::token::burn",
                typeArguments: [],
                arguments: [creatorAddress, collectionName, tokenName, propertyVersion, amount],
                type: "entry_function_payload",
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            return this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
        });
        this.transferV1Token = (to, creator, collection, name, propertyVersion, amount) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const transaction = {
                function: "0x3::token_transfers::offer_script",
                typeArguments: [],
                arguments: [to, creator, collection, name, propertyVersion, amount],
                type: "entry_function_payload",
            };
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(transaction);
            return this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
        });
        this.createCollection = this.createCollection.bind(this);
        this.mintWithCollectionName = this.mintWithCollectionName.bind(this);
        this.mintWithCollectionAddress = this.mintWithCollectionAddress.bind(this);
        this.transfer = this.transfer.bind(this);
        this.transferV1Token = this.transferV1Token.bind(this);
        this.burn = this.burn.bind(this);
    }
}
exports.AptosNft = AptosNft;
