"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosOrder = void 0;
const tslib_1 = require("tslib");
const sdk_common_1 = require("@rarible/sdk-common");
const common_1 = require("../common");
class AptosOrder {
    constructor(aptos, wallet, config) {
        this.aptos = aptos;
        this.wallet = wallet;
        this.config = config;
        this.sell = (tokenAddress, feeObjectAddress, startTime, price) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::coin_listing::init_fixed_price`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [tokenAddress, feeObjectAddress, startTime, price],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("listing::Listing")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
        this.sellV1 = (feeObjectAddress, creatorAddress, collectionName, tokenName, propertyVersion, startTime, price) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::coin_listing::init_fixed_price_for_tokenv1`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [creatorAddress, collectionName, tokenName, propertyVersion, feeObjectAddress, startTime, price],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("listing::Listing")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
        this.getListingTokenType = (listing) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const listingObject = yield this.aptos.getAccountResources({
                accountAddress: listing,
            });
            return (0, common_1.getListingTokenType)(listingObject);
        });
        this.sellUpdate = (listing, price) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f;
            const listingObject = yield this.aptos.getAccountResources({
                accountAddress: listing,
            });
            const listingResource = listingObject.find(o => o.type.includes("listing::Listing"));
            if (!((_b = (_a = listingResource === null || listingResource === void 0 ? void 0 : listingResource.data) === null || _a === void 0 ? void 0 : _a.fee_schedule) === null || _b === void 0 ? void 0 : _b.inner)) {
                throw new Error("Fee object has no been found");
            }
            const tokenType = (0, common_1.getListingTokenType)(listingObject);
            const rawTx = {
                function: `${this.config.marketplaceAddress}::coin_listing::init_fixed_price`,
                typeArguments: [tokenType],
                arguments: [
                    (_d = (_c = listingResource === null || listingResource === void 0 ? void 0 : listingResource.data) === null || _c === void 0 ? void 0 : _c.object) === null || _d === void 0 ? void 0 : _d.inner,
                    (_f = (_e = listingResource === null || listingResource === void 0 ? void 0 : listingResource.data) === null || _e === void 0 ? void 0 : _e.fee_schedule) === null || _f === void 0 ? void 0 : _f.inner,
                    listingResource.start_time,
                    price,
                ],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("listing::Listing")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
        this.buy = (listing) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tokenType = yield this.getListingTokenType(listing);
            const rawTx = {
                function: `${this.config.marketplaceAddress}::coin_listing::purchase`,
                typeArguments: [tokenType],
                arguments: [listing],
            };
            return this.sendAndWaitTx(rawTx);
        });
        this.cancel = (listing) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tokenType = yield this.getListingTokenType(listing);
            const rawTx = {
                function: `${this.config.marketplaceAddress}::coin_listing::end_fixed_price`,
                typeArguments: [tokenType],
                arguments: [listing],
            };
            return this.sendAndWaitTx(rawTx);
        });
        this.collectionOffer = (collectionAddress, amount, feeObjectAddress, endTime, price) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::collection_offer::init_for_tokenv2_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [collectionAddress, feeObjectAddress, price, amount, endTime],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("collection_offer::CollectionOffer")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
        this.collectionOfferV1 = (creatorAddress, collectionName, feeObjectAddress, price, amount, endTime) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::collection_offer::init_for_tokenv1_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [creatorAddress, collectionName, feeObjectAddress, price, amount, endTime],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("collection_offer::CollectionOffer")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
        this.cancelCollectionOffer = (offer) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::collection_offer::cancel`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer],
            };
            return this.sendAndWaitTx(rawTx);
        });
        this.tokenOffer = (tokenAddress, feeObjectAddress, endTime, price) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::token_offer::init_for_tokenv2_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [tokenAddress, feeObjectAddress, price, endTime],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            if (!("events" in tx)) {
                throw new Error("Events field in tx object was expected");
            }
            const event = tx.events.find(e => e.type.includes("events::TokenOfferPlaced"));
            if (!event || !("token_offer" in event.data)) {
                throw new Error("Offer has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(event.data.token_offer);
        });
        this.tokenOfferV1 = (creatorAddress, collectionName, tokenName, propertyVersion, feeObjectAddress, price, endTime) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::token_offer::init_for_tokenv1_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [creatorAddress, collectionName, tokenName, propertyVersion, feeObjectAddress, price, endTime],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            if (!("events" in tx)) {
                throw new Error("Events field in tx object was expected");
            }
            const event = tx.events.find(e => e.type.includes("events::TokenOfferPlaced"));
            if (!event || !("token_offer" in event.data)) {
                throw new Error("Offer has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(event.data.token_offer);
        });
        this.cancelTokenOffer = (offer) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::token_offer::cancel`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer],
            };
            return this.sendAndWaitTx(rawTx);
        });
        this.createFeeSchedule = this.createFeeSchedule.bind(this);
        this.getFeeObject = this.getFeeObject.bind(this);
        this.getFeeScheduleAddress = this.getFeeScheduleAddress.bind(this);
        this.sendAndWaitTx = this.sendAndWaitTx.bind(this);
        this.getListingTokenType = this.getListingTokenType.bind(this);
        this.sell = this.sell.bind(this);
        this.sellV1 = this.sellV1.bind(this);
        this.buy = this.buy.bind(this);
        this.cancel = this.cancel.bind(this);
        this.collectionOffer = this.collectionOffer.bind(this);
        this.collectionOfferV1 = this.collectionOfferV1.bind(this);
        this.cancelCollectionOffer = this.cancelCollectionOffer.bind(this);
        this.acceptCollectionOffer = this.acceptCollectionOffer.bind(this);
        this.acceptCollectionOfferV1 = this.acceptCollectionOfferV1.bind(this);
        this.tokenOffer = this.tokenOffer.bind(this);
        this.tokenOfferV1 = this.tokenOfferV1.bind(this);
        this.cancelTokenOffer = this.cancelTokenOffer.bind(this);
        this.acceptTokenOffer = this.acceptTokenOffer.bind(this);
        this.acceptTokenOfferV1 = this.acceptTokenOfferV1.bind(this);
    }
    sendAndWaitTx(tx) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const pendingTx = yield (0, common_1.getRequiredWallet)(this.wallet).signAndSubmitTransaction(tx);
            return this.aptos.waitForTransaction({
                transactionHash: pendingTx.hash,
            });
        });
    }
    acceptCollectionOffer(offer, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::collection_offer::sell_tokenv2`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer, token],
            };
            return this.sendAndWaitTx(rawTx);
        });
    }
    acceptCollectionOfferV1(offer, tokenName, propertyVersion) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::collection_offer::sell_tokenv1_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer, tokenName, propertyVersion],
            };
            return this.sendAndWaitTx(rawTx);
        });
    }
    acceptTokenOffer(offer) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::token_offer::sell_tokenv2`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer],
            };
            return this.sendAndWaitTx(rawTx);
        });
    }
    acceptTokenOfferV1(offer, tokenName, propertyVersion) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const rawTx = {
                function: `${this.config.marketplaceAddress}::token_offer::sell_tokenv1_entry`,
                typeArguments: [common_1.APT_TOKEN_TYPE],
                arguments: [offer, tokenName, propertyVersion],
            };
            return this.sendAndWaitTx(rawTx);
        });
    }
    createFeeSchedule(_a) {
        return tslib_1.__awaiter(this, arguments, void 0, function* ({ value, receiveAddress }) {
            const commissionDenominator = "10000";
            const commissionNumerator = value.toString();
            const biddingFee = "0";
            const listingFee = "0";
            const addr = receiveAddress !== null && receiveAddress !== void 0 ? receiveAddress : (yield (0, common_1.getRequiredWallet)(this.wallet).getAccountInfo()).address;
            const rawTx = {
                function: `${this.config.marketplaceAddress}::fee_schedule::init_entry`,
                typeArguments: [],
                arguments: [addr, biddingFee, listingFee, commissionDenominator, commissionNumerator],
            };
            const tx = yield this.sendAndWaitTx(rawTx);
            const change = tx.changes.find(change => (0, common_1.isChangeBelongsToType)(change, type => type.includes("fee_schedule::FeeSchedule")));
            if (!change || !("address" in change)) {
                throw new Error("Address has not been found");
            }
            return (0, sdk_common_1.normalizeAptosAddress)(change.address);
        });
    }
    getFeeObject(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options)
                return this.getFeeScheduleAddress();
            if (yield this.isFeeScheduleObject(options.address)) {
                return options.address;
            }
            return this.createFeeSchedule({
                receiveAddress: options.address,
                value: options.value,
            });
        });
    }
    isFeeScheduleObject(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const addressObjectResources = yield this.aptos.getAccountResources({
                accountAddress: address,
            });
            const feeScheduleEvent = addressObjectResources.find(resource => resource.type.includes("fee_schedule::FeeSchedule"));
            const percentageRateEvent = addressObjectResources.find(resource => resource.type.includes("fee_schedule::PercentageRateCommission"));
            return !!feeScheduleEvent && !!percentageRateEvent;
        });
    }
    getFeeScheduleAddress() {
        return this.config.feeZeroScheduleAddress;
    }
}
exports.AptosOrder = AptosOrder;
