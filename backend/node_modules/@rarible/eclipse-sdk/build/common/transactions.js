"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendSignedTransaction = exports.sendTransactionWithRetry = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const solana_common_1 = require("@rarible/solana-common");
const sdk_common_1 = require("@rarible/sdk-common");
function sendTransactionWithRetry(connection, wallet, instructions, signers, commitment, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction({ feePayer: wallet.publicKey });
        instructions.forEach(instruction => transaction.add(instruction));
        transaction.recentBlockhash = (yield connection.getLatestBlockhash(commitment)).blockhash;
        let signedTransaction = transaction;
        if (signers.length > 0) {
            signedTransaction = yield wallet.signTransaction(signedTransaction);
            for (let signer of signers) {
                signedTransaction = yield signer.signTransaction(signedTransaction);
            }
        }
        else {
            signedTransaction = yield wallet.signTransaction(signedTransaction);
        }
        return yield sendSignedTransaction({
            connection,
            signedTransaction,
            initialTransaction: transaction,
        }, logger);
    });
}
exports.sendTransactionWithRetry = sendTransactionWithRetry;
function sendSignedTransaction(_a, logger_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ signedTransaction, initialTransaction, connection, timeout = 1000 * 60, }, logger) {
        const rawTransaction = signedTransaction.serialize();
        const startTime = (0, solana_common_1.getUnixTs)();
        let slot = 0;
        const txId = yield connection.sendRawTransaction(rawTransaction, {
            skipPreflight: true,
        });
        logger === null || logger === void 0 ? void 0 : logger.log("Started awaiting confirmation for", txId);
        let done = false;
        (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            while (!done && (0, solana_common_1.getUnixTs)() - startTime < timeout) {
                connection.sendRawTransaction(rawTransaction, {
                    skipPreflight: true,
                });
                yield (0, solana_common_1.sleep)(500);
            }
        }))();
        try {
            const confirmation = yield awaitTransactionSignatureConfirmation(txId, timeout, connection, "processed", true, logger);
            if (!confirmation) {
                throw new Error("Timed out awaiting confirmation on transaction");
            }
            if (confirmation.err) {
                logger === null || logger === void 0 ? void 0 : logger.error(confirmation.err);
                throw new Error("Transaction failed: Custom instruction error");
            }
            slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;
        }
        catch (err) {
            logger === null || logger === void 0 ? void 0 : logger.error("Confirmation awaiting error caught", err);
            throw prettifyBlockchainError(err);
        }
        finally {
            done = true;
        }
        logger === null || logger === void 0 ? void 0 : logger.log("Latency (ms)", txId, (0, solana_common_1.getUnixTs)() - startTime);
        return { txId, slot };
    });
}
exports.sendSignedTransaction = sendSignedTransaction;
function prettifyBlockchainError(err) {
    const stringError = (0, sdk_common_1.getStringifiedData)(err);
    if (!stringError || !stringError.includes("InstructionError"))
        return err;
    if (stringError.includes("3012")) {
        return new Error("Transaction execution error: Order was already executed or cancelled");
    }
    if (stringError.includes("1")) {
        return new Error("Transaction execution error: Insufficient funds");
    }
    return err;
}
function awaitTransactionSignatureConfirmation(txid_1, timeout_1, connection_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (txid, timeout, connection, commitment = "recent", queryStatus = false, logger) {
        let done = false;
        let status = {
            slot: 0,
            confirmations: 0,
            err: null,
        };
        let subId = 0;
        status = yield new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            setTimeout(() => {
                if (done)
                    return;
                done = true;
                logger === null || logger === void 0 ? void 0 : logger.log("Rejecting for timeout...");
                reject({ timeout: true });
            }, timeout);
            try {
                subId = connection.onSignature(txid, (result, context) => {
                    done = true;
                    status = {
                        err: result.err,
                        slot: context.slot,
                        confirmations: 0,
                    };
                    if (result.err) {
                        logger === null || logger === void 0 ? void 0 : logger.log("Rejected via websocket", result.err);
                        reject(status);
                    }
                    else {
                        logger === null || logger === void 0 ? void 0 : logger.log("Resolved via websocket", result);
                        resolve(status);
                    }
                }, commitment);
            }
            catch (e) {
                done = true;
                logger === null || logger === void 0 ? void 0 : logger.error("WS error in setup", txid, e);
            }
            while (!done && queryStatus) {
                // eslint-disable-next-line no-loop-func
                ;
                (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    try {
                        const signatureStatuses = yield connection.getSignatureStatuses([txid]);
                        status = signatureStatuses && signatureStatuses.value[0];
                        if (!done) {
                            if (!status) {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST null result for", txid, status);
                            }
                            else if (status.err) {
                                logger === null || logger === void 0 ? void 0 : logger.error("REST error for", txid, status);
                                done = true;
                                reject(status.err);
                            }
                            else if (!status.confirmations) {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST no confirmations for", txid, status);
                            }
                            else {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST confirmation for", txid, status);
                                done = true;
                                resolve(status);
                            }
                        }
                    }
                    catch (e) {
                        if (!done) {
                            logger === null || logger === void 0 ? void 0 : logger.error("REST connection error: txid", txid, e);
                        }
                    }
                }))();
                yield (0, solana_common_1.sleep)(4000);
            }
        }));
        done = true;
        logger === null || logger === void 0 ? void 0 : logger.log("Returning status", status);
        return status;
    });
}
