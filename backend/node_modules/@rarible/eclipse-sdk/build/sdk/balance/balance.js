"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EclipseBalancesSdk = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("@rarible/utils");
class EclipseBalancesSdk {
    constructor(connection) {
        this.connection = connection;
    }
    getBalance(publicKey_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (publicKey, options = {}) {
            var _a;
            const balanceCents = yield this.connection.getBalance(publicKey, (_a = options.commitment) !== null && _a !== void 0 ? _a : "confirmed");
            return (0, utils_1.toBn)(balanceCents).dividedBy(web3_js_1.LAMPORTS_PER_SOL);
        });
    }
    getTokenBalance(owner_1, mint_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (owner, mint, options = {}) {
            var _a, _b, _c;
            const accounts = yield this.connection.getTokenAccountsByOwner(owner, { mint });
            let res = new utils_1.BigNumber(0);
            for (let tokenAccount of accounts.value) {
                const balance = yield this.connection.getTokenAccountBalance(tokenAccount.pubkey, (_a = options.commitment) !== null && _a !== void 0 ? _a : "confirmed");
                res = res.plus(new utils_1.BigNumber((_c = (_b = balance === null || balance === void 0 ? void 0 : balance.value) === null || _b === void 0 ? void 0 : _b.uiAmountString) !== null && _c !== void 0 ? _c : 0));
            }
            return res;
        });
    }
}
exports.EclipseBalancesSdk = EclipseBalancesSdk;
