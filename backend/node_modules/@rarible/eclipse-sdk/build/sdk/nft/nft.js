"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EclipseNftSdk = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const spl_token_1 = require("@solana/spl-token");
const prepared_transaction_1 = require("../prepared-transaction");
class EclipseNftSdk {
    constructor(connection, logger, accountSdk) {
        this.connection = connection;
        this.logger = logger;
        this.accountSdk = accountSdk;
    }
    transfer(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const sourceTokenAccount = (_a = request.tokenAccount) !== null && _a !== void 0 ? _a : (yield this.accountSdk.getTokenAccountForMint({
                owner: request.owner,
                mint: request.mint,
            }));
            if (!sourceTokenAccount) {
                throw new Error("Can't find current token account for for mint");
            }
            const tokenAmountToTransfer = (_b = (0, utils_1.toBn)(request.amount).toNumber()) !== null && _b !== void 0 ? _b : 1;
            const destinationTokenAccount = yield (0, spl_token_1.getAssociatedTokenAddress)(request.mint, request.to, false, spl_token_1.TOKEN_2022_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
            const instructions = [];
            const accountInfo = yield this.connection.getAccountInfo(destinationTokenAccount);
            if (accountInfo === null) {
                instructions.push((0, spl_token_1.createAssociatedTokenAccountInstruction)(request.signer.publicKey, destinationTokenAccount, request.to, request.mint, spl_token_1.TOKEN_2022_PROGRAM_ID, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID));
            }
            instructions.push((0, spl_token_1.createTransferInstruction)(sourceTokenAccount, destinationTokenAccount, request.owner, tokenAmountToTransfer, [], spl_token_1.TOKEN_2022_PROGRAM_ID));
            const preparedInstructions = {
                instructions,
                signers: [],
            };
            return new prepared_transaction_1.PreparedTransaction(this.connection, preparedInstructions, request.signer, this.logger, () => {
                this.logger.log(`${request.amount.toString()} token(s) ${request.mint.toString()} transferred to ${request.to.toString()}`);
            });
        });
    }
    burn(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const tokenAccount = (_a = request.tokenAccount) !== null && _a !== void 0 ? _a : (yield this.accountSdk.getTokenAccountForMint({
                owner: request.owner,
                mint: request.mint,
            }));
            if (!tokenAccount) {
                throw new Error("Can't find current token account for for mint");
            }
            const tokenAmountToBurn = (_b = (0, utils_1.toBn)(request.amount).toNumber()) !== null && _b !== void 0 ? _b : 1;
            const instructions = {
                instructions: [
                    (0, spl_token_1.createBurnInstruction)(tokenAccount, request.mint, request.owner, tokenAmountToBurn, [], spl_token_1.TOKEN_2022_PROGRAM_ID),
                ],
                signers: [],
            };
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log(`${request.amount.toString()} token(s) ${request.mint.toString()} burned`);
            });
        });
    }
}
exports.EclipseNftSdk = EclipseNftSdk;
