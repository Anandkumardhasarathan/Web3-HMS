"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeOrder = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const spl_token_1 = require("@solana/spl-token");
const marketplace_program_1 = require("../core/marketplace-program");
const utils_1 = require("../utils");
function executeOrder(request, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const marketProgram = (0, marketplace_program_1.getProgramInstanceRaribleMarketplace)(request.connection);
        const eventAuthority = (0, utils_1.getEventAuthority)();
        const taker = request.signer.publicKey;
        const orderAddress = request.orderAddress;
        const nftMint = request.nftMint;
        const extraAccountParams = request.extraAccountParams;
        const order = yield (0, utils_1.fetchOrderByAddress)(request.connection, orderAddress.toString());
        if (!order) {
            throw new Error(`Order not found ${orderAddress.toString()}`);
        }
        const market = yield (0, utils_1.fetchMarketByAddress)(request.connection, order.market.toString());
        if (!market) {
            throw new Error(`Market not found ${order.market.toString()}`);
        }
        const nftTokenProgram = yield (0, utils_1.getTokenProgramFromMint)(request.connection, nftMint.toString());
        const paymentTokenProgram = yield (0, utils_1.getTokenProgramFromMint)(request.connection, order.paymentMint.toString());
        if (!paymentTokenProgram || !nftTokenProgram) {
            throw new Error(`Token programs not found. Nft mint: ${nftMint.toString()}, payment mint: ${order.paymentMint.toString()}`);
        }
        const nftProgram = yield (0, utils_1.getNftProgramFromMint)(request.connection, nftMint.toBase58());
        const isBuy = order.side === 0; // Assuming 0 represents Buy
        const nftRecipient = isBuy ? order.owner : taker;
        const nftFunder = isBuy ? taker : order.owner;
        const paymentFunder = isBuy ? new web3_js_1.PublicKey(orderAddress) : taker;
        const paymentRecipient = isBuy ? taker : order.owner;
        const buyerPaymentTa = (0, utils_1.getAtaAddress)(order.paymentMint.toBase58(), paymentFunder.toBase58(), paymentTokenProgram.toBase58());
        const sellerPaymentTa = (0, utils_1.getAtaAddress)(order.paymentMint.toBase58(), paymentRecipient.toBase58(), paymentTokenProgram.toBase58());
        const buyerNftTa = (0, utils_1.getAtaAddress)(nftMint.toBase58(), nftRecipient.toBase58(), nftTokenProgram.toBase58());
        const sellerNftTa = (0, utils_1.getAtaAddress)(nftMint.toBase58(), nftFunder.toBase58(), nftTokenProgram.toBase58());
        const feeRecipient = market.feeRecipient;
        const feeRecipientTa = (0, utils_1.getAtaAddress)(order.paymentMint.toBase58(), feeRecipient.toBase58(), paymentTokenProgram.toBase58());
        const feeRecipient2 = market.feeRecipient2;
        const feeRecipient2Ta = (0, utils_1.getAtaAddress)(order.paymentMint.toBase58(), feeRecipient2.toBase58(), paymentTokenProgram.toBase58());
        const remainingAccounts = yield (0, utils_1.getRemainingAccountsForMint)(request.connection, nftMint.toBase58(), extraAccountParams);
        yield fillRemainingAccountWithRoyalties(request, remainingAccounts, paymentTokenProgram, order.paymentMint, logger);
        const group = yield getTokenGroup(request.connection, nftMint, "confirmed", spl_token_1.TOKEN_2022_PROGRAM_ID);
        const instruction = yield marketProgram.methods
            .fillOrderV2(new anchor_1.BN(request.amountToFill))
            .accountsStrict({
            taker: taker,
            maker: order.owner,
            market: order.market,
            order: new web3_js_1.PublicKey(orderAddress),
            buyerNftTa,
            buyerPaymentTa,
            sellerNftTa,
            sellerPaymentTa,
            nftTokenProgram,
            paymentTokenProgram,
            nftProgram: nftProgram !== null && nftProgram !== void 0 ? nftProgram : web3_js_1.PublicKey.default,
            associatedTokenProgram: spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
            program: marketProgram.programId,
            eventAuthority,
            paymentMint: order.paymentMint,
            nftMint,
            sysvarInstructions: web3_js_1.SYSVAR_INSTRUCTIONS_PUBKEY,
            feeRecipient,
            feeRecipientTa,
            feeRecipient2,
            feeRecipient2Ta,
            group,
        })
            .remainingAccounts(remainingAccounts)
            .instruction();
        const instructions = [];
        instructions.push(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 850000,
        }));
        instructions.push(instruction);
        return {
            instructions,
            signers: [],
        };
    });
}
exports.executeOrder = executeOrder;
function getTokenGroup(connection_1, address_1, commitment_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (connection, address, commitment, programId = spl_token_1.TOKEN_2022_PROGRAM_ID) {
        const mintInfo = yield (0, spl_token_1.getMint)(connection, address, commitment, programId);
        const data = (0, spl_token_1.getExtensionData)(spl_token_1.ExtensionType.GroupMemberPointer, mintInfo.tlvData);
        if (data === null) {
            return null;
        }
        const groupData = data.slice(32, 32 + 32);
        return new web3_js_1.PublicKey(groupData);
    });
}
function parseCreatorInfo(key, value, creatorsInfo, logger) {
    try {
        const creatorPubkey = new web3_js_1.PublicKey(key);
        const percentage = parseInt(value, 10);
        if (percentage > 0 && percentage <= 100) {
            creatorsInfo.push({
                pubkey: creatorPubkey,
                percentage: percentage,
            });
        }
        else {
            logger.log(`Invalid percentage for creator ${key}: ${value}`);
        }
    }
    catch (e) {
        logger.log(`Invalid public key for creator in additionalMetadata: ${key}`);
    }
}
function fillRemainingAccountWithRoyalties(request, remainingAccounts, paymentTokenProgram, paymentMint, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const metadata = yield (0, spl_token_1.getTokenMetadata)(request.connection, request.nftMint, "confirmed", spl_token_1.TOKEN_2022_PROGRAM_ID);
        if (!metadata) {
            logger.log("Try to fill remaining accounts with royalties. No metadata found for the NFT mint");
            return;
        }
        let accounts = fixForSpecificNFTs(metadata, paymentTokenProgram, paymentMint);
        if (accounts.length > 0) {
            remainingAccounts.push(...accounts);
            return;
        }
        let hasRoyalties = false;
        const creatorsInfo = [];
        let royaltyBasisPoints = 0;
        const additionalMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.additionalMetadata;
        if (additionalMetadata && additionalMetadata.length > 0) {
            for (const [key, value] of additionalMetadata) {
                if (key === "royalty_basis_points") {
                    royaltyBasisPoints = parseInt(value, 10);
                    if (royaltyBasisPoints > 0) {
                        hasRoyalties = true;
                    }
                }
                else {
                    parseCreatorInfo(key, value, creatorsInfo, logger);
                }
            }
        }
        // Validate that total percentages add up to 100
        const totalPercentage = creatorsInfo.reduce((acc, creator) => acc + creator.percentage, 0);
        if (totalPercentage > 100) {
            logger.log("Total royalties percentages exceed 100%, skipping the royalties");
            hasRoyalties = false;
        }
        if (hasRoyalties) {
            for (const creatorInfo of creatorsInfo) {
                remainingAccounts.push({
                    pubkey: creatorInfo.pubkey,
                    isSigner: false,
                    isWritable: true,
                });
                const creatorPaymentTa = (0, utils_1.getAtaAddress)(paymentMint.toBase58(), creatorInfo.pubkey.toBase58(), paymentTokenProgram.toBase58());
                remainingAccounts.push({
                    pubkey: creatorPaymentTa,
                    isSigner: false,
                    isWritable: true,
                });
            }
        }
    });
}
function fixForSpecificNFTs(metadata, paymentTokenProgram, paymentMint) {
    const remainingAccounts = [];
    // for these NFTs there is wrong creator Address in metadata,
    // so we need to hardcode proper one
    if ((metadata === null || metadata === void 0 ? void 0 : metadata.symbol) === "POD") {
        const creatorAddress = new web3_js_1.PublicKey("J5xffSinbAQw65TsphSZ8gfaNGAPEfNWL9wwzGNdm3PR");
        remainingAccounts.push({
            pubkey: creatorAddress,
            isSigner: false,
            isWritable: true,
        });
        const creatorPaymentTa = (0, utils_1.getAtaAddress)(paymentMint.toBase58(), creatorAddress.toBase58(), paymentTokenProgram.toBase58());
        remainingAccounts.push({
            pubkey: creatorPaymentTa,
            isSigner: false,
            isWritable: true,
        });
    }
    return remainingAccounts;
}
