"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EclipseOrderSdk = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const prepared_transaction_1 = require("../prepared-transaction");
const utils_2 = require("../utils");
const sell_1 = require("./sell");
const cancel_sell_1 = require("./cancel-sell");
const execute_order_1 = require("./execute-order");
const initialize_market_1 = require("./initialize-market");
const bid_1 = require("./bid");
const cancel_bid_1 = require("./cancel-bid");
class EclipseOrderSdk {
    constructor(connection, logger) {
        this.connection = connection;
        this.logger = logger;
    }
    initializeMarket(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, initialize_market_1.initializeMarket)({
                connection: this.connection,
                signer: request.signer,
                marketIdentifier: request.marketIdentifier,
                feeRecipient: request.feeRecipient,
                feeRecipient2: request.feeRecipient2,
                feeBps: request.feeBps,
                feeBps2: request.feeBps2,
            });
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log("Initialize market", request.marketIdentifier, "with feeRecipient", request.feeRecipient.toString(), "and feeBps", request.feeBps.toString);
            });
        });
    }
    sell(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, sell_1.sell)({
                connection: this.connection,
                marketIdentifier: request.marketIdentifier,
                signer: request.signer,
                nftMint: request.nftMint,
                paymentMint: request.paymentMint,
                price: request.price,
                tokensAmount: request.tokensAmount,
                extraAccountParams: request.extraAccountParams,
            });
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log("Set", request.tokensAmount, request.nftMint.toString(), "for sale for", request.price);
            });
        });
    }
    bid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, bid_1.bid)({
                connection: this.connection,
                marketIdentifier: request.marketIdentifier,
                signer: request.signer,
                nftMint: request.nftMint,
                paymentMint: request.paymentMint,
                price: request.price,
                tokensAmount: request.tokensAmount,
            });
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                var _a;
                this.logger.log("Bid token", (_a = request.nftMint) === null || _a === void 0 ? void 0 : _a.toString(), "with price", request.price, "and count", request.tokensAmount, "and currency", request.paymentMint.toString());
            });
        });
    }
    cancelSell(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, cancel_sell_1.cancelSell)({
                connection: this.connection,
                signer: request.signer,
                orderAddress: request.orderAddress,
                extraAccountParams: request.extraAccountParams,
            });
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log("Cancelled order of", request.orderAddress.toString());
            });
        });
    }
    cancelBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, cancel_bid_1.cancelBid)({
                connection: this.connection,
                signer: request.signer,
                orderAddress: request.orderAddress,
            });
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log("Cancelled order of", request.orderAddress.toString());
            });
        });
    }
    executeOrder(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const instructions = yield (0, execute_order_1.executeOrder)({
                connection: this.connection,
                signer: request.signer,
                nftMint: request.nftMint,
                amountToFill: request.amountToFill,
                orderAddress: request.orderAddress,
                extraAccountParams: request.extraAccountParams,
            }, this.logger);
            return new prepared_transaction_1.PreparedTransaction(this.connection, instructions, request.signer, this.logger, () => {
                this.logger.log("Execute order", request.orderAddress.toString(), "for mint", request.nftMint.toString(), "number of tokens", request.amountToFill);
            });
        });
    }
    getMarketPlace(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const marketAddress = (0, utils_2.getMarketPda)(request.marketIdentifier.toString());
            const market = yield (0, utils_2.fetchMarketByAddress)(this.connection, marketAddress.toString());
            if (!market) {
                throw new Error(`Market not found ${marketAddress.toString()}`);
            }
            this.logger.log("Get marketplace", request.marketIdentifier.toString());
            return {
                marketIdentifier: request.marketIdentifier,
                feeRecipient: market.feeRecipient,
                feeRecipient2: market.feeRecipient2,
                feeBps: new utils_1.BigNumber(market.feeBps.toString()),
                feeBps2: market.feeBps2 ? new utils_1.BigNumber(market.feeBps2.toString()) : undefined,
                initializer: market.initializer,
                version: market.version,
            };
        });
    }
}
exports.EclipseOrderSdk = EclipseOrderSdk;
