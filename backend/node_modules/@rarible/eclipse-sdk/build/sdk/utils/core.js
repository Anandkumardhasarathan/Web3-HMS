"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toLamports = exports.getGroupMemberAccount = exports.getDistributionAccountPda = exports.getApproveAccountPda = exports.getExtraMetasAccountPda = exports.getEventAuthority = exports.getOrderAccount = exports.getVerificationPda = exports.getMarketPda = exports.getAtaAddress = exports.getProgramAddress = exports.getRemainingAccountsForMint = exports.isWnsNft = exports.isMetaplexMetadataAccount = exports.getNftProgramFromMint = exports.getTokenProgramFromMint = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const utils_1 = require("../utils");
const marketplace_program_1 = require("../core/marketplace-program");
const getTokenProgramFromMint = (connection, mint) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const mintPubkey = new web3_js_1.PublicKey(mint);
    try {
        yield (0, spl_token_1.getMint)(connection, mintPubkey, undefined, spl_token_1.TOKEN_PROGRAM_ID);
        return spl_token_1.TOKEN_PROGRAM_ID;
    }
    catch (e) {
        try {
            yield (0, spl_token_1.getMint)(connection, mintPubkey, undefined, spl_token_1.TOKEN_2022_PROGRAM_ID);
            return spl_token_1.TOKEN_2022_PROGRAM_ID;
        }
        catch (e) {
            return undefined;
        }
    }
});
exports.getTokenProgramFromMint = getTokenProgramFromMint;
const getNftProgramFromMint = (connection, nftMint) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const mintProgram = yield (0, exports.getTokenProgramFromMint)(connection, nftMint);
    if (!mintProgram) {
        return undefined;
    }
    if (mintProgram === spl_token_1.TOKEN_PROGRAM_ID) {
        const isMetaplex = yield (0, exports.isMetaplexMetadataAccount)(connection, nftMint);
        if (isMetaplex) {
            return utils_1.METAPLEX_METADATA_PROGRAM_ID;
        }
    }
    if (mintProgram === spl_token_1.TOKEN_2022_PROGRAM_ID) {
        const isWns = yield (0, exports.isWnsNft)(connection, nftMint);
        if (isWns) {
            return utils_1.WNS_PROGRAM_ID;
        }
    }
    return undefined;
});
exports.getNftProgramFromMint = getNftProgramFromMint;
const isMetaplexMetadataAccount = (connection, mint) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const mintPubkey = new web3_js_1.PublicKey(mint);
    const metadataAccount = (0, exports.getProgramAddress)([Buffer.from(utils_1.METADATA_SEED), utils_1.METAPLEX_METADATA_PROGRAM_ID.toBytes(), mintPubkey.toBytes()], utils_1.METAPLEX_METADATA_PROGRAM_ID);
    try {
        yield connection.getAccountInfo(metadataAccount);
        return true;
    }
    catch (e) {
        return false;
    }
});
exports.isMetaplexMetadataAccount = isMetaplexMetadataAccount;
const isWnsNft = (connection, mint) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const mintPubkey = new web3_js_1.PublicKey(mint);
    const metadata = yield (0, spl_token_1.getTokenMetadata)(connection, mintPubkey);
    if (metadata === null) {
        return false;
    }
    const extraMeta = metadata.additionalMetadata;
    const royalties = extraMeta.filter(m => m[0] === "royalty_basis_points");
    // TODO : check differently
    if (royalties.length > 0) {
        return false;
    }
    return false;
});
exports.isWnsNft = isWnsNft;
const getRemainingAccountsForMint = (connection, mint, wnsParams) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const remainingAccounts = [];
    const nftProgram = yield (0, exports.getNftProgramFromMint)(connection, mint);
    if (nftProgram === utils_1.WNS_PROGRAM_ID) {
        if (!wnsParams) {
            return [];
        }
        const extraMetaPda = (0, exports.getExtraMetasAccountPda)(mint);
        const approveAccount = (0, exports.getApproveAccountPda)(mint);
        const distributionAccount = (0, exports.getDistributionAccountPda)(wnsParams.groupMint, wnsParams.paymentMint);
        const paymentTokenProgram = yield (0, exports.getTokenProgramFromMint)(connection, wnsParams.paymentMint);
        const groupMemberAccount = (0, exports.getGroupMemberAccount)(mint);
        const distributionTokenAccount = paymentTokenProgram &&
            (0, exports.getAtaAddress)(wnsParams.paymentMint, distributionAccount.toString(), paymentTokenProgram.toString());
        remainingAccounts.push(...[
            {
                pubkey: approveAccount,
                isWritable: true,
                isSigner: false,
            },
            {
                pubkey: distributionAccount,
                isWritable: true,
                isSigner: false,
            },
            {
                pubkey: distributionTokenAccount !== null && distributionTokenAccount !== void 0 ? distributionTokenAccount : distributionAccount,
                isWritable: true,
                isSigner: false,
            },
            {
                pubkey: utils_1.WNS_DISTRIBUTION_PROGRAM_ID,
                isWritable: false,
                isSigner: false,
            },
            {
                pubkey: groupMemberAccount,
                isWritable: false,
                isSigner: false,
            },
            {
                pubkey: new web3_js_1.PublicKey(wnsParams.paymentMint),
                isWritable: false,
                isSigner: false,
            },
            {
                pubkey: extraMetaPda,
                isWritable: false,
                isSigner: false,
            },
            {
                pubkey: approveAccount,
                isWritable: false,
                isSigner: false,
            },
            {
                pubkey: utils_1.WNS_PROGRAM_ID,
                isWritable: false,
                isSigner: false,
            },
        ]);
        return remainingAccounts;
    }
    // Need todo metaplex pNFT accounts
    return [];
});
exports.getRemainingAccountsForMint = getRemainingAccountsForMint;
const getProgramAddress = (seeds, programId) => {
    const [key] = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId);
    return key;
};
exports.getProgramAddress = getProgramAddress;
const getAtaAddress = (mint, owner, tokenProgram) => (0, exports.getProgramAddress)([new web3_js_1.PublicKey(owner).toBuffer(), new web3_js_1.PublicKey(tokenProgram).toBuffer(), new web3_js_1.PublicKey(mint).toBuffer()], spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
exports.getAtaAddress = getAtaAddress;
// MARKET ACCOUNTS
const getMarketPda = (marketIdentifier) => {
    const [marketAccount] = web3_js_1.PublicKey.findProgramAddressSync([anchor_1.utils.bytes.utf8.encode("market"), new web3_js_1.PublicKey(marketIdentifier).toBuffer()], marketplace_program_1.PROGRAM_ID_MARKETPLACE);
    return marketAccount;
};
exports.getMarketPda = getMarketPda;
const getVerificationPda = (marketAddress, nftMint) => {
    const [marketAccount] = web3_js_1.PublicKey.findProgramAddressSync([
        anchor_1.utils.bytes.utf8.encode("verification"),
        new web3_js_1.PublicKey(nftMint).toBuffer(),
        new web3_js_1.PublicKey(marketAddress).toBuffer(),
    ], marketplace_program_1.PROGRAM_ID_MARKETPLACE);
    return marketAccount;
};
exports.getVerificationPda = getVerificationPda;
const getOrderAccount = (nonce, marketAddress, user) => {
    const [marketAccount] = web3_js_1.PublicKey.findProgramAddressSync([
        anchor_1.utils.bytes.utf8.encode("order"),
        new web3_js_1.PublicKey(nonce).toBuffer(),
        new web3_js_1.PublicKey(marketAddress).toBuffer(),
        new web3_js_1.PublicKey(user).toBuffer(),
    ], marketplace_program_1.PROGRAM_ID_MARKETPLACE);
    return marketAccount;
};
exports.getOrderAccount = getOrderAccount;
const getEventAuthority = () => {
    const [eventAuthority] = web3_js_1.PublicKey.findProgramAddressSync([anchor_1.utils.bytes.utf8.encode("__event_authority")], marketplace_program_1.PROGRAM_ID_MARKETPLACE);
    return eventAuthority;
};
exports.getEventAuthority = getEventAuthority;
const getExtraMetasAccountPda = (mint) => {
    const [extraMetasAccount] = web3_js_1.PublicKey.findProgramAddressSync([anchor_1.utils.bytes.utf8.encode("extra-account-metas"), new web3_js_1.PublicKey(mint).toBuffer()], utils_1.WNS_PROGRAM_ID);
    return extraMetasAccount;
};
exports.getExtraMetasAccountPda = getExtraMetasAccountPda;
const getApproveAccountPda = (mint) => {
    const [approveAccount] = web3_js_1.PublicKey.findProgramAddressSync([anchor_1.utils.bytes.utf8.encode("approve-account"), new web3_js_1.PublicKey(mint).toBuffer()], utils_1.WNS_PROGRAM_ID);
    return approveAccount;
};
exports.getApproveAccountPda = getApproveAccountPda;
const getDistributionAccountPda = (groupMint, paymentMint) => {
    const [distributionAccount] = web3_js_1.PublicKey.findProgramAddressSync([new web3_js_1.PublicKey(groupMint).toBuffer(), new web3_js_1.PublicKey(paymentMint).toBuffer()], utils_1.WNS_DISTRIBUTION_PROGRAM_ID);
    return distributionAccount;
};
exports.getDistributionAccountPda = getDistributionAccountPda;
const getGroupMemberAccount = (nftMint) => {
    const [groupMemberAccount] = web3_js_1.PublicKey.findProgramAddressSync([anchor_1.utils.bytes.utf8.encode("member"), new web3_js_1.PublicKey(nftMint).toBuffer()], utils_1.WNS_PROGRAM_ID);
    return groupMemberAccount;
};
exports.getGroupMemberAccount = getGroupMemberAccount;
function toLamports(value) {
    return value.toNumber() * 1000000000;
}
exports.toLamports = toLamports;
