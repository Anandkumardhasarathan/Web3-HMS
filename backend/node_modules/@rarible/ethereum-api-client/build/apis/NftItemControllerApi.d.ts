/**
 * OpenAPI definition
 * # Exciting News  Hey there, amazing developers! üëã  We\'ve got some fantastic news to share that will make your experience with our product even better. We\'re thrilled to announce the implementation of API-Keys, which brings a new level of control and convenience to your development process. So, let\'s dive right into the details! ‚ú®  ## API-Keys for Enhanced Functionality üîë  Starting now, we have introduced API-Keys to streamline your interactions with our methods. You might have noticed a slight change while making requests ‚Äì now, all you need to do is include the parameter `X-API-KEY` in the Header of your request. Simple as that!  ## Get Your API-Key in a Snap! ‚ö°Ô∏è  Securing your API-Key is a breeze. We\'ve made the process super user-friendly to ensure you can get started quickly. Just head over to our website and fill out a simple form. Once you\'ve done that, your shiny new API-Key will be delivered straight to your email inbox. Easy peasy! üìß  [Get Your API-Key Here](https://api.rarible.org/registration) [Configure SDK with API-key](https://github.com/rarible/sdk#api-querying)  ## Unlock the Power of the Rarible Protocol üîì  As passionate developers, we know you\'re always hungry for knowledge and eager to explore new frontiers. That\'s why we invite you to discover the incredible world of the Rarible Protocol. By visiting our dedicated protocol page, you\'ll gain access to a treasure trove of useful information, tips, and insights that will elevate your development skills to new heights. üöÄ  [Explore the Rarible Protocol](https://rarible.org)  So, buckle up and get ready for an enhanced development journey with our API-Keys. We\'re excited to see what you\'ll create using our revamped system! üí™üöÄ  Stay curious, keep innovating, and happy coding! ‚ú®  [P.S. Join our Discord Server to stay up to date and ask questions](https://discord.gg/rarifoundation)
 *
 * The version of the OpenAPI document: v0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import * as runtime from '../runtime';
import { BurnLazyNftForm, EthereumApiErrorBadRequest, EthereumApiErrorEntityNotFound, EthereumApiErrorServerError, LazyNft, NftItem, NftItemIds, NftItemMeta, NftItemRoyaltyList, NftItems } from '../models';
export interface DeleteLazyMintNftAssetRequest {
    itemId: string;
    burnLazyNftForm: BurnLazyNftForm;
}
export interface GetNftAllItemsRequest {
    continuation?: string;
    size?: number;
    showDeleted?: boolean;
    lastUpdatedFrom?: number;
    lastUpdatedTo?: number;
}
export interface GetNftItemByIdRequest {
    itemId: string;
}
export interface GetNftItemMetaByIdRequest {
    itemId: string;
}
export interface GetNftItemRoyaltyByIdRequest {
    itemId: string;
}
export interface GetNftItemsByCollectionRequest {
    collection: string;
    owner?: string;
    continuation?: string;
    size?: number;
}
export interface GetNftItemsByCreatorRequest {
    creator: string;
    continuation?: string;
    size?: number;
}
export interface GetNftItemsByIdsRequest {
    nftItemIds: NftItemIds;
}
export interface GetNftItemsByOwnerRequest {
    owner: string;
    continuation?: string;
    size?: number;
}
export interface GetNftLazyItemByIdRequest {
    itemId: string;
}
export interface ResetNftItemMetaByIdRequest {
    itemId: string;
}
/**
 * no description
 */
export declare class NftItemControllerApi extends runtime.BaseAPI {
    /**
     * Delete Lazy mint of NFT
     */
    deleteLazyMintNftAssetRaw(requestParameters: DeleteLazyMintNftAssetRequest): Promise<DeleteLazyMintNftAssetResponse>;
    /**
     * Delete Lazy mint of NFT
     */
    deleteLazyMintNftAsset(requestParameters: DeleteLazyMintNftAssetRequest): Promise<void>;
    /**
     * Returns all NFT items
     */
    getNftAllItemsRaw(requestParameters: GetNftAllItemsRequest): Promise<GetNftAllItemsResponse>;
    /**
     * Returns all NFT items
     */
    getNftAllItems(requestParameters: GetNftAllItemsRequest): Promise<NftItems>;
    /**
     * Returns the NFT item by identifier
     */
    getNftItemByIdRaw(requestParameters: GetNftItemByIdRequest): Promise<GetNftItemByIdResponse>;
    /**
     * Returns the NFT item by identifier
     */
    getNftItemById(requestParameters: GetNftItemByIdRequest): Promise<NftItem>;
    /**
     * Returns metadata of specified NFT item
     */
    getNftItemMetaByIdRaw(requestParameters: GetNftItemMetaByIdRequest): Promise<GetNftItemMetaByIdResponse>;
    /**
     * Returns metadata of specified NFT item
     */
    getNftItemMetaById(requestParameters: GetNftItemMetaByIdRequest): Promise<NftItemMeta>;
    /**
     * Returns item royalty by identifier
     */
    getNftItemRoyaltyByIdRaw(requestParameters: GetNftItemRoyaltyByIdRequest): Promise<GetNftItemRoyaltyByIdResponse>;
    /**
     * Returns item royalty by identifier
     */
    getNftItemRoyaltyById(requestParameters: GetNftItemRoyaltyByIdRequest): Promise<NftItemRoyaltyList>;
    /**
     * Returns the NFT items by collection
     */
    getNftItemsByCollectionRaw(requestParameters: GetNftItemsByCollectionRequest): Promise<GetNftItemsByCollectionResponse>;
    /**
     * Returns the NFT items by collection
     */
    getNftItemsByCollection(requestParameters: GetNftItemsByCollectionRequest): Promise<NftItems>;
    /**
     * Returns the NFT item by creator
     */
    getNftItemsByCreatorRaw(requestParameters: GetNftItemsByCreatorRequest): Promise<GetNftItemsByCreatorResponse>;
    /**
     * Returns the NFT item by creator
     */
    getNftItemsByCreator(requestParameters: GetNftItemsByCreatorRequest): Promise<NftItems>;
    /**
     * Returns the NFT item by identifier
     */
    getNftItemsByIdsRaw(requestParameters: GetNftItemsByIdsRequest): Promise<GetNftItemsByIdsResponse>;
    /**
     * Returns the NFT item by identifier
     */
    getNftItemsByIds(requestParameters: GetNftItemsByIdsRequest): Promise<Array<NftItem>>;
    /**
     * Returns the NFT item by owner
     */
    getNftItemsByOwnerRaw(requestParameters: GetNftItemsByOwnerRequest): Promise<GetNftItemsByOwnerResponse>;
    /**
     * Returns the NFT item by owner
     */
    getNftItemsByOwner(requestParameters: GetNftItemsByOwnerRequest): Promise<NftItems>;
    /**
     * Returns the NFT lazy item by identifier
     */
    getNftLazyItemByIdRaw(requestParameters: GetNftLazyItemByIdRequest): Promise<GetNftLazyItemByIdResponse>;
    /**
     * Returns the NFT lazy item by identifier
     */
    getNftLazyItemById(requestParameters: GetNftLazyItemByIdRequest): Promise<LazyNft>;
    /**
     * Deletes the NFT item meta by identifier. In future indexer won\'t store metadata, so this endpoint will be removed.
     */
    resetNftItemMetaByIdRaw(requestParameters: ResetNftItemMetaByIdRequest): Promise<ResetNftItemMetaByIdResponse>;
    /**
     * Deletes the NFT item meta by identifier. In future indexer won\'t store metadata, so this endpoint will be removed.
     */
    resetNftItemMetaById(requestParameters: ResetNftItemMetaByIdRequest): Promise<void>;
}
export type DeleteLazyMintNftAsset204 = {
    status: 204;
};
export type DeleteLazyMintNftAsset400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type DeleteLazyMintNftAsset404 = {
    status: 404;
    value: EthereumApiErrorEntityNotFound;
};
export type DeleteLazyMintNftAsset500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type DeleteLazyMintNftAssetResponse = DeleteLazyMintNftAsset204 | DeleteLazyMintNftAsset400 | DeleteLazyMintNftAsset404 | DeleteLazyMintNftAsset500;
export type GetNftAllItems200 = {
    status: 200;
    value: NftItems;
};
export type GetNftAllItems400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftAllItems500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftAllItemsResponse = GetNftAllItems200 | GetNftAllItems400 | GetNftAllItems500;
export type GetNftItemById200 = {
    status: 200;
    value: NftItem;
};
export type GetNftItemById404 = {
    status: 404;
    value: EthereumApiErrorEntityNotFound;
};
export type GetNftItemById400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemById500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemByIdResponse = GetNftItemById200 | GetNftItemById404 | GetNftItemById400 | GetNftItemById500;
export type GetNftItemMetaById200 = {
    status: 200;
    value: NftItemMeta;
};
export type GetNftItemMetaById400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemMetaById404 = {
    status: 404;
    value: EthereumApiErrorEntityNotFound;
};
export type GetNftItemMetaById500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemMetaByIdResponse = GetNftItemMetaById200 | GetNftItemMetaById400 | GetNftItemMetaById404 | GetNftItemMetaById500;
export type GetNftItemRoyaltyById200 = {
    status: 200;
    value: NftItemRoyaltyList;
};
export type GetNftItemRoyaltyById400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemRoyaltyById500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemRoyaltyByIdResponse = GetNftItemRoyaltyById200 | GetNftItemRoyaltyById400 | GetNftItemRoyaltyById500;
export type GetNftItemsByCollection200 = {
    status: 200;
    value: NftItems;
};
export type GetNftItemsByCollection400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemsByCollection500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemsByCollectionResponse = GetNftItemsByCollection200 | GetNftItemsByCollection400 | GetNftItemsByCollection500;
export type GetNftItemsByCreator200 = {
    status: 200;
    value: NftItems;
};
export type GetNftItemsByCreator400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemsByCreator500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemsByCreatorResponse = GetNftItemsByCreator200 | GetNftItemsByCreator400 | GetNftItemsByCreator500;
export type GetNftItemsByIds200 = {
    status: 200;
    value: Array<NftItem>;
};
export type GetNftItemsByIds400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemsByIds500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemsByIdsResponse = GetNftItemsByIds200 | GetNftItemsByIds400 | GetNftItemsByIds500;
export type GetNftItemsByOwner200 = {
    status: 200;
    value: NftItems;
};
export type GetNftItemsByOwner400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftItemsByOwner500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftItemsByOwnerResponse = GetNftItemsByOwner200 | GetNftItemsByOwner400 | GetNftItemsByOwner500;
export type GetNftLazyItemById200 = {
    status: 200;
    value: LazyNft;
};
export type GetNftLazyItemById404 = {
    status: 404;
    value: EthereumApiErrorEntityNotFound;
};
export type GetNftLazyItemById400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type GetNftLazyItemById500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type GetNftLazyItemByIdResponse = GetNftLazyItemById200 | GetNftLazyItemById404 | GetNftLazyItemById400 | GetNftLazyItemById500;
export type ResetNftItemMetaById200 = {
    status: 200;
};
export type ResetNftItemMetaById400 = {
    status: 400;
    value: EthereumApiErrorBadRequest;
};
export type ResetNftItemMetaById500 = {
    status: 500;
    value: EthereumApiErrorServerError;
};
export type ResetNftItemMetaByIdResponse = ResetNftItemMetaById200 | ResetNftItemMetaById400 | ResetNftItemMetaById500;
