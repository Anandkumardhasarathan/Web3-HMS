"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * # Exciting News  Hey there, amazing developers! üëã  We\'ve got some fantastic news to share that will make your experience with our product even better. We\'re thrilled to announce the implementation of API-Keys, which brings a new level of control and convenience to your development process. So, let\'s dive right into the details! ‚ú®  ## API-Keys for Enhanced Functionality üîë  Starting now, we have introduced API-Keys to streamline your interactions with our methods. You might have noticed a slight change while making requests ‚Äì now, all you need to do is include the parameter `X-API-KEY` in the Header of your request. Simple as that!  ## Get Your API-Key in a Snap! ‚ö°Ô∏è  Securing your API-Key is a breeze. We\'ve made the process super user-friendly to ensure you can get started quickly. Just head over to our website and fill out a simple form. Once you\'ve done that, your shiny new API-Key will be delivered straight to your email inbox. Easy peasy! üìß  [Get Your API-Key Here](https://api.rarible.org/registration) [Configure SDK with API-key](https://github.com/rarible/sdk#api-querying)  ## Unlock the Power of the Rarible Protocol üîì  As passionate developers, we know you\'re always hungry for knowledge and eager to explore new frontiers. That\'s why we invite you to discover the incredible world of the Rarible Protocol. By visiting our dedicated protocol page, you\'ll gain access to a treasure trove of useful information, tips, and insights that will elevate your development skills to new heights. üöÄ  [Explore the Rarible Protocol](https://rarible.org)  So, buckle up and get ready for an enhanced development journey with our API-Keys. We\'re excited to see what you\'ll create using our revamped system! üí™üöÄ  Stay curious, keep innovating, and happy coding! ‚ú®  [P.S. Join our Discord Server to stay up to date and ask questions](https://discord.gg/rarifoundation)
 *
 * The version of the OpenAPI document: v0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NftItemControllerApi = void 0;
const runtime = __importStar(require("../runtime"));
/**
 * no description
 */
class NftItemControllerApi extends runtime.BaseAPI {
    /**
     * Delete Lazy mint of NFT
     */
    deleteLazyMintNftAssetRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling deleteLazyMintNftAsset.');
            }
            if (requestParameters.burnLazyNftForm === null || requestParameters.burnLazyNftForm === undefined) {
                throw new runtime.RequiredError('burnLazyNftForm', 'Required parameter requestParameters.burnLazyNftForm was null or undefined when calling deleteLazyMintNftAsset.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}/lazy/delete`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.burnLazyNftForm,
            });
            if (response.status === 204) {
                return {
                    status: 204,
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 404) {
                return {
                    status: 404,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Delete Lazy mint of NFT
     */
    deleteLazyMintNftAsset(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deleteLazyMintNftAssetRaw(requestParameters);
        });
    }
    /**
     * Returns all NFT items
     */
    getNftAllItemsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.continuation !== undefined) {
                queryParameters['continuation'] = requestParameters.continuation;
            }
            if (requestParameters.size !== undefined) {
                queryParameters['size'] = requestParameters.size;
            }
            if (requestParameters.showDeleted !== undefined) {
                queryParameters['showDeleted'] = requestParameters.showDeleted;
            }
            if (requestParameters.lastUpdatedFrom !== undefined) {
                queryParameters['lastUpdatedFrom'] = requestParameters.lastUpdatedFrom;
            }
            if (requestParameters.lastUpdatedTo !== undefined) {
                queryParameters['lastUpdatedTo'] = requestParameters.lastUpdatedTo;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/all`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns all NFT items
     */
    getNftAllItems(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftAllItemsRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by identifier
     */
    getNftItemByIdRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling getNftItemById.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 404) {
                return {
                    status: 404,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by identifier
     */
    getNftItemById(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemByIdRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns metadata of specified NFT item
     */
    getNftItemMetaByIdRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling getNftItemMetaById.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}/meta`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 404) {
                return {
                    status: 404,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns metadata of specified NFT item
     */
    getNftItemMetaById(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemMetaByIdRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns item royalty by identifier
     */
    getNftItemRoyaltyByIdRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling getNftItemRoyaltyById.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}/royalty`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns item royalty by identifier
     */
    getNftItemRoyaltyById(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemRoyaltyByIdRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT items by collection
     */
    getNftItemsByCollectionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.collection === null || requestParameters.collection === undefined) {
                throw new runtime.RequiredError('collection', 'Required parameter requestParameters.collection was null or undefined when calling getNftItemsByCollection.');
            }
            const queryParameters = {};
            if (requestParameters.collection !== undefined) {
                queryParameters['collection'] = requestParameters.collection;
            }
            if (requestParameters.owner !== undefined) {
                queryParameters['owner'] = requestParameters.owner;
            }
            if (requestParameters.continuation !== undefined) {
                queryParameters['continuation'] = requestParameters.continuation;
            }
            if (requestParameters.size !== undefined) {
                queryParameters['size'] = requestParameters.size;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/byCollection`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT items by collection
     */
    getNftItemsByCollection(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemsByCollectionRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by creator
     */
    getNftItemsByCreatorRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.creator === null || requestParameters.creator === undefined) {
                throw new runtime.RequiredError('creator', 'Required parameter requestParameters.creator was null or undefined when calling getNftItemsByCreator.');
            }
            const queryParameters = {};
            if (requestParameters.creator !== undefined) {
                queryParameters['creator'] = requestParameters.creator;
            }
            if (requestParameters.continuation !== undefined) {
                queryParameters['continuation'] = requestParameters.continuation;
            }
            if (requestParameters.size !== undefined) {
                queryParameters['size'] = requestParameters.size;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/byCreator`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by creator
     */
    getNftItemsByCreator(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemsByCreatorRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by identifier
     */
    getNftItemsByIdsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.nftItemIds === null || requestParameters.nftItemIds === undefined) {
                throw new runtime.RequiredError('nftItemIds', 'Required parameter requestParameters.nftItemIds was null or undefined when calling getNftItemsByIds.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/byIds`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.nftItemIds,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by identifier
     */
    getNftItemsByIds(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemsByIdsRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by owner
     */
    getNftItemsByOwnerRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.owner === null || requestParameters.owner === undefined) {
                throw new runtime.RequiredError('owner', 'Required parameter requestParameters.owner was null or undefined when calling getNftItemsByOwner.');
            }
            const queryParameters = {};
            if (requestParameters.owner !== undefined) {
                queryParameters['owner'] = requestParameters.owner;
            }
            if (requestParameters.continuation !== undefined) {
                queryParameters['continuation'] = requestParameters.continuation;
            }
            if (requestParameters.size !== undefined) {
                queryParameters['size'] = requestParameters.size;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/byOwner`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT item by owner
     */
    getNftItemsByOwner(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftItemsByOwnerRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Returns the NFT lazy item by identifier
     */
    getNftLazyItemByIdRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling getNftLazyItemById.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}/lazy`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                    value: yield response.json()
                };
            }
            if (response.status === 404) {
                return {
                    status: 404,
                    value: yield response.json()
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Returns the NFT lazy item by identifier
     */
    getNftLazyItemById(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNftLazyItemByIdRaw(requestParameters);
            if (response.status === 200) {
                return response.value;
            }
            throw response;
        });
    }
    /**
     * Deletes the NFT item meta by identifier. In future indexer won\'t store metadata, so this endpoint will be removed.
     */
    resetNftItemMetaByIdRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
                throw new runtime.RequiredError('itemId', 'Required parameter requestParameters.itemId was null or undefined when calling resetNftItemMetaById.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["X-API-KEY"] = this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
            }
            const response = yield this.request({
                path: `/v0.1/nft/items/{itemId}/resetMeta`.replace(`{${"itemId"}}`, encodeURIComponent(String(requestParameters.itemId))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            });
            if (response.status === 200) {
                return {
                    status: 200,
                };
            }
            if (response.status === 400) {
                return {
                    status: 400,
                    value: yield response.json()
                };
            }
            if (response.status === 500) {
                return {
                    status: 500,
                    value: yield response.json()
                };
            }
            throw response;
        });
    }
    /**
     * Deletes the NFT item meta by identifier. In future indexer won\'t store metadata, so this endpoint will be removed.
     */
    resetNftItemMetaById(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetNftItemMetaByIdRaw(requestParameters);
        });
    }
}
exports.NftItemControllerApi = NftItemControllerApi;
