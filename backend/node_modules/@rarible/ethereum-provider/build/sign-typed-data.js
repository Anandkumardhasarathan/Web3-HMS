"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignTypedDataError = exports.hasMessage = exports.isObject = exports.filterErrors = exports.signTypedData = void 0;
const tslib_1 = require("tslib");
const eth_sig_util_1 = require("eth-sig-util");
const domain_1 = require("./domain");
function signTypedData(send, signer, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const errorsStack = [];
        try {
            const signature = yield send(domain_1.SignTypedDataMethodEnum.V4, [signer, JSON.stringify(data)]);
            filterErrors(signature);
            return signature;
        }
        catch (error) {
            filterErrors(error);
            errorsStack.push(error);
            try {
                console.error("got error while executing sign typed data v4", error);
                if (isError(error) && error.message === "MetaMask Message Signature: Error: Not supported on this device") {
                    return yield signWithHardwareWallets(send, signer, data);
                }
                else {
                    try {
                        return yield send(domain_1.SignTypedDataMethodEnum.V3, [signer, JSON.stringify(data)]);
                    }
                    catch (error) {
                        console.error("got error while executing sign typed data v3", error);
                        filterErrors(error);
                        errorsStack.push(error);
                        return yield send(domain_1.SignTypedDataMethodEnum.DEFAULT, [signer, data]);
                    }
                }
            }
            catch (e) {
                errorsStack.push(e);
                throw new SignTypedDataError({
                    error,
                    data: {
                        signer,
                        data,
                        errorsStack,
                    },
                });
            }
        }
    });
}
exports.signTypedData = signTypedData;
function isError(x) {
    return typeof x === "object" && x !== null && "message" in x;
}
function signWithHardwareWallets(send, signer, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hash = eth_sig_util_1.TypedDataUtils.sign(data);
        const signature = toBuffer(yield send("eth_sign", [signer, `0x${hash.toString("hex")}`]));
        signature.writeInt8(signature[64] + 4, 64);
        return `0x${signature.toString("hex")}`;
    });
}
/*
    4900 - wallet is disconnected
    4001 - user cancelled request
    4901 - chain is not connected
    4100 - not authorized in wallet
*/
function filterErrors(original) {
    var _a;
    if (hasCode(original)) {
        if ([4900, 4001, 4901, 4100].includes(original.code)) {
            throw original;
        }
        if (hasMessage(original) && ((_a = original.message) === null || _a === void 0 ? void 0 : _a.includes("User denied message signature."))) {
            throw original;
        }
    }
    if (hasMessage(original)) {
        const jsonMsg = getJSONFromMessage(original.message);
        if (jsonMsg) {
            filterErrors(jsonMsg);
        }
    }
}
exports.filterErrors = filterErrors;
function getJSONFromMessage(message) {
    if (!message || typeof message !== "string") {
        return;
    }
    try {
        return JSON.parse(message);
    }
    catch (e) {
        return;
    }
}
function isObject(x) {
    return typeof x === "object" && x !== null;
}
exports.isObject = isObject;
function hasCode(error) {
    return isObject(error) && "code" in error;
}
function hasMessage(error) {
    return isObject(error) && "message" in error;
}
exports.hasMessage = hasMessage;
function toBuffer(hex) {
    if (hex.startsWith("0x")) {
        return Buffer.from(hex.substring(2), "hex");
    }
    else {
        return Buffer.from(hex, "hex");
    }
}
class SignTypedDataError extends Error {
    constructor(data) {
        var _a, _b, _c;
        super(SignTypedDataError.getErrorMessage(data));
        Object.setPrototypeOf(this, SignTypedDataError.prototype);
        this.name = "SignTypedDataError";
        this.error = data === null || data === void 0 ? void 0 : data.error;
        this.data = data === null || data === void 0 ? void 0 : data.data;
        this.code = ((_a = data === null || data === void 0 ? void 0 : data.error) === null || _a === void 0 ? void 0 : _a.code) || ((_c = (_b = data === null || data === void 0 ? void 0 : data.error) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) || undefined;
    }
    static getErrorMessage(data) {
        var _a;
        if (typeof data.error === "string")
            return data.error;
        return ((_a = data === null || data === void 0 ? void 0 : data.error) === null || _a === void 0 ? void 0 : _a.message) || (data === null || data === void 0 ? void 0 : data.message) || "SignTypedDataError";
    }
}
exports.SignTypedDataError = SignTypedDataError;
