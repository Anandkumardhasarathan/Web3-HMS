import type { Contract } from "ethers";
import { ethers } from "ethers";
import type { TransactionResponse } from "@ethersproject/abstract-provider";
import type * as EthereumProvider from "@rarible/ethereum-provider";
import type { EthereumTransactionEvent, MessageTypes, TypedMessage, EthereumSendTransactionOptions } from "@rarible/ethereum-provider";
import type { Address, BigNumber, Binary, Word } from "@rarible/types";
import type { TypedDataSigner } from "@ethersproject/abstract-signer";
export declare class EthersWeb3ProviderEthereum implements EthereumProvider.Ethereum {
    readonly web3Provider: ethers.providers.Web3Provider;
    readonly from?: string | undefined;
    constructor(web3Provider: ethers.providers.Web3Provider, from?: string | undefined);
    createContract(abi: any, address?: string): EthereumProvider.EthereumContract;
    send(method: string, params: any): Promise<any>;
    sendTransaction(options: EthereumSendTransactionOptions): Promise<any>;
    personalSign(message: string): Promise<string>;
    signTypedData<T extends MessageTypes>(data: TypedMessage<T>): Promise<string>;
    getFrom(): Promise<string>;
    encodeParameter(type: any, parameter: any): string;
    decodeParameter(type: any, data: string): any;
    getBalance(address: Address): Promise<BigNumber>;
    getChainId(): Promise<number>;
    getCurrentProvider(): any;
}
export declare class EthersEthereum implements EthereumProvider.Ethereum {
    readonly signer: TypedDataSigner & ethers.Signer;
    constructor(signer: TypedDataSigner & ethers.Signer);
    getCurrentProvider(): any;
    createContract(abi: any, address?: string): EthereumProvider.EthereumContract;
    personalSign(message: string): Promise<string>;
    sendTransaction(options: EthereumSendTransactionOptions): Promise<EthersTransaction>;
    signTypedData<T extends MessageTypes>(data: TypedMessage<T>): Promise<string>;
    getFrom(): Promise<string>;
    encodeParameter(type: any, parameter: any): string;
    decodeParameter(type: any, data: string): any;
    getBalance(address: Address): Promise<BigNumber>;
    getChainId(): Promise<number>;
}
export declare class EthersContract implements EthereumProvider.EthereumContract {
    private readonly contract;
    private readonly signer;
    constructor(contract: Contract, signer: TypedDataSigner & ethers.Signer);
    functionCall(name: string, ...args: any): EthereumProvider.EthereumFunctionCall;
}
export declare class EthersFunctionCall implements EthereumProvider.EthereumFunctionCall {
    private readonly signer;
    private readonly contract;
    private readonly name;
    private readonly args;
    private fnSignature;
    constructor(signer: TypedDataSigner & ethers.Signer, contract: Contract, name: string, args: any[]);
    getCallInfo(): Promise<EthereumProvider.EthereumFunctionCallInfo>;
    getData(): Promise<string>;
    estimateGas(options?: EthereumProvider.EthereumSendOptions): Promise<number>;
    call(options?: EthereumProvider.EthereumSendOptions): Promise<any>;
    send(options?: EthereumProvider.EthereumSendOptions): Promise<EthereumProvider.EthereumTransaction>;
}
export declare class EthersTransaction implements EthereumProvider.EthereumTransaction {
    private readonly tx;
    private readonly contract?;
    constructor(tx: TransactionResponse, contract?: Contract | undefined);
    get hash(): Word;
    wait(): Promise<EthereumProvider.EthereumTransactionReceipt>;
    getEvents(): Promise<EthereumTransactionEvent[]>;
    get to(): Address | undefined;
    get from(): Address;
    get data(): Binary;
    get nonce(): number;
}
