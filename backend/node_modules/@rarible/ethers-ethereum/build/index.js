"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthersTransaction = exports.EthersFunctionCall = exports.EthersContract = exports.EthersEthereum = exports.EthersWeb3ProviderEthereum = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const ethereum_provider_1 = require("@rarible/ethereum-provider");
const types_1 = require("@rarible/types");
const ethers_2 = require("ethers/lib/ethers");
const sdk_common_1 = require("@rarible/sdk-common");
const abi_coder_1 = require("./abi-coder");
const parse_logs_1 = require("./utils/parse-logs");
class EthersWeb3ProviderEthereum {
    constructor(web3Provider, from) {
        this.web3Provider = web3Provider;
        this.from = from;
        this.send = this.send.bind(this);
    }
    createContract(abi, address) {
        if (!address) {
            throw new Error("No Contract address provided, it's required for EthersEthereum");
        }
        return new EthersContract(new ethers_1.ethers.Contract(address, abi, this.web3Provider.getSigner()), this.web3Provider.getSigner());
    }
    send(method, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.web3Provider.send(method, params);
            }
            catch (e) {
                let signer;
                try {
                    signer = yield this.getFrom();
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.send",
                    error: e,
                    data: {
                        method,
                        params,
                        from: signer,
                    },
                });
            }
        });
    }
    sendTransaction(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let enrichedData = options.data || "0x";
                if (options.additionalData) {
                    const additionalData = (0, types_1.toBinary)(options.additionalData).slice(2);
                    enrichedData = `0x${enrichedData}${additionalData}`;
                }
                const signer = this.web3Provider.getSigner();
                const txConfig = {
                    to: options.to,
                    data: enrichedData,
                    value: options.value !== undefined ? ethers_1.ethers.utils.hexValue(ethers_2.BigNumber.from(options.value)) : undefined,
                };
                if (options.gas !== undefined) {
                    txConfig.gasLimit = options.gas;
                }
                if (options.gasPrice !== undefined) {
                    txConfig.gasPrice = options.gasPrice;
                }
                const tx = yield signer.sendTransaction(txConfig);
                return new EthersTransaction(tx);
            }
            catch (e) {
                let signer;
                try {
                    signer = yield this.getFrom();
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.sendTransaction",
                    error: e,
                    data: {
                        options,
                        from: signer,
                    },
                });
            }
        });
    }
    personalSign(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.web3Provider.getSigner().signMessage(message);
            }
            catch (e) {
                let signer;
                try {
                    signer = yield this.getFrom();
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.personalSign",
                    error: e,
                    data: {
                        message,
                        from: signer,
                    },
                });
            }
        });
    }
    signTypedData(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let signer;
            try {
                signer = yield this.getFrom();
                return yield (0, ethereum_provider_1.signTypedData)(this.send, signer, data);
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.signTypedData",
                    error: e,
                    data,
                    signer,
                });
            }
        });
    }
    getFrom() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.from) {
                    const [first] = yield this.web3Provider.listAccounts();
                    return first;
                }
                return this.from;
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.getFrom",
                    error: e,
                    data: null,
                });
            }
        });
    }
    encodeParameter(type, parameter) {
        try {
            return (0, abi_coder_1.encodeParameters)([type], [parameter]);
        }
        catch (e) {
            throw new ethereum_provider_1.EthereumProviderError({
                providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                provider: ethereum_provider_1.Provider.ETHERS,
                method: "EthersWeb3ProviderEthereum.encodeParameter",
                error: e,
                data: { type, parameter },
            });
        }
    }
    decodeParameter(type, data) {
        try {
            return (0, abi_coder_1.decodeParameters)([type], data);
        }
        catch (e) {
            throw new ethereum_provider_1.EthereumProviderError({
                providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                provider: ethereum_provider_1.Provider.ETHERS,
                method: "EthersWeb3ProviderEthereum.decodeParameter",
                error: e,
                data: { type, data },
            });
        }
    }
    getBalance(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const balance = yield this.web3Provider.getBalance(address);
                return (0, types_1.toBigNumber)(balance.toString());
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.getBalance",
                    error: e,
                    data: { address },
                });
            }
        });
    }
    getChainId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { chainId } = yield this.web3Provider.getNetwork();
                return +chainId;
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersWeb3ProviderEthereum.getChainId",
                    error: e,
                    data: null,
                });
            }
        });
    }
    getCurrentProvider() {
        return this.web3Provider.provider;
    }
}
exports.EthersWeb3ProviderEthereum = EthersWeb3ProviderEthereum;
class EthersEthereum {
    constructor(signer) {
        this.signer = signer;
    }
    getCurrentProvider() {
        return getCurrentProviderFromSigner(this.signer);
    }
    createContract(abi, address) {
        if (!address) {
            throw new Error("No Contract address provided, it's required for EthersEthereum");
        }
        return new EthersContract(new ethers_1.ethers.Contract(address, abi, this.signer), this.signer);
    }
    personalSign(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.signer.signMessage(message);
            }
            catch (e) {
                let signer;
                try {
                    signer = yield this.getFrom();
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersEthereum.personalSign",
                    error: e,
                    data: {
                        message,
                        from: signer,
                    },
                });
            }
        });
    }
    sendTransaction(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let enrichedData = options.data || "0x";
            if (options.additionalData) {
                const additionalData = (0, types_1.toBinary)(options.additionalData).slice(2);
                enrichedData = `0x${enrichedData}${additionalData}`;
            }
            const txConfig = {
                from: yield this.signer.getAddress(),
                to: options.to,
                data: enrichedData,
                value: options.value !== undefined ? ethers_1.ethers.utils.hexValue(ethers_2.BigNumber.from(options.value)) : undefined,
            };
            if (options.gas !== undefined) {
                txConfig.gasLimit = options.gas;
            }
            if (options.gasPrice !== undefined) {
                txConfig.gasPrice = options.gasPrice;
            }
            const tx = yield this.signer.sendTransaction(txConfig);
            return new EthersTransaction(tx);
        });
    }
    signTypedData(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const _a = data.types, { EIP712Domain } = _a, types = tslib_1.__rest(_a, ["EIP712Domain"]);
                return yield this.signer._signTypedData(data.domain, types, data.message);
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersEthereum.signTypedData",
                    error: e,
                    data,
                });
            }
        });
    }
    getFrom() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.signer.getAddress();
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersEthereum.getFrom",
                    error: e,
                    data: null,
                });
            }
        });
    }
    encodeParameter(type, parameter) {
        try {
            return (0, abi_coder_1.encodeParameters)([type], [parameter]);
        }
        catch (e) {
            throw new ethereum_provider_1.EthereumProviderError({
                providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                provider: ethereum_provider_1.Provider.ETHERS,
                method: "EthersEthereum.encodeParameter",
                error: e,
                data: { type, parameter },
            });
        }
    }
    decodeParameter(type, data) {
        try {
            return (0, abi_coder_1.decodeParameters)([type], data);
        }
        catch (e) {
            throw new ethereum_provider_1.EthereumProviderError({
                providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                provider: ethereum_provider_1.Provider.ETHERS,
                method: "EthersEthereum.decodeParameter",
                error: e,
                data: { type, data },
            });
        }
    }
    getBalance(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signer.provider) {
                throw new Error("EthersEthereum: signer provider does not exist");
            }
            try {
                const balance = yield this.signer.provider.getBalance(address);
                return (0, types_1.toBigNumber)(balance.toString());
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersEthereum.getBalance",
                    error: e,
                    data: { address },
                });
            }
        });
    }
    getChainId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return +(yield this.signer.getChainId());
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    providerId: (0, sdk_common_1.getDappType)(this.getCurrentProvider()),
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersEthereum.getChainId",
                    error: e,
                    data: null,
                });
            }
        });
    }
}
exports.EthersEthereum = EthersEthereum;
class EthersContract {
    constructor(contract, signer) {
        this.contract = contract;
        this.signer = signer;
    }
    functionCall(name, ...args) {
        return new EthersFunctionCall(this.signer, this.contract, name, args);
    }
}
exports.EthersContract = EthersContract;
const captureBracketsTextRegexp = /\(([^)]+)\)/;
class EthersFunctionCall {
    constructor(signer, contract, name, args) {
        this.signer = signer;
        this.contract = contract;
        this.name = name;
        this.args = args;
        if (this.contract.estimateGas[this.name]) {
            this.fnSignature = this.name;
        }
        else {
            const fnSignature = Object.keys(this.contract.estimateGas).find(signature => {
                if (!signature.includes(this.name)) {
                    return false;
                }
                const argsText = signature.match(captureBracketsTextRegexp);
                if (!argsText) {
                    return !this.args.length;
                }
                const args = argsText[1].split(",");
                return args.length === this.args.length;
            });
            if (!fnSignature) {
                throw new Error("Function signature is not found");
            }
            this.fnSignature = fnSignature;
        }
    }
    getCallInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let from;
            try {
                from = yield this.signer.getAddress();
            }
            catch (e) {
                from = "";
            }
            return {
                from,
                method: this.name,
                args: this.args,
                contract: this.contract.address,
                provider: ethereum_provider_1.Provider.ETHERS,
            };
        });
    }
    getData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return (yield this.contract.populateTransaction[this.fnSignature](...this.args)).data || "0x";
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    providerId: getCurrentProviderFromSigner(this.signer),
                    method: "EthersFunctionCall.getData",
                    error: e,
                    data: yield this.getCallInfo(),
                });
            }
        });
    }
    estimateGas(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const fn = this.contract.estimateGas[this.fnSignature].bind(null, ...this.args);
                const value = yield fn(options);
                return value.toNumber();
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    providerId: getCurrentProviderFromSigner(this.signer),
                    method: "EthersFunctionCall.estimateGas",
                    error: e,
                    data: Object.assign(Object.assign({}, (yield this.getCallInfo())), { options }),
                });
            }
        });
    }
    call(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const func = this.contract[this.fnSignature].bind(null, ...this.args);
                if (options) {
                    return yield func(options);
                }
                else {
                    return yield func();
                }
            }
            catch (e) {
                let callInfo = null, callData = null;
                try {
                    ;
                    [callInfo, callData] = yield (0, sdk_common_1.promiseSettledRequest)([this.getCallInfo(), this.getData()]);
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    providerId: getCurrentProviderFromSigner(this.signer),
                    method: "EthersFunctionCall.call",
                    error: e,
                    data: Object.assign(Object.assign({}, (callInfo || {})), { data: callData, options }),
                });
            }
        });
    }
    send(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let hashValue;
            try {
                if (options === null || options === void 0 ? void 0 : options.additionalData) {
                    const additionalData = (0, types_1.toBinary)(options.additionalData).slice(2);
                    const sourceData = (0, types_1.toBinary)(yield this.getData()).slice(2);
                    const txConfig = {
                        from: yield this.signer.getAddress(),
                        to: this.contract.address,
                        data: `0x${sourceData}${additionalData}`,
                        value: options.value !== undefined ? ethers_1.ethers.utils.hexValue(ethers_2.BigNumber.from(options.value)) : undefined,
                    };
                    if (options.gas !== undefined) {
                        txConfig.gasLimit = options.gas;
                    }
                    if (options.gasPrice !== undefined) {
                        txConfig.gasPrice = options.gasPrice;
                    }
                    const tx = yield this.signer.sendTransaction(txConfig);
                    return new EthersTransaction(tx, this.contract);
                }
                const func = this.contract[this.fnSignature].bind(null, ...this.args);
                const tx = yield func(options || {});
                hashValue = tx.hash;
                return new EthersTransaction(tx, this.contract);
            }
            catch (e) {
                let callInfo = null, callData = null;
                try {
                    ;
                    [callInfo, callData] = yield (0, sdk_common_1.promiseSettledRequest)([this.getCallInfo(), this.getData()]);
                }
                catch (e) { }
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    providerId: getCurrentProviderFromSigner(this.signer),
                    method: "EthersFunctionCall.send",
                    error: e,
                    data: Object.assign(Object.assign({}, (callInfo || {})), { data: callData, hash: hashValue, options }),
                });
            }
        });
    }
}
exports.EthersFunctionCall = EthersFunctionCall;
class EthersTransaction {
    constructor(tx, contract) {
        this.tx = tx;
        this.contract = contract;
    }
    get hash() {
        return (0, types_1.toWord)(this.tx.hash);
    }
    wait() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const receipt = yield this.tx.wait();
                const status = receipt.status === 1;
                return Object.assign(Object.assign({}, receipt), { status });
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersTransaction.wait",
                    error: e,
                    data: {
                        hash: this.hash,
                        data: this.data,
                        nonce: this.nonce,
                        from: this.from,
                        to: this.to,
                    },
                });
            }
        });
    }
    getEvents() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const receipt = yield this.tx.wait();
                if (this.contract) {
                    return (0, parse_logs_1.getTxEvents)(receipt, this.contract);
                }
                return (receipt === null || receipt === void 0 ? void 0 : receipt.events) || [];
            }
            catch (e) {
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.ETHERS,
                    method: "EthersTransaction.getEvents",
                    error: e,
                    data: {
                        hash: this.hash,
                        data: this.data,
                        nonce: this.nonce,
                        from: this.from,
                        to: this.to,
                    },
                });
            }
        });
    }
    get to() {
        return this.tx.to ? (0, types_1.toAddress)(this.tx.to) : undefined;
    }
    get from() {
        return (0, types_1.toAddress)(this.tx.from);
    }
    get data() {
        return (0, types_1.toBinary)(this.tx.data);
    }
    get nonce() {
        return this.tx.nonce;
    }
}
exports.EthersTransaction = EthersTransaction;
function getCurrentProviderFromSigner(signer) {
    if (signer.provider && "provider" in signer.provider) {
        return signer.provider.provider;
    }
    return null;
}
