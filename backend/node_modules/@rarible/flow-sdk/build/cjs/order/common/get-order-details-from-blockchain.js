"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorefrontV2OrderDetailsFromBlockchain = exports.getOrderDetailsFromBlockchain = void 0;
var tslib_1 = require("tslib");
var t = tslib_1.__importStar(require("@onflow/types"));
var types_1 = require("@rarible/types");
var transaction_1 = require("../../common/transaction");
var config_1 = require("../../config/config");
var prefix_1 = require("../../common/prefix");
var storefront_common_1 = require("../../scripts/storefront/storefront-common");
var nft_1 = require("../../scripts/nft");
var bid_common_1 = require("../../scripts/bid/bid-common");
function getOrderDetailsFromBlockchain(fcl, network, orderType, address, orderId) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var cadence, map, args, details, fungibleContract, protocolFeeReceiver, data;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    switch (orderType) {
                        case "sell":
                            cadence = storefront_common_1.StorefrontCommon.read_listing_details;
                            map = {
                                NFTStorefront: config_1.CONFIGS[network].mainAddressMap.NFTStorefront,
                            };
                            break;
                        case "sellV2":
                            cadence = nft_1.scriptOrderDetails;
                            map = {
                                NFTStorefrontV2: config_1.CONFIGS[network].mainAddressMap.NFTStorefrontV2,
                            };
                            break;
                        case "bid":
                            cadence = bid_common_1.openBidCommon.readBidDetails;
                            map = {
                                RaribleOpenBid: config_1.CONFIGS[network].mainAddressMap.RaribleOpenBid,
                            };
                            break;
                        default:
                            throw new Error("Unsupported order type");
                    }
                    args = fcl.args([fcl.arg(address, t.Address), fcl.arg(orderId, t.UInt64)]);
                    return [4 /*yield*/, (0, transaction_1.runScript)(fcl, {
                            cadence: cadence,
                            args: args,
                        }, map)];
                case 1:
                    details = _a.sent();
                    if ("vaultType" in details) {
                        fungibleContract = details.vaultType.typeID.split(".")[2];
                    }
                    else if ("salePaymentVaultType" in details) {
                        fungibleContract = details.salePaymentVaultType.typeID.split(".")[2];
                    }
                    else {
                        throw new Error("Unknown order object type returned from blockchain");
                    }
                    protocolFeeReceiver = config_1.CONFIGS[network].protocolFee.account;
                    data = tslib_1.__assign(tslib_1.__assign({}, details), { saleCuts: ("saleCuts" in details ? details.saleCuts : details.cuts).map(function (s) { return ({
                            account: (0, types_1.toFlowAddress)(s.receiver.address),
                            value: (0, types_1.toBigNumberLike)(s.amount),
                        }); }) });
                    data.isLegacy = data.saleCuts.filter(function (s) { return (0, prefix_1.withPrefix)(s.account).toLowerCase() === (0, prefix_1.withPrefix)(protocolFeeReceiver).toLowerCase(); }).length > 1;
                    switch (fungibleContract) {
                        case "FlowToken":
                            return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, data), { currency: "FLOW" })];
                        case "FUSD":
                            return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, data), { currency: "FUSD" })];
                        default:
                            throw new Error("Unsupported fungible token");
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.getOrderDetailsFromBlockchain = getOrderDetailsFromBlockchain;
function getStorefrontV2OrderDetailsFromBlockchain(fcl, network, address, orderId) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, (0, transaction_1.runScript)(fcl, {
                    cadence: nft_1.scriptOrderDetails,
                    args: fcl.args([fcl.arg(address, t.Address), fcl.arg(orderId, t.UInt64)]),
                }, { NFTStorefrontV2: config_1.CONFIGS[network].mainAddressMap.NFTStorefrontV2 })];
        });
    });
}
exports.getStorefrontV2OrderDetailsFromBlockchain = getStorefrontV2OrderDetailsFromBlockchain;
