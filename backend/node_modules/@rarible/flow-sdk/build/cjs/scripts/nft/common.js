"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonNft = void 0;
exports.commonNft = {
    transfer: "\nimport NonFungibleToken from address\nimport %nftContract% from address\n\n// transfer %nftContract% token with tokenId to given address\n//\ntransaction(tokenId: UInt64, to: Address) {\n    let token: @NonFungibleToken.NFT\n    let receiver: Capability<&{%nftPublicTypeMin%}>\n\n    prepare(account: AuthAccount) {\n        let collection = account.borrow<&%nftStorageType%>(from: %nftStoragePath%)\n            ?? panic(\"could not borrow %nftContract% collection from account\")\n        self.token <- collection.withdraw(withdrawID: tokenId)\n        self.receiver = getAccount(to).getCapability<&{%nftPublicTypeMin%}>(%nftPublicPath%)\n    }\n\n    execute {\n        let receiver = self.receiver.borrow()\n            ?? panic(\"recipient %nftContract% collection not initialized\")\n        receiver.deposit(token: <- self.token)\n    }\n}\n\n\t",
    burn: "\nimport NonFungibleToken from address\nimport %nftContract% from address\n\n// Burn %nftContract% on signer account by tokenId\n//\ntransaction(tokenId: UInt64) {\n    prepare(account: auth(BorrowValue) &Account) {\n        let card: @%nftContract%.NFT <-account.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: %nftContract%.CollectionStoragePath)!.withdraw(withdrawID: tokenId) as! @%nftContract%.NFT\n\n        destroy card\n    }\n}\n\n",
    setupAccount: "\nimport NonFungibleToken from address\nimport %nftContract% from address\n\n// Setup storage for %nftContract% on signer account\n//\ntransaction {\n    prepare(account: AuthAccount) {\n        if !account.getCapability<&{%nftPublicType%}>(%nftPublicPath%).check() {\n            if account.borrow<&AnyResource>(from: %nftStoragePath%) != nil {\n                account.unlink(%nftPublicPath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            } else {\n                let collection <- %nftContract%.createEmptyCollection() as! @%nftStorageType%\n                account.save(<-collection, to: %nftStoragePath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            }\n        }\n    }\n}\n\n\t",
    check: "\nimport NonFungibleToken from address\nimport %nftContract% from address\n\n// check %nftContract% collection is available on given address\naccess(all)\nfun main(address: Address): Bool {\n    return getAccount(address)\n        .capabilities.get<&{%nftPublicTypeMin%}>(%nftPublicPath%)\n        .check()\n}\n\t",
};
