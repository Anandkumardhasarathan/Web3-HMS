"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.txInitGamisodesContractsAndStorefrontV2 = exports.gamisodesRawInitPart = void 0;
var init_vault_1 = require("../init-vault");
exports.gamisodesRawInitPart = "\n        //Gamisodes INIT PART START\n        if acct.borrow<&Gamisodes.Collection>(from: Gamisodes.COLLECTION_STORAGE_PATH) == nil {\n          let collection <- Gamisodes.createEmptyCollection()\n          acct.save(<-collection, to: Gamisodes.COLLECTION_STORAGE_PATH)\n        }\n        if (acct.getCapability<&Gamisodes.Collection{NiftoryNonFungibleToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(Gamisodes.COLLECTION_PUBLIC_PATH).borrow() == nil) {\n          acct.unlink(Gamisodes.COLLECTION_PUBLIC_PATH)\n          acct.link<&Gamisodes.Collection{NiftoryNonFungibleToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(Gamisodes.COLLECTION_PUBLIC_PATH, target: Gamisodes.COLLECTION_STORAGE_PATH)\n        }\n\n        if (acct.getCapability<&Gamisodes.Collection{NiftoryNonFungibleToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(Gamisodes.COLLECTION_PRIVATE_PATH).borrow() == nil) {\n          acct.unlink(Gamisodes.COLLECTION_PRIVATE_PATH)\n          acct.link<&Gamisodes.Collection{NiftoryNonFungibleToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(Gamisodes.COLLECTION_PRIVATE_PATH, target: Gamisodes.COLLECTION_STORAGE_PATH)\n        }\n\n        if acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n        // Create a new empty Storefront\n        let storefront: @NFTStorefrontV2.Storefront <- NFTStorefrontV2.createStorefront()\n\n        // save it to the account\n        acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n        // create a public capability for the Storefront\n        let storefrontPublicCap: Capability<&{NFTStorefrontV2.StorefrontPublic}> = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(\n            NFTStorefrontV2.StorefrontStoragePath\n          )\n        acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)\n          }\n        //Gamisodes INIT PART END\n";
exports.txInitGamisodesContractsAndStorefrontV2 = "\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport FUSD from 0xFUSD\nimport FiatToken from 0xFiatToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n//Gamisodes\nimport TokenForwarding from 0xTokenForwarding\nimport Gamisodes from 0xGamisodes\nimport NiftoryNFTRegistry from 0xNiftoryNFTRegistry\nimport NiftoryNonFungibleToken from 0xNiftoryNonFungibleToken\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n".concat((0, init_vault_1.getVaultInitTx)(init_vault_1.vaultOptions["FiatToken"]), "\n").concat(exports.gamisodesRawInitPart, "\n\n      if acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n      // Create a new empty Storefront\n      let storefront: @NFTStorefrontV2.Storefront <- NFTStorefrontV2.createStorefront()\n\n      // save it to the account\n      acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n      // create a public capability for the Storefront\n      let storefrontPublicCap: Capability<&{NFTStorefrontV2.StorefrontPublic}> = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(\n          NFTStorefrontV2.StorefrontStoragePath\n        )\n      acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)\n        }\n    }\n    execute {\n    }\n}");
