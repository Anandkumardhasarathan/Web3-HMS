"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gamisodesListTxCode = void 0;
var contracts_1 = require("../contracts");
var init_vault_1 = require("../init-vault");
var init_1 = require("./init");
var gamisodesListTxCode = function (currency) {
    return "\nimport %ftContract% from 0x%ftContract%\nimport FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\nimport TokenForwarding from 0xTokenForwarding\nimport Gamisodes from 0xGamisodes\nimport NiftoryNFTRegistry from 0xNiftoryNFTRegistry\nimport NiftoryNonFungibleToken from 0xNiftoryNonFungibleToken\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    let fiatReceiver: Capability<&AnyResource{".concat(contracts_1.FungibleToken.name, ".Receiver}>\n    let %nftContract%Provider: Capability<&AnyResource{").concat(contracts_1.NonFungibleToken.name, ".Provider, ").concat(contracts_1.NonFungibleToken.name, ".CollectionPublic}>\n    let storefront: &").concat(contracts_1.NFTStorefrontV2.name, ".Storefront\n    var saleCuts: [").concat(contracts_1.NFTStorefrontV2.name, ".SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{").concat(contracts_1.FungibleToken.name, ".Receiver}>]\n\n    prepare(acct: AuthAccount) {\n").concat(currency === "USDC" ? (0, init_vault_1.getVaultInitTx)(init_vault_1.vaultOptions["FiatToken"]) : "", "\n").concat(init_1.gamisodesRawInitPart, "\n\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let %nftContract%ProviderPrivatePath = %nftPrivatePath%\n\n        // Receiver for the sale cut.\n        self.fiatReceiver = acct.getCapability<&{").concat(contracts_1.FungibleToken.name, ".Receiver}>(%ftPublicPath%)\n        assert(self.fiatReceiver.borrow() != nil, message: \"Missing or mis-typed FT receiver\")\n\n        // Check if the Provider capability exists or not if then create a new link for the same.\n        // if !acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, NiftoryNonFungibleToken.CollectionPublic}>(%nftContract%ProviderPrivatePath).check() {\n        //     acct.link<&{NonFungibleToken.Provider, NiftoryNonFungibleToken.CollectionPrivate}>(%nftContract%ProviderPrivatePath, target: %nftStoragePath%)\n        // }\n\n\n        self.%nftContract%Provider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(%nftContract%ProviderPrivatePath)\n        let collection = acct\n            .getCapability(%nftPublicPath%)\n            .borrow<&{%nftPublicTypeMin%}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n        let nft = collection.borrowNFT(id: saleItemID)!\n        // Check whether the NFT implements the MetadataResolver or not.\n        if nft.getViews().contains(Type<").concat(contracts_1.MetadataViews.name, ".Royalties>()) {\n            let royaltiesRef = nft.resolveView(Type<").concat(contracts_1.MetadataViews.name, ".Royalties>())?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! ").concat(contracts_1.MetadataViews.name, ".Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(").concat(contracts_1.NFTStorefrontV2.name, ".SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n        // Append the cut for the seller.\n        self.saleCuts.append(").concat(contracts_1.NFTStorefrontV2.name, ".SaleCut(\n            receiver: self.fiatReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.%nftContract%Provider.borrow() != nil, message: \"Missing or mis-typed %nftContract%.Collection provider\")\n\n        self.storefront = acct.borrow<&").concat(contracts_1.NFTStorefrontV2.name, ".Storefront>(from: ").concat(contracts_1.NFTStorefrontV2.name, ".StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            // Here we are making a fair assumption that all given addresses would have\n            // the capability to receive the\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{").concat(contracts_1.FungibleToken.name, ".Receiver}>(%ftPublicPath%))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.%nftContract%Provider,\n            nftType: Type<@%nftContract%.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@%ftContract%.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n");
};
exports.gamisodesListTxCode = gamisodesListTxCode;
