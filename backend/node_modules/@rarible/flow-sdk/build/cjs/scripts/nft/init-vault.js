"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.txInitVault = exports.vaultOptions = exports.defaultVaultOptions = exports.getUSDCVaultInitTx = exports.getVaultInitTx = void 0;
var getVaultInitTx = function (o) {
    if (o === void 0) { o = exports.defaultVaultOptions; }
    return "\n      // Return early if the account already stores a ContractName Vault\n      if acct.borrow<&".concat(o.contractName, ".Vault>(from: ").concat(o.storagePath, ") == nil {\n          // Create a new ContractName Vault and put it in storage\n          acct.save(\n              <-").concat(o.contractName, ".createEmptyVault(),\n              to: ").concat(o.storagePath, "\n          )\n\n          // Create a public capability to the Vault that only exposes\n          // the deposit function through the Receiver interface\n          acct.link<&").concat(o.contractName, ".Vault{FungibleToken.Receiver}>(\n              ").concat(o.publicPath, ",\n              target: ").concat(o.storagePath, "\n          )\n\n          // Create a public capability to the Vault that only exposes\n          // the balance field through the Balance interface\n          acct.link<&").concat(o.contractName, ".Vault{FungibleToken.Balance}>(\n              ").concat(o.balancePublicPath, ",\n              target: ").concat(o.storagePath, "\n          )\n      }\n");
};
exports.getVaultInitTx = getVaultInitTx;
var getUSDCVaultInitTx = function () { return "\n      // ******\n\t\t\t// IMPORTANT UNCOMMENT WHEN USDCFLOW IS READY FOR CRESCENDO\n\t\t\t// ******\n\t\t\t// if signer.storage.borrow<&USDCFlow.Vault>(from: /storage/usdcFlowVault) == nil {\n\t\t\t// \t\t// Create a new flowToken Vault and put it in storage\n\t\t\t// \t\tsigner.storage.save(<-USDCFlow.createEmptyVault(), to: /storage/usdcFlowVault)\n\n\t\t\t// \t\t// Create a public capability to the Vault that only exposes\n\t\t\t// \t\t// the deposit function through the Receiver interface\n\t\t\t// \t\tlet vaultCap = signer.capabilities.storage.issue<&USDCFlow.Vault>(\n\t\t\t// \t\t\t\t/storage/usdcFlowVault\n\t\t\t// \t\t)\n\n\t\t\t// \t\tsigner.capabilities.publish(\n\t\t\t// \t\t\t\tvaultCap,\n\t\t\t// \t\t\t\tat: /public/usdcFlowReceiver\n\t\t\t// \t\t)\n\n\t\t\t// \t\t// Create a public capability to the Vault that only exposes\n\t\t\t// \t\t// the balance field through the Balance interface\n\t\t\t// \t\tlet balanceCap = signer.capabilities.storage.issue<&USDCFlow.Vault>(\n\t\t\t// \t\t\t\t/storage/usdcFlowVault\n\t\t\t// \t\t)\n\n\t\t\t// \t\tsigner.capabilities.publish(\n\t\t\t// \t\t\t\tbalanceCap,\n\t\t\t// \t\t\t\tat: /public/usdcFlowMetadata\n\t\t\t// \t\t)\n\t\t\t// }\n"; };
exports.getUSDCVaultInitTx = getUSDCVaultInitTx;
exports.defaultVaultOptions = {
    contractName: "%ftContract%",
    storagePath: "%ftStoragePath%",
    publicPath: "%ftPublicPath%",
    balancePublicPath: "%ftBalancePublicPath%",
};
exports.vaultOptions = {
    "FiatToken": {
        contractName: "FiatToken",
        storagePath: "FiatToken.VaultStoragePath",
        publicPath: "FiatToken.VaultReceiverPubPath",
        balancePublicPath: "FiatToken.VaultBalancePubPath",
    },
    "FUSD": {
        contractName: "FUSD",
        storagePath: "/storage/fusdVault",
        publicPath: "/public/fusdReceiver",
        balancePublicPath: "/public/fusdBalance",
    },
};
exports.txInitVault = "\nimport NonFungibleToken from 0xNonFungibleToken\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport FUSD from 0xFUSD\nimport FiatToken from 0xFiatToken\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n".concat((0, exports.getVaultInitTx)(exports.vaultOptions["FiatToken"]), "\n    }\n    execute {\n    }\n}");
