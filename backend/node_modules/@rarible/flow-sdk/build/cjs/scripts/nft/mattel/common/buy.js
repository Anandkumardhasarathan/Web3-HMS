"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuyTxCode = void 0;
var contracts_1 = require("../../contracts");
function getBuyTxCode(options) {
    return "\nimport %ftContract% from 0x%ftContract%\nimport ".concat(contracts_1.FungibleToken.name, " from 0xFungibleToken\nimport ").concat(contracts_1.MetadataViews.name, " from 0xMetadataViews\nimport ").concat(contracts_1.NonFungibleToken.name, " from 0xNonFungibleToken\nimport ").concat(contracts_1.NFTStorefrontV2.name, " from 0xNFTStorefrontV2\n").concat((options === null || options === void 0 ? void 0 : options.additionalImports) || "", "\n\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    let paymentVault: @{").concat(contracts_1.FungibleToken.name, ".Vault}\n    let %nftContract%Collection: &{NonFungibleToken.Receiver}\n    let storefront: &{NFTStorefrontV2.StorefrontPublic}\n    let listing: &{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{").concat(contracts_1.FungibleToken.name, ".Receiver}>?\n\n    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability, Storage) &Account) {\n").concat((options === null || options === void 0 ? void 0 : options.preparePreHookCode) || "", "\n\n        self.commissionRecipientCap = nil\n        self.storefront = getAccount(storefrontAddress).capabilities.borrow<&{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            ) ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        let mainFlowVault = acct.storage.borrow<auth(FungibleToken.Withdraw) &%ftContract%.Vault>(from: %ftStoragePath%)\n            ?? panic(\"Cannot borrow FlowToken vault from acct storage\")\n        // Access the vault of the buyer to pay the sale price of the listing.\n        self.paymentVault <- mainFlowVault.withdraw(amount: price)\n\n        let collectionData = %nftContract%.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.%nftContract%Collection = acct.capabilities.borrow<&{NonFungibleToken.Receiver}>(collectionData.publicPath)\n            ?? panic(\"Cannot borrow buyers Pack collection receiver\")\n\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            let _commissionRecipientCap = getAccount(commissionRecipient!).capabilities.get<&{FungibleToken.Receiver}>(\n               %ftPublicPath%\n            )\n            // Access the capability to receive the commission.\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have FT receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.%nftContract%Collection.deposit(token: <-item)\n    }\n}\n");
}
exports.getBuyTxCode = getBuyTxCode;
