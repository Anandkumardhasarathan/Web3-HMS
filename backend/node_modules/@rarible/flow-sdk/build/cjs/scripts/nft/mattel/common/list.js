"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getListTxCode = void 0;
var getListTxCode = function (collection, options) {
    var borrowMethod = "borrowNFT";
    return "\nimport %ftContract% from 0x%ftContract%\nimport FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n".concat((options === null || options === void 0 ? void 0 : options.additionalImports) || "", "\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    let tokenReceiver: Capability<&{FungibleToken.Receiver}>\n    let %nftContract%Provider: Capability<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>\n    let storefront: auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]\n\n    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability, Storage) &Account) {\n").concat((options === null || options === void 0 ? void 0 : options.preparePreHookCode) || "", "\n\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        let collectionData = ").concat(collection, ".resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n             ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n        // Receiver for the sale cut.\n        self.tokenReceiver = acct.capabilities.get<&{FungibleToken.Receiver}>(%ftPublicPath%)\n        assert(self.tokenReceiver.borrow() != nil, message: \"Missing or mis-typed Flow receiver\")\n\n        self.%nftContract%Provider = acct.capabilities.storage.issue<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Collection}>(\n                collectionData.storagePath\n        )\n        assert(self.%nftContract%Provider.check(), message: \"Missing or mis-typed Collection provider\")\n\n        let collection = acct.capabilities.borrow<&{NonFungibleToken.Collection}>(\n            collectionData.publicPath\n        ) ?? panic(\"Could not borrow a reference to the signer's collection\")\n\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n        // eslint-disable-next-line\n        let nft = collection.").concat(borrowMethod, "(saleItemID)!\n        // Check whether the NFT implements the MetadataResolver or not.\n        if nft.getViews().contains(Type<MetadataViews.Royalties>()) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                let royaltyValue = royalty.cut * saleItemPrice\n                self.saleCuts.append(\n                    NFTStorefrontV2.SaleCut(\n                        receiver: royalty.receiver,\n                        amount: royaltyValue\n                    )\n                )\n                totalRoyaltyCut = totalRoyaltyCut + royaltyValue\n            }\n        }\n        // Append the cut for the seller.\n        self.saleCuts.append(\n            NFTStorefrontV2.SaleCut(\n                receiver: self.tokenReceiver,\n                amount: effectiveSaleItemPrice - totalRoyaltyCut\n            )\n        )\n        assert(self.%nftContract%Provider.borrow() != nil, message: \"Missing or mis-typed %nftContract%.Collection provider\")\n\n        self.storefront = acct.storage.borrow<auth(NFTStorefrontV2.CreateListing) &NFTStorefrontV2.Storefront>(\n                from: NFTStorefrontV2.StorefrontStoragePath\n            ) ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            // Here we are making a fair assumption that all given addresses would have\n            // the capability to receive the\n            self.marketplacesCapability.append(\n                getAccount(marketplace).capabilities.get<&{FungibleToken.Receiver}>(%ftPublicPath%)\n            )\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.%nftContract%Provider,\n            nftType: Type<@%nftContract%.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@%ftContract%.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n");
};
exports.getListTxCode = getListTxCode;
