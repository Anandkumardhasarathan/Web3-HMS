"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransferCode = void 0;
var getTransferCode = function (collection) { return "\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport ".concat(collection, " from 0x").concat(collection, "\n\ntransaction(\n    cardEditionID: UInt64\n    , to: Address\n    ) {\n\n    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {\n        // Setup Card Collection\n        let cardCollectionData: MetadataViews.NFTCollectionData = ").concat(collection, ".resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n            ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n        // exit if cardCollection exists\n        if acct.storage.borrow<&").concat(collection, ".Collection>(from: cardCollectionData.storagePath) == nil {\n            // create a new empty cardCollection for ").concat(collection, "\n            let cardCollection: @{NonFungibleToken.Collection} <- ").concat(collection, ".createEmptyCollection(nftType: Type<@").concat(collection, ".NFT>())\n\n            // save ").concat(collection, " cardCollection to the account\n            acct.storage.save(<-cardCollection, to: cardCollectionData.storagePath)\n\n            // create a public capability for the ").concat(collection, " cardCollection\n            acct.capabilities.unpublish(cardCollectionData.publicPath) // remove any current pubCap\n            let cardCollectionCap: Capability<&").concat(collection, ".Collection> = acct.capabilities.storage.issue<&").concat(collection, ".Collection>(cardCollectionData.storagePath)\n            acct.capabilities.publish(cardCollectionCap, at: cardCollectionData.publicPath)\n        }\n\n        let cardToTransfer: @").concat(collection, ".NFT <-acct.storage.borrow<auth(NonFungibleToken.Withdraw) &{NonFungibleToken.Provider}>(from: ").concat(collection, ".CollectionStoragePath)!.withdraw(withdrawID: cardEditionID) as! @").concat(collection, ".NFT\n        ").concat(collection, ".transfer(uuid: cardToTransfer.uuid, id: cardToTransfer.id, packSeriesId: cardToTransfer.packSeriesID, cardEditionId: cardToTransfer.id,  toAddress: to)\n        getAccount(to).capabilities.get<&{NonFungibleToken.Receiver}>(").concat(collection, ".CollectionPublicPath).borrow()!.deposit(token: <-cardToTransfer)\n\n    }\n    execute {\n    }\n}\n\n"); };
exports.getTransferCode = getTransferCode;
