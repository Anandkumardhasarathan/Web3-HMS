"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNftCode = void 0;
var tslib_1 = require("tslib");
var t = tslib_1.__importStar(require("@onflow/types"));
var convert_royalties_1 = require("../common/convert-royalties");
var cadence_code_config_1 = require("../config/cadence-code-config");
var types_1 = require("../types");
var template_replacer_1 = require("../common/template-replacer");
var nft_1 = require("../scripts/nft");
var transfer_1 = require("../scripts/nft/mattel/transfer");
var hw_v1_card_1 = require("../scripts/nft/mattel/garage/transfer/hw-v1-card");
var hw_v2_card_1 = require("../scripts/nft/mattel/garage/transfer/hw-v2-card");
var hw_v2_pack_1 = require("../scripts/nft/mattel/garage/transfer/hw-v2-pack");
var hw_v2_token_1 = require("../scripts/nft/mattel/garage/transfer/hw-v2-token");
function getNftCode(name) {
    if (types_1.NON_FUNGIBLE_CONTRACTS.includes(name)) {
        var map_1 = (0, cadence_code_config_1.getNftCodeConfig)(name);
        return {
            burn: function (fcl, tokenId) {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(nft_1.commonNft.burn, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64)]),
                };
            },
            transfer: function (fcl, tokenId, to) {
                var transferCdc;
                switch (name) {
                    case "HWGarageCard":
                        transferCdc = hw_v1_card_1.hwV1CardTransfer;
                        break;
                    case "HWGarageCardV2":
                        transferCdc = hw_v2_card_1.hwV2CardTransfer;
                        break;
                    case "HWGaragePackV2":
                        transferCdc = hw_v2_pack_1.hwV2PackTransfer;
                        break;
                    case "HWGarageTokenV2":
                        transferCdc = hw_v2_token_1.hwV2TokenTransfer;
                        break;
                    case "HWGaragePack":
                    case "BBxBarbieCard":
                    case "BBxBarbiePack":
                    case "BBxBarbieToken":
                        transferCdc = (0, transfer_1.getTransferCode)(name);
                        break;
                    default: transferCdc = nft_1.commonNft.transfer;
                }
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(transferCdc, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64), fcl.arg(to, t.Address)]),
                };
            },
            mint: function (fcl, address, metadata, royalties) {
                if (name === "RaribleNFT") {
                    var RoyaltiesType = t.Array(t.Struct("A.".concat(fcl.sansPrefix(address), ".RaribleNFT.Royalty"), [
                        { value: t.Address },
                        { value: t.UFix64 },
                    ]));
                    return {
                        cadence: nft_1.RaribleNFT.mint,
                        args: fcl.args([
                            fcl.arg(metadata, t.String),
                            fcl.arg((0, convert_royalties_1.convertRoyalties)(royalties), RoyaltiesType),
                        ]),
                    };
                }
                throw new Error("This collection doesn't support minting");
            },
            check: function (fcl, address) {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(nft_1.commonNft.check, map_1),
                    args: fcl.args([fcl.arg(address, t.Address)]),
                };
            },
            setupAccount: function () {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(nft_1.commonNft.setupAccount, map_1),
                };
            },
        };
    }
    throw new Error("Flow-sdk: Unsupported collection: ".concat(name));
}
exports.getNftCode = getNftCode;
