import type { Fcl } from "@rarible/fcl-types";
import type { Maybe } from "@rarible/types";
import type { ConfigurationParameters, FlowOrder, FlowRoyalty } from "@rarible/flow-api-client";
import * as ApiClient from "@rarible/flow-api-client";
import type { BigNumberLike, FlowAddress, FlowContractAddress } from "@rarible/types";
import { toFlowContractAddress, isFlowContractAddress } from "@rarible/types";
import type { FlowMintResponse } from "./nft/mint";
import type { FlowSellRequest, FlowSellResponse } from "./order/sell";
import { getFungibleBalance as getFungibleBalanceTemplate } from "./wallet/get-fungible-balance";
import type { ProtocolFees } from "./order/get-protocol-fee";
import type { AuthWithPrivateKey, FlowCurrency, FlowEnv, FlowOriginFees, FlowTransaction } from "./types";
import type { FlowUpdateOrderRequest } from "./order/update-order";
import type { FlowItemId } from "./common/item";
import type { FlowEnvConfig } from "./config/env";
import type { TransferFlowRequest } from "./wallet/transfer-funds";
import type { CollectionsInitStatus, GamisodesInitStatus } from "./collection/check-init-collections";
export interface FlowApisSdk {
    order: ApiClient.FlowOrderControllerApi;
    collection: ApiClient.FlowNftCollectionControllerApi;
    item: ApiClient.FlowNftItemControllerApi;
    ownership: ApiClient.FlowNftOwnershipControllerApi;
}
export interface FlowNftSdk {
    /**
     * Mint new NFT in specific collection
     * @param collection
     * @param metadata
     * @param royalties
     */
    mint(collection: FlowContractAddress, metadata: string, royalties: FlowRoyalty[]): Promise<FlowMintResponse>;
    /**
     * Transfer NFT to flow user
     * @param collection
     * @param tokenId
     * @param to
     */
    transfer(collection: FlowContractAddress, tokenId: number, to: FlowAddress): Promise<FlowTransaction>;
    /**
     * Burn specific NFT token
     * @param collection
     * @param tokenId
     */
    burn(collection: FlowContractAddress, tokenId: number): Promise<FlowTransaction>;
}
export interface FlowOrderSdk {
    /**
     * Create sell order for NFT token
     */
    sell(sellRequest: FlowSellRequest): Promise<FlowSellResponse>;
    /**
     * Update sell order
     */
    updateOrder(updateRequest: FlowUpdateOrderRequest): Promise<FlowSellResponse>;
    /**
     * Initiate NFT purchase
     */
    fill(collection: FlowContractAddress, currency: FlowCurrency, orderId: string | number | FlowOrder, owner: string, fees: FlowOriginFees): Promise<FlowTransaction>;
    /**
     * Cancel sell order
     * @param collection
     * @param orderId
     */
    cancelOrder(collection: FlowContractAddress, orderId: string | number): Promise<FlowTransaction>;
    /**
     * Create bid
     * @param collection
     * @param currency
     * @param itemId
     * @param price
     * @param originFee
     */
    bid(collection: FlowContractAddress, currency: FlowCurrency, itemId: FlowItemId, price: BigNumberLike, originFee?: FlowOriginFees): Promise<FlowSellResponse>;
    /**
     * @param collection
     * @param currency
     * @param order
     * @param price
     */
    bidUpdate(collection: FlowContractAddress, currency: FlowCurrency, order: string | number | FlowOrder, price: BigNumberLike): Promise<FlowSellResponse>;
    /**
     * Cancel sell order
     * @param collection
     * @param orderId
     */
    cancelBid(collection: FlowContractAddress, orderId: number | string): Promise<FlowTransaction>;
    getProtocolFee(): ProtocolFees;
}
export interface FlowWalletSdk {
    getFungibleBalance(address: FlowAddress, currency: FlowCurrency): Promise<string>;
    transferFunds(request: TransferFlowRequest): Promise<FlowTransaction>;
    setupVault(): Promise<FlowTransaction>;
}
export interface FlowCollectionSdk {
    setupAccount(collection: FlowContractAddress): Promise<FlowTransaction>;
    setupCollections(): Promise<FlowTransaction>;
    setupMattelCollections(): Promise<FlowTransaction>;
    setupGamisodesCollections(): Promise<FlowTransaction>;
    checkInitCollections(address?: FlowAddress): Promise<CollectionsInitStatus>;
    checkInitGamisodesCollections(address?: FlowAddress): Promise<GamisodesInitStatus>;
}
export interface FlowSdk {
    apis: FlowApisSdk;
    nft: FlowNftSdk;
    order: FlowOrderSdk;
    collection: FlowCollectionSdk;
    wallet: FlowWalletSdk;
    signUserMessage(message: string): Promise<string>;
}
export declare function createFlowApisSdk(env: FlowEnv, params?: ConfigurationParameters): FlowApisSdk;
/**
 * Creates new instance of FlowSdk
 * @param fcl
 * @param network
 * @param params - api configuration
 * @param auth - optional, only for testing purposes
 */
export declare function createFlowSdk(fcl: Maybe<Fcl>, network: FlowEnv, params?: ConfigurationParameters, auth?: AuthWithPrivateKey): FlowSdk;
export type { FlowNetwork, FlowCurrency, FlowTransaction, AuthWithPrivateKey, FlowFee } from "./types";
export type { FlowRoyalty } from "@rarible/flow-api-client";
export { toFlowItemId, isFlowItemId } from "./common/item/index";
export { replaceImportAddresses } from "./common/template-replacer";
export { waitForSeal } from "./common/transaction";
export type { FlowItemId } from "./common/item/index";
export { toFlowContractAddress, isFlowContractAddress, FlowContractAddress };
export type { FlowEnv } from "./config/env";
export declare const FLOW_ENV_CONFIG: FlowEnvConfig;
export { FlowOrder } from "@rarible/flow-api-client";
export { getFungibleBalanceSimple } from "./wallet/get-ft-balance-simple";
export { CollectionsInitStatus, GamisodesInitStatus } from "./collection/check-init-collections";
export { CONFIGS } from "./config/config";
export declare const getFlowFungibleBalance: typeof getFungibleBalanceTemplate;
