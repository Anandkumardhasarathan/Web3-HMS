import { __assign, __spreadArray } from "tslib";
import { toBn } from "@rarible/utils";
import { toBigNumberLike, toFlowAddress } from "@rarible/types";
import { withPrefix } from "../../common/prefix";
/**
 * Gets fees in percents and convert to currency value
 * @param mainPayoutAddress - seller address
 * @param price - order price
 * @param fees - royalties, protocolFee, originFee
 * @param payouts - payoutFee
 * @returns FlowFee - calculated fees in currency
 */
export function calculateSaleCuts(mainPayoutAddress, price, fees, payouts) {
    var startPrice = toBn(price);
    var leftAfterFees = toBn(price);
    var resultFeeSaleCuts = fees.map(function (fee) {
        var value = startPrice.multipliedBy(toBn(fee.value));
        leftAfterFees = leftAfterFees.minus(value);
        return __assign(__assign({}, fee), { value: toBigNumberLike(value.decimalPlaces(8).toString()) });
    });
    var leftAfterPayouts = toBn(leftAfterFees);
    var resultPayoutSaleCuts = payouts.map(function (fee) {
        var value = leftAfterFees.multipliedBy(toBn(fee.value));
        leftAfterPayouts = leftAfterPayouts.minus(value);
        return __assign(__assign({}, fee), { value: toBigNumberLike(value.decimalPlaces(8).toString()) });
    });
    if (leftAfterPayouts.gt(0)) {
        resultPayoutSaleCuts.push({
            account: mainPayoutAddress,
            value: toBigNumberLike(leftAfterPayouts.decimalPlaces(8).toString()),
        });
    }
    else if (leftAfterPayouts.lt(0)) {
        throw new Error("Sum of payouts greater than price");
    }
    return concatNonUniqueFees(__spreadArray(__spreadArray([], resultFeeSaleCuts, true), resultPayoutSaleCuts, true));
}
export function concatNonUniqueFees(fees) {
    var unique = {};
    fees.forEach(function (f) {
        var account = withPrefix(f.account);
        if (account in unique) {
            unique[account] = toBn(unique[account]).plus(toBn(f.value)).toString();
        }
        else {
            unique[account] = f.value;
        }
    });
    return Object.keys(unique).map(function (k) { return ({ account: toFlowAddress(k), value: toBigNumberLike(unique[k]) }); });
}
