import { __assign, __awaiter, __generator } from "tslib";
import * as t from "@onflow/types";
import { toBigNumberLike, toFlowAddress } from "@rarible/types";
import { runScript } from "../../common/transaction";
import { CONFIGS } from "../../config/config";
import { withPrefix } from "../../common/prefix";
import { StorefrontCommon } from "../../scripts/storefront/storefront-common";
import { scriptOrderDetails } from "../../scripts/nft";
import { openBidCommon } from "../../scripts/bid/bid-common";
export function getOrderDetailsFromBlockchain(fcl, network, orderType, address, orderId) {
    return __awaiter(this, void 0, void 0, function () {
        var cadence, map, args, details, fungibleContract, protocolFeeReceiver, data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    switch (orderType) {
                        case "sell":
                            cadence = StorefrontCommon.read_listing_details;
                            map = {
                                NFTStorefront: CONFIGS[network].mainAddressMap.NFTStorefront,
                            };
                            break;
                        case "sellV2":
                            cadence = scriptOrderDetails;
                            map = {
                                NFTStorefrontV2: CONFIGS[network].mainAddressMap.NFTStorefrontV2,
                            };
                            break;
                        case "bid":
                            cadence = openBidCommon.readBidDetails;
                            map = {
                                RaribleOpenBid: CONFIGS[network].mainAddressMap.RaribleOpenBid,
                            };
                            break;
                        default:
                            throw new Error("Unsupported order type");
                    }
                    args = fcl.args([fcl.arg(address, t.Address), fcl.arg(orderId, t.UInt64)]);
                    return [4 /*yield*/, runScript(fcl, {
                            cadence: cadence,
                            args: args,
                        }, map)];
                case 1:
                    details = _a.sent();
                    if ("vaultType" in details) {
                        fungibleContract = details.vaultType.typeID.split(".")[2];
                    }
                    else if ("salePaymentVaultType" in details) {
                        fungibleContract = details.salePaymentVaultType.typeID.split(".")[2];
                    }
                    else {
                        throw new Error("Unknown order object type returned from blockchain");
                    }
                    protocolFeeReceiver = CONFIGS[network].protocolFee.account;
                    data = __assign(__assign({}, details), { saleCuts: ("saleCuts" in details ? details.saleCuts : details.cuts).map(function (s) { return ({
                            account: toFlowAddress(s.receiver.address),
                            value: toBigNumberLike(s.amount),
                        }); }) });
                    data.isLegacy = data.saleCuts.filter(function (s) { return withPrefix(s.account).toLowerCase() === withPrefix(protocolFeeReceiver).toLowerCase(); }).length > 1;
                    switch (fungibleContract) {
                        case "FlowToken":
                            return [2 /*return*/, __assign(__assign({}, data), { currency: "FLOW" })];
                        case "FUSD":
                            return [2 /*return*/, __assign(__assign({}, data), { currency: "FUSD" })];
                        default:
                            throw new Error("Unsupported fungible token");
                    }
                    return [2 /*return*/];
            }
        });
    });
}
export function getStorefrontV2OrderDetailsFromBlockchain(fcl, network, address, orderId) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, runScript(fcl, {
                    cadence: scriptOrderDetails,
                    args: fcl.args([fcl.arg(address, t.Address), fcl.arg(orderId, t.UInt64)]),
                }, { NFTStorefrontV2: CONFIGS[network].mainAddressMap.NFTStorefrontV2 })];
        });
    });
}
