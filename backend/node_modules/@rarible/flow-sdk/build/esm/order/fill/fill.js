import { __awaiter, __generator, __spreadArray } from "tslib";
import { toFlowAddress } from "@rarible/types";
import { getCollectionConfig } from "../../common/collection/get-config";
import { getProtocolFee } from "../get-protocol-fee";
import { getPreparedOrder } from "../common/get-prepared-order";
import { calculateFees } from "../../common/calculate-fees";
import { runTransaction, waitForSeal } from "../../common/transaction";
import { getOrderCode } from "../../tx-code-store/order/storefront";
import { getOrderDetailsFromBlockchain, } from "../common/get-order-details-from-blockchain";
import { fetchItemRoyalties } from "../common/fetch-item-royalties";
import { getWhitelabelOrderCode, isWhitelabelCollection } from "../../tx-code-store/order/whitelabel-storefront";
import { getOrderId } from "../common/get-order-id";
import { fillBidOrder } from "./fill-bid-order";
export function fill(fcl, auth, network, orderApi, itemApi, collection, currency, order, owner, originFee) {
    return __awaiter(this, void 0, void 0, function () {
        var from_1, _a, _b, _c, orderId, preparedOrder, _d, name_1, map, _e, fee, txId_1, blockChainOrder, fees, txId, protocolFee, orderPayouts, payouts, filteredPayouts, royalties, _f, includedFees;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    if (!fcl) return [3 /*break*/, 16];
                    if (!auth) return [3 /*break*/, 2];
                    _b = toFlowAddress;
                    return [4 /*yield*/, auth()];
                case 1:
                    _a = _b.apply(void 0, [(_g.sent()).addr]);
                    return [3 /*break*/, 4];
                case 2:
                    _c = toFlowAddress;
                    return [4 /*yield*/, fcl.currentUser().snapshot()];
                case 3:
                    _a = _c.apply(void 0, [(_g.sent()).addr]);
                    _g.label = 4;
                case 4:
                    from_1 = _a;
                    if (!from_1) {
                        throw new Error("FLOW-SDK: Can't get current user address");
                    }
                    orderId = getOrderId(order);
                    return [4 /*yield*/, getPreparedOrder(orderApi, order)];
                case 5:
                    preparedOrder = _g.sent();
                    console.log("prepared order", JSON.stringify(preparedOrder, null, " "));
                    _d = getCollectionConfig(network, collection), name_1 = _d.name, map = _d.map;
                    _e = preparedOrder.type;
                    switch (_e) {
                        case "LIST": return [3 /*break*/, 6];
                        case "BID": return [3 /*break*/, 11];
                    }
                    return [3 /*break*/, 15];
                case 6:
                    if (!isWhitelabelCollection(name_1)) return [3 /*break*/, 8];
                    fee = preparedOrder.data.originalFees[0];
                    return [4 /*yield*/, runTransaction(fcl, map, getWhitelabelOrderCode(fcl, name_1).buy({
                            orderId: orderId,
                            address: owner,
                            comissionRecipient: fee ? toFlowAddress(fee.account) : undefined,
                            currency: currency,
                        }), auth)];
                case 7:
                    txId_1 = _g.sent();
                    return [2 /*return*/, waitForSeal(fcl, txId_1)];
                case 8: return [4 /*yield*/, getOrderDetailsFromBlockchain(fcl, network, "sell", owner, orderId)];
                case 9:
                    blockChainOrder = _g.sent();
                    fees = [];
                    if (!blockChainOrder.isLegacy) {
                        fees = calculateFees(preparedOrder.take.value, __spreadArray(__spreadArray([], (originFee || []), true), [
                            getProtocolFee.percents(network).buyerFee,
                        ], false));
                    }
                    return [4 /*yield*/, runTransaction(fcl, map, getOrderCode(fcl, name_1).buy(currency, orderId, owner, fees), auth)];
                case 10:
                    txId = _g.sent();
                    return [2 /*return*/, waitForSeal(fcl, txId)];
                case 11:
                    protocolFee = [getProtocolFee.percents(network).sellerFee];
                    orderPayouts = preparedOrder.data.payouts;
                    payouts = !!orderPayouts.length ? orderPayouts : [];
                    filteredPayouts = payouts.filter(function (p) { return p.account !== from_1; });
                    if (!(network === "emulator")) return [3 /*break*/, 12];
                    _f = [];
                    return [3 /*break*/, 14];
                case 12: return [4 /*yield*/, fetchItemRoyalties(itemApi, preparedOrder.itemId)
                    /**
                     * fees included in price, royalties, originFees, protocolFees
                     */
                ];
                case 13:
                    _f = _g.sent();
                    _g.label = 14;
                case 14:
                    royalties = _f;
                    includedFees = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], filteredPayouts, true), (originFee || []), true), royalties, true), protocolFee, true);
                    return [2 /*return*/, fillBidOrder(fcl, auth, currency, name_1, map, orderId, owner, calculateFees(preparedOrder.make.value, includedFees))];
                case 15: throw new Error("Unsupported order type: ".concat(preparedOrder.type));
                case 16: throw new Error("Fcl is required for purchasing");
            }
        });
    });
}
