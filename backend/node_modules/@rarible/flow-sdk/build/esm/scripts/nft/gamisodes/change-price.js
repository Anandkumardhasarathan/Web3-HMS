import { getVaultInitTx, vaultOptions } from "../init-vault";
import { gamisodesRawInitPart } from "./init";
export var gamisodesChangePriceTxCode = function (currency) {
    return "\nimport %ftContract% from 0x%ftContract%\nimport FungibleToken from 0xFungibleToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\nimport TokenForwarding from 0xTokenForwarding\nimport Gamisodes from 0xGamisodes\nimport NiftoryNFTRegistry from 0xNiftoryNFTRegistry\nimport NiftoryNonFungibleToken from 0xNiftoryNonFungibleToken\n\ntransaction(removalListingResourceID: UInt64, saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    let storefrontForRemove: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    let fiatReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let %nftContract%Provider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n".concat(currency === "USDC" ? getVaultInitTx(vaultOptions["FiatToken"]) : "", "\n").concat(gamisodesRawInitPart, "\n\n        self.storefrontForRemove = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // We need a provider capability, but one is not provided by default so we create one if needed.\n        let %nftContract%ProviderPrivatePath = %nftPrivatePath%\n\n        // Receiver for the sale cut.\n        self.fiatReceiver = acct.getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%)\n        assert(self.fiatReceiver.borrow() != nil, message: \"Missing or mis-typed FiatToken receiver\")\n\n        // Check if the Provider capability exists or not if `no` then create a new link for the same.\n        if !acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, NiftoryNonFungibleToken.CollectionPublic}>(%nftContract%ProviderPrivatePath).check() {\n            acct.link<&{NonFungibleToken.Provider, NiftoryNonFungibleToken.CollectionPrivate}>(%nftContract%ProviderPrivatePath, target: %nftStoragePath%)\n        }\n\n        self.%nftContract%Provider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(%nftContract%ProviderPrivatePath)\n        let collection = acct\n            .getCapability(%nftPublicPath%)\n            .borrow<&{%nftPublicTypeMin%}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n        let nft = collection.borrowNFT(id: saleItemID)!\n        // Check whether the NFT implements the MetadataResolver or not.\n        if nft.getViews().contains(Type<MetadataViews.Royalties>()) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.fiatReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.%nftContract%Provider.borrow() != nil, message: \"Missing or mis-typed %nftContract%.Collection provider\")\n\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            // Here we are making a fair assumption that all given addresses would have\n            // the capability to receive the `FlowToken`\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%))\n        }\n    }\n\n    execute {\n        self.storefrontForRemove.removeListing(listingResourceID: removalListingResourceID)\n\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.%nftContract%Provider,\n            nftType: Type<@%nftContract%.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@%ftContract%.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n");
};
