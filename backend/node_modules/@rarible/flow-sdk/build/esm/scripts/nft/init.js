import { HWGarageCard, HWGaragePack } from "./contracts";
import { barbieRawInitPart } from "./mattel/barbie";
import { garageRawInitPart } from "./mattel/garage";
import { getUSDCVaultInitTx, getVaultInitTx, vaultOptions } from "./init-vault";
import { gamisodesRawInitPart } from "./gamisodes";
export var txInitMattelContractsAndStorefrontV2 = "\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport FUSD from 0xFUSD\nimport FiatToken from 0xFiatToken\nimport HWGarageCard from 0xHWGarageCard\nimport HWGaragePack from 0xHWGaragePack\nimport HWGarageCardV2 from 0xHWGarageCardV2\nimport HWGaragePackV2 from 0xHWGaragePackV2\nimport HWGarageTokenV2 from 0xHWGarageTokenV2\nimport BBxBarbiePack from 0xBBxBarbiePack\nimport BBxBarbieCard from 0xBBxBarbieCard\nimport BBxBarbieToken from 0xBBxBarbieToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n\ntransaction() {\n    prepare(acct: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {\n".concat(getUSDCVaultInitTx(), "\n").concat(garageRawInitPart, "\n").concat(barbieRawInitPart, "\n\n      if acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n      // Create a new empty Storefront\n      let storefront: @NFTStorefrontV2.Storefront <- NFTStorefrontV2.createStorefront()\n\n      // save it to the account\n      acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n      // create a public capability for the Storefront\n      let storefrontPublicCap: Capability<&{NFTStorefrontV2.StorefrontPublic}> = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(\n          NFTStorefrontV2.StorefrontStoragePath\n        )\n      acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)\n        }\n    }\n    execute {\n    }\n}");
export var txInitNFTContractsAndStorefrontV2 = "\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FungibleToken from 0xFungibleToken\nimport FlowToken from 0xFlowToken\nimport FUSD from 0xFUSD\nimport FiatToken from 0xFiatToken\nimport ".concat(HWGarageCard.name, " from 0xHWGarageCard\nimport ").concat(HWGaragePack.name, " from 0xHWGaragePack\nimport HWGarageCardV2 from 0xHWGarageCardV2\nimport HWGaragePackV2 from 0xHWGaragePackV2\nimport HWGarageTokenV2 from 0xHWGarageTokenV2\nimport BBxBarbiePack from 0xBBxBarbiePack\nimport BBxBarbieCard from 0xBBxBarbieCard\nimport BBxBarbieToken from 0xBBxBarbieToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n//Gamisodes\nimport TokenForwarding from 0xTokenForwarding\nimport Gamisodes from 0xGamisodes\nimport NiftoryNFTRegistry from 0xNiftoryNFTRegistry\nimport NiftoryNonFungibleToken from 0xNiftoryNonFungibleToken\n\ntransaction() {\n    prepare(acct: AuthAccount) {\n").concat(getVaultInitTx(vaultOptions["FiatToken"]), "\n").concat(garageRawInitPart, "\n").concat(barbieRawInitPart, "\n").concat(gamisodesRawInitPart, "\n\n      if acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n      // Create a new empty Storefront\n      let storefront: @NFTStorefrontV2.Storefront <- NFTStorefrontV2.createStorefront()\n\n      // save it to the account\n      acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n      // create a public capability for the Storefront\n      let storefrontPublicCap: Capability<&{NFTStorefrontV2.StorefrontPublic}> = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(\n          NFTStorefrontV2.StorefrontStoragePath\n        )\n      acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)\n        }\n    }\n    execute {\n    }\n}");
