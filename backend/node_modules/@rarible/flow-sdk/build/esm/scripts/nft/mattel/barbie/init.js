export var barbieRawInitPart = "\n// Setup Token Collection\n\n   let barbieTokenCollectionData: MetadataViews.NFTCollectionData = BBxBarbieToken.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n     ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n   // exit if tokenCollection exists\n   if acct.storage.borrow<&BBxBarbieToken.Collection>(from: barbieTokenCollectionData.storagePath) == nil {\n     // create a new empty tokenCollection for BBxBarbieToken\n     let tokenCollection: @{NonFungibleToken.Collection} <- BBxBarbieToken.createEmptyCollection(nftType: Type<@BBxBarbieToken.NFT>())\n\n     // save BBxBarbieToken tokenCollection to the account\n     acct.storage.save(<-tokenCollection, to: barbieTokenCollectionData.storagePath)\n\n     // create a public capability for the BBxBarbieToken tokenCollection\n     acct.capabilities.unpublish(barbieTokenCollectionData.publicPath) // remove any current pubCap\n     let tokenCollectionCap: Capability<&BBxBarbieToken.Collection> = acct.capabilities.storage.issue<&BBxBarbieToken.Collection>(barbieTokenCollectionData.storagePath)\n     acct.capabilities.publish(tokenCollectionCap, at: barbieTokenCollectionData.publicPath)\n   }\n\n\n\n   // Setup Card Collection\n\n   let barbieCardCollectionData: MetadataViews.NFTCollectionData = BBxBarbieCard.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n     ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n   // exit if cardCollection exists\n   if acct.storage.borrow<&BBxBarbieCard.Collection>(from: barbieCardCollectionData.storagePath) == nil {\n     // create a new empty cardCollection for BBxBarbieCard\n     let cardCollection: @{NonFungibleToken.Collection} <- BBxBarbieCard.createEmptyCollection(nftType: Type<@BBxBarbieCard.NFT>())\n\n     // save BBxBarbieCard cardCollection to the account\n     acct.storage.save(<-cardCollection, to: barbieCardCollectionData.storagePath)\n\n     // create a public capability for the BBxBarbieCard cardCollection\n     acct.capabilities.unpublish(barbieCardCollectionData.publicPath) // remove any current pubCap\n     let cardCollectionCap: Capability<&BBxBarbieCard.Collection> = acct.capabilities.storage.issue<&BBxBarbieCard.Collection>(barbieCardCollectionData.storagePath)\n     acct.capabilities.publish(cardCollectionCap, at: barbieCardCollectionData.publicPath)\n   }\n   // Setup Pack Collection\n\n   let barbiePackCollectionData: MetadataViews.NFTCollectionData = BBxBarbiePack.resolveContractView(resourceType: nil, viewType: Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?\n     ?? panic(\"ViewResolver does not resolve NFTCollectionData view\")\n\n   // exit if packCollection exists\n   if acct.storage.borrow<&BBxBarbiePack.Collection>(from: barbiePackCollectionData.storagePath) == nil {\n     // create a new empty packCollection for BBxBarbiePack\n     let packCollection: @{NonFungibleToken.Collection} <- BBxBarbiePack.createEmptyCollection(nftType: Type<@BBxBarbiePack.NFT>())\n\n     // save BBxBarbiePack packCollection to the account\n     acct.storage.save(<-packCollection, to: barbiePackCollectionData.storagePath)\n\n     // create a public capability for the BBxBarbiePack packCollection\n     acct.capabilities.unpublish(barbiePackCollectionData.publicPath) // remove any current pubCap\n     let packCollectionCap: Capability<&BBxBarbiePack.Collection> = acct.capabilities.storage.issue<&BBxBarbiePack.Collection>(barbiePackCollectionData.storagePath)\n     acct.capabilities.publish(packCollectionCap, at: barbiePackCollectionData.publicPath)\n   }\n";
export var barbiePreparePartOfInit = "\n".concat(barbieRawInitPart, "\n\n\t\tif acct.storage.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n    // Create a new empty Storefront\n    let storefront: @NFTStorefrontV2.Storefront <- NFTStorefrontV2.createStorefront()\n\n    // save it to the account\n    acct.storage.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n\n    // create a public capability for the Storefront\n    let storefrontPublicCap: Capability<&{NFTStorefrontV2.StorefrontPublic}> = acct.capabilities.storage.issue<&{NFTStorefrontV2.StorefrontPublic}>(\n        NFTStorefrontV2.StorefrontStoragePath\n      )\n    acct.capabilities.publish(storefrontPublicCap, at: NFTStorefrontV2.StorefrontPublicPath)\n      }\n");
export var barbieImports = "\nimport BBxBarbiePack from 0xBBxBarbiePack\nimport BBxBarbieCard from 0xBBxBarbieCard\nimport BBxBarbieToken from 0xBBxBarbieToken\n";
