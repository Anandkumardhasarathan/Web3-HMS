import * as t from "@onflow/types";
import { convertRoyalties } from "../common/convert-royalties";
import { getNftCodeConfig } from "../config/cadence-code-config";
import { NON_FUNGIBLE_CONTRACTS } from "../types";
import { fillCodeTemplate } from "../common/template-replacer";
import { commonNft, RaribleNFT } from "../scripts/nft";
import { getTransferCode } from "../scripts/nft/mattel/transfer";
import { hwV1CardTransfer } from "../scripts/nft/mattel/garage/transfer/hw-v1-card";
import { hwV2CardTransfer } from "../scripts/nft/mattel/garage/transfer/hw-v2-card";
import { hwV2PackTransfer } from "../scripts/nft/mattel/garage/transfer/hw-v2-pack";
import { hwV2TokenTransfer } from "../scripts/nft/mattel/garage/transfer/hw-v2-token";
export function getNftCode(name) {
    if (NON_FUNGIBLE_CONTRACTS.includes(name)) {
        var map_1 = getNftCodeConfig(name);
        return {
            burn: function (fcl, tokenId) {
                return {
                    cadence: fillCodeTemplate(commonNft.burn, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64)]),
                };
            },
            transfer: function (fcl, tokenId, to) {
                var transferCdc;
                switch (name) {
                    case "HWGarageCard":
                        transferCdc = hwV1CardTransfer;
                        break;
                    case "HWGarageCardV2":
                        transferCdc = hwV2CardTransfer;
                        break;
                    case "HWGaragePackV2":
                        transferCdc = hwV2PackTransfer;
                        break;
                    case "HWGarageTokenV2":
                        transferCdc = hwV2TokenTransfer;
                        break;
                    case "HWGaragePack":
                    case "BBxBarbieCard":
                    case "BBxBarbiePack":
                    case "BBxBarbieToken":
                        transferCdc = getTransferCode(name);
                        break;
                    default: transferCdc = commonNft.transfer;
                }
                return {
                    cadence: fillCodeTemplate(transferCdc, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64), fcl.arg(to, t.Address)]),
                };
            },
            mint: function (fcl, address, metadata, royalties) {
                if (name === "RaribleNFT") {
                    var RoyaltiesType = t.Array(t.Struct("A.".concat(fcl.sansPrefix(address), ".RaribleNFT.Royalty"), [
                        { value: t.Address },
                        { value: t.UFix64 },
                    ]));
                    return {
                        cadence: RaribleNFT.mint,
                        args: fcl.args([
                            fcl.arg(metadata, t.String),
                            fcl.arg(convertRoyalties(royalties), RoyaltiesType),
                        ]),
                    };
                }
                throw new Error("This collection doesn't support minting");
            },
            check: function (fcl, address) {
                return {
                    cadence: fillCodeTemplate(commonNft.check, map_1),
                    args: fcl.args([fcl.arg(address, t.Address)]),
                };
            },
            setupAccount: function () {
                return {
                    cadence: fillCodeTemplate(commonNft.setupAccount, map_1),
                };
            },
        };
    }
    throw new Error("Flow-sdk: Unsupported collection: ".concat(name));
}
