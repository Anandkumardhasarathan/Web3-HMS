"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancel = exports.buy = exports.sell = void 0;
const tslib_1 = require("tslib");
const convert_fees_1 = require("../common/convert-fees");
const utils_1 = require("../common/utils");
function sell(link, request) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (link === undefined) {
            throw new Error("Wallet undefined");
        }
        const { makeAssetType: { tokenId, contract }, takeAssetType, amount, payouts, originFees, } = request;
        const currencyContract = takeAssetType.assetClass === "ERC20" ? takeAssetType.contract : undefined;
        const orderId = (yield link.sell(Object.assign({ tokenId, tokenAddress: contract, fees: (0, convert_fees_1.convertFees)([...payouts, ...originFees]), amount }, (currencyContract ? { currencyAddress: currencyContract } : {}))));
        return {
            orderId,
        };
    });
}
exports.sell = sell;
function buy(env, link, apis, request, token) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        if (link === undefined) {
            throw new Error("Wallet undefined");
        }
        const { orderId, fee } = request;
        const buyResult = yield link.buy({
            orderIds: [orderId],
            fees: (0, convert_fees_1.convertFees)(fee),
        });
        const tradeResult = (_a = buyResult.result) === null || _a === void 0 ? void 0 : _a[orderId];
        if (tradeResult.status === "error") {
            throw new Error("Trade unsuccessful: " + tradeResult.message);
        }
        let txId = undefined;
        try {
            txId = yield (0, utils_1.retry)(20, 2000, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { result } = yield apis.trades.getTrades({
                    tokenType: token.assetClass,
                    tokenAddress: token.contract,
                    tokenId: token.tokenId,
                });
                const trade = result.find(trade => trade.b.order_id.toString() === orderId);
                if (!trade) {
                    throw new Error("Can't find trade with orderid " + orderId);
                }
                if (tradeResult.status === "success") {
                    return trade.transaction_id;
                }
            }));
        }
        catch (e) {
            console.error("Error while fetching trade", e);
        }
        return {
            txId,
        };
    });
}
exports.buy = buy;
function cancel(link, request) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (link === undefined) {
            throw new Error("Wallet undefined");
        }
        const { orderId } = request;
        const result = yield link.cancel({
            orderId,
        });
        return {
            orderId: result.order_id.toString(),
        };
    });
}
exports.cancel = cancel;
