"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IMX_ENV_CONFIG = exports.IMX_NETWORK_CONFIG = exports.ImxWallet = void 0;
const tslib_1 = require("tslib");
const imx_sdk_1 = require("@imtbl/imx-sdk");
const domain_1 = require("./domain");
const config_1 = require("./config");
Object.defineProperty(exports, "IMX_ENV_CONFIG", { enumerable: true, get: function () { return config_1.IMX_ENV_CONFIG; } });
Object.defineProperty(exports, "IMX_NETWORK_CONFIG", { enumerable: true, get: function () { return config_1.IMX_NETWORK_CONFIG; } });
class ImxWallet {
    constructor(env, provider = domain_1.ImxWalletProviderEnum.NONE, iframeOptions, storage = localStorage) {
        this.env = env;
        this.provider = provider;
        this.iframeOptions = iframeOptions;
        this.storage = storage;
        this.state = Object.keys(StorageKeyEnum).reduce((prev, curr) => (Object.assign(Object.assign({}, prev), { [curr]: this.storage.getItem(curr) || "" })), {});
        this.status = this.state[StorageKeyEnum.IMX_ADDRESS] ? "connected" : "disconnected";
        this.network = Object.assign(Object.assign({}, config_1.IMX_ENV_CONFIG[this.env]), { env: this.env });
        this.link = new imx_sdk_1.Link(this.network.linkAddress, this.iframeOptions, "v3");
        this.connect = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.link.setup(this.getSetupOptions());
                if (data.address && data.starkPublicKey) {
                    this.status = "connected";
                    this.state = {
                        [StorageKeyEnum.IMX_ADDRESS]: data.address,
                        [StorageKeyEnum.IMX_STARK_KEY]: data.starkPublicKey,
                        [StorageKeyEnum.IMX_ETH_NETWORK]: data.ethNetwork,
                        [StorageKeyEnum.IMX_PROVIDER]: data.providerPreference,
                    };
                    this.setValue(StorageKeyEnum.IMX_ADDRESS, data.address);
                    this.setValue(StorageKeyEnum.IMX_STARK_KEY, data.starkPublicKey);
                    this.setValue(StorageKeyEnum.IMX_ETH_NETWORK, data.ethNetwork);
                    this.setValue(StorageKeyEnum.IMX_PROVIDER, data.providerPreference);
                    return data;
                }
                throw new Error("There is no address or starkAddress in response");
            }
            catch (error) {
                console.error("Connection failed with reason", error);
                throw error;
            }
        });
        this.disconnect = () => {
            Object.keys(StorageKeyEnum).forEach(x => this.setValue(x, ""));
            this.status = "disconnected";
        };
        this.getConnectionData = () => ({
            address: this.state[StorageKeyEnum.IMX_ADDRESS],
            starkPublicKey: this.state[StorageKeyEnum.IMX_STARK_KEY],
            ethNetwork: this.state[StorageKeyEnum.IMX_ETH_NETWORK],
            providerPreference: this.state[StorageKeyEnum.IMX_PROVIDER],
            link: this.link,
            status: this.status,
        });
    }
    getSetupOptions() {
        return this.provider ? { providerPreference: imx_sdk_1.ProviderPreference[this.provider] } : {};
    }
    setValue(key, value) {
        this.state[key] = value;
        return this.storage.setItem(key, value);
    }
}
exports.ImxWallet = ImxWallet;
var StorageKeyEnum;
(function (StorageKeyEnum) {
    StorageKeyEnum["IMX_STARK_KEY"] = "IMX_STARK_KEY";
    StorageKeyEnum["IMX_ADDRESS"] = "IMX_ADDRESS";
    StorageKeyEnum["IMX_PROVIDER"] = "IMX_PROVIDER";
    StorageKeyEnum["IMX_ETH_NETWORK"] = "IMX_ETH_NETWORK";
})(StorageKeyEnum || (StorageKeyEnum = {}));
