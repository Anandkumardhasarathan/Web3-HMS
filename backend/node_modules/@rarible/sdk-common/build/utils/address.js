"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeAptosAddress = exports.isSupportedBlockchain = exports.FLOW_TOKEN_MAP = exports.validateBlockchain = exports.getEntityData = exports.extractId = exports.extractBlockchain = exports.extractBlockchainFromAssetType = void 0;
const blockchain_1 = require("./blockchain");
function extractBlockchainFromAssetType(assetType) {
    if (!assetType) {
        throw new Error("Asset type is expected");
    }
    if ("blockchain" in assetType && assetType.blockchain) {
        return validateBlockchain(assetType.blockchain);
    }
    if ("contract" in assetType && assetType.contract) {
        return extractBlockchain(assetType.contract);
    }
}
exports.extractBlockchainFromAssetType = extractBlockchainFromAssetType;
function extractBlockchain(value) {
    const idx = value.indexOf(":");
    if (idx === -1) {
        throw new Error(`Unable to extract blockchain from ${value}`);
    }
    const start = value.substring(0, idx);
    for (const blockchain of blockchain_1.SupportedBlockchains) {
        if (blockchain === start) {
            return blockchain;
        }
    }
    throw new Error(`Unable to extract blockchain from ${value}`);
}
exports.extractBlockchain = extractBlockchain;
function extractId(value) {
    const idx = value.indexOf(":");
    if (idx === -1)
        throw new Error(`Unable to extract blockchain from ${value}`);
    return value.substring(idx + 1);
}
exports.extractId = extractId;
function getEntityData(entity) {
    if (!entity) {
        throw new Error("Entity has not been specified");
    }
    const [blockchain, address] = entity.split(":");
    return {
        blockchain: validateBlockchain(blockchain),
        address,
    };
}
exports.getEntityData = getEntityData;
function validateBlockchain(blockchain) {
    if (!isSupportedBlockchain(blockchain)) {
        throw new Error(`Value: "${blockchain}" is not a supported blockchain type`);
    }
    return blockchain;
}
exports.validateBlockchain = validateBlockchain;
exports.FLOW_TOKEN_MAP = {
    testnet: "A.7e60df042a9c0868.FlowToken",
    prod: "A.1654653399040a61.FlowToken",
};
function isSupportedBlockchain(blockchain) {
    return blockchain_1.SupportedBlockchains.includes(blockchain);
}
exports.isSupportedBlockchain = isSupportedBlockchain;
function normalizeAptosAddress(address) {
    if (address.length === 66 && address.startsWith("0x"))
        return address;
    return `0x${address.replace("0x", "").padStart(64, "0")}`;
}
exports.normalizeAptosAddress = normalizeAptosAddress;
