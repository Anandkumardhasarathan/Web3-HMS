"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Balances = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const erc20_1 = require("../order/contracts/erc20");
const retry_1 = require("./retry");
const get_required_wallet_1 = require("./get-required-wallet");
const index_1 = require("./index");
class Balances {
    constructor(ethereum, send, getApis) {
        this.ethereum = ethereum;
        this.send = send;
        this.getApis = getApis;
        this.getBalance = this.getBalance.bind(this);
        this.transfer = this.transfer.bind(this);
    }
    getBalance(address, assetType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const apis = yield this.getApis();
            switch (assetType.assetClass) {
                case "ETH": {
                    const ethBalance = yield (0, retry_1.wrapInRetry)(() => apis.balances.getEthBalance({ owner: address }));
                    return (0, utils_1.toBn)(ethBalance.decimalBalance);
                }
                case "ERC20": {
                    const balance = yield (0, retry_1.wrapInRetry)(() => apis.balances.getErc20Balance({
                        contract: assetType.contract,
                        owner: address,
                    }));
                    return (0, utils_1.toBn)(balance.decimalBalance);
                }
                default:
                    throw new Error("Asset class is not supported");
            }
        });
    }
    getNormalizedTransferValue(asset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("value" in asset && asset.value)
                return asset.value;
            if ("valueDecimal" in asset && asset.valueDecimal) {
                if (asset.assetType.assetClass === "ETH") {
                    return (0, types_1.toBigNumber)((0, utils_1.toBn)(asset.valueDecimal).multipliedBy(index_1.ETHER_IN_WEI).toFixed());
                }
                if (asset.assetType.assetClass === "ERC20") {
                    const decimals = yield (0, erc20_1.createErc20Contract)((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), asset.assetType.contract)
                        .functionCall("decimals")
                        .call();
                    return (0, types_1.toBigNumber)((0, utils_1.toBn)(asset.valueDecimal)
                        .multipliedBy((0, utils_1.toBn)(10).pow(Number(decimals)))
                        .toFixed());
                }
            }
            throw new Error("TransferAsset must includes value");
        });
    }
    transfer(address, asset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const value = (yield this.getNormalizedTransferValue(asset)).toString();
            switch (asset.assetType.assetClass) {
                case "ETH": {
                    return (0, get_required_wallet_1.getRequiredWallet)(this.ethereum).sendTransaction({
                        to: address,
                        value,
                    });
                }
                case "ERC20": {
                    const fn = yield (0, erc20_1.createErc20Contract)((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), asset.assetType.contract).functionCall("transfer", address, value);
                    return this.send(fn);
                }
                default:
                    throw new Error("Unrecognized asset type for transfer");
            }
        });
    }
}
exports.Balances = Balances;
