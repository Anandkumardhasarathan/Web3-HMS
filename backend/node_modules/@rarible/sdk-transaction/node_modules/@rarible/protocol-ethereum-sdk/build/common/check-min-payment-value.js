"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkMinPaymentValue = exports.MIN_PAYMENT_VALUE_DECIMAL = exports.MIN_PAYMENT_VALUE = exports.checkGreaterThanMinPaymentValue = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const build_1 = require("@rarible/logger/build");
const common_1 = require("../nft/common");
const is_nft_1 = require("../order/is-nft");
const get_price_1 = require("./get-price");
const index_1 = require("./index");
function checkGreaterThanMinPaymentValue(ethereum_1, _a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, { assetType, value }) {
        const priceDecimal = yield (0, get_price_1.getPriceDecimal)(ethereum, assetType, value);
        if (((0, common_1.isETH)(assetType) || (0, common_1.isErc20)(assetType)) && !priceDecimal.gte(exports.MIN_PAYMENT_VALUE_DECIMAL) && !priceDecimal.eq(0)) {
            throw new build_1.Warning(`Asset value must be greater or equal to ${exports.MIN_PAYMENT_VALUE_DECIMAL.toFixed()}`);
        }
    });
}
exports.checkGreaterThanMinPaymentValue = checkGreaterThanMinPaymentValue;
// Min value 0.0001 in ETH/Rari/Weth on listing/bidding
exports.MIN_PAYMENT_VALUE = new utils_1.BigNumber(10).pow(12);
exports.MIN_PAYMENT_VALUE_DECIMAL = exports.MIN_PAYMENT_VALUE.div(index_1.ETHER_IN_WEI);
function checkMinPaymentValue(ethereum, checked) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, is_nft_1.isNft)(checked.make.assetType)) {
            yield checkGreaterThanMinPaymentValue(ethereum, checked.take);
        }
        else if ((0, is_nft_1.isNft)(checked.take.assetType)) {
            yield checkGreaterThanMinPaymentValue(ethereum, checked.make);
        }
    });
}
exports.checkMinPaymentValue = checkMinPaymentValue;
