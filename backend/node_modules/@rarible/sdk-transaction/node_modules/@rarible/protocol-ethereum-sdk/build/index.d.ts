import type { Ethereum, EthereumTransaction } from "@rarible/ethereum-provider";
import type { EVMAddress, AssetType, OrderForm } from "@rarible/ethereum-api-client";
import type { BigNumber } from "@rarible/utils";
import type { Address, Maybe } from "@rarible/types";
import type { BigNumberValue } from "@rarible/utils";
import type { AmmTradeInfo } from "@rarible/ethereum-api-client/build/models";
import type { GetAmmBuyInfoRequest } from "@rarible/ethereum-api-client/build/apis/OrderControllerApi";
import type { UpsertOrderAction } from "./order/upsert-order";
import type { SellOrderAction, SellOrderUpdateAction } from "./order/sell";
import type { BidOrderAction, BidUpdateOrderAction } from "./order/bid";
import type { MintOffChainResponse, MintOnChainResponse, MintRequest } from "./nft/mint";
import type { TransferAsset } from "./nft/transfer";
import type { BurnRequest } from "./nft/burn";
import type { RaribleEthereumApis } from "./common/apis";
import type { FillBatchOrderAction, FillOrderAction, GetOrderBuyTxData, GetOrderFillTxData } from "./order/fill-order/types";
import type { SimpleOrder } from "./order/types";
import type { DeployNft } from "./common/deploy";
import type { BalanceRequestAssetType, TransferBalanceAsset } from "./common/balances";
import type { EthereumNetwork, IRaribleEthereumSdkConfig } from "./types";
import type { CryptoPunksWrapper } from "./common/crypto-punks";
import type { AuctionStartAction, PutAuctionBidAction, BuyoutAuctionAction } from "./auction/types";
export interface RaribleOrderSdk {
    /**
     * Sell asset (create off-chain order and check if approval is needed)
     */
    sell: SellOrderAction;
    /**
     * Update price in existing sell order (with approval checking)
     */
    sellUpdate: SellOrderUpdateAction;
    /**
     * Create bid (create off-chain order and check if approval is needed)
     */
    bid: BidOrderAction;
    /**
     * Update price in existing bid order (with approval checking)
     */
    bidUpdate: BidUpdateOrderAction;
    /**
     * Fill order (buy or accept bid - depending on the order type)
     *
     * @deprecated Use {@link buy} or {@link acceptBid} instead
     * @param request order and parameters (amount to fill, fees etc.)
     */
    fill: FillOrderAction;
    /**
     * Buy order
     *
     * @param request order and parameters (amount to fill, fees etc.)
     */
    buy: FillOrderAction;
    /**
     * Accept bid order
     *
     * @param request order and parameters (amount to fill, fees etc.)
     */
    acceptBid: FillOrderAction;
    /**
     * Purchase batch
     *
     * @param request array of order and parameters (amount to fill, fees etc.)
     */
    buyBatch: FillBatchOrderAction;
    /**
     * Get fill transaction data (for external sending)
     *
     * @param request order and parameters (amount to fill, fees etc.)
     */
    getFillTxData: GetOrderFillTxData;
    /**
     * Get buy transaction data (for external sending)
     *
     * @param request order and parameters (amount to fill, fees etc.)
     */
    getBuyTxData: GetOrderBuyTxData;
    /**
     * Sell or create bid. Low-level method
     */
    upsert: UpsertOrderAction;
    /**
     * Get base fee (this fee will be hold by the processing platform - in basis points)
     */
    getBaseOrderFee(type?: OrderForm["type"]): Promise<number>;
    /**
     * Get base fee for filling an order (this fee will be hold by the processing platform - in basis points)
     *
     * @param order Order which should be filled
     * @param withOriginFees set to true if you want to send origin fees for the order
     */
    getFillOrderBaseFee(order: SimpleOrder, withOriginFees?: boolean): Promise<number>;
    /**
     * Get for buy pricing info from AMM
     *
     * @param request AMM hash with amount of NFTs
     */
    getBuyAmmInfo(request: GetAmmBuyInfoRequest): Promise<AmmTradeInfo>;
    /**
     * Cancel order
     */
    cancel(order: SimpleOrder): Promise<EthereumTransaction>;
}
export interface RaribleNftSdk {
    /**
     *
     * @param request parameters for item to mint
     */
    mint(request: MintRequest): Promise<MintOnChainResponse | MintOffChainResponse>;
    /**
     * @param asset asset for transfer
     * @param to recipient address
     * @param amount for transfer
     */
    transfer(asset: TransferAsset, to: EVMAddress | Address, amount?: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * @param request burn request
     */
    burn(request: BurnRequest): Promise<EthereumTransaction | void>;
    deploy: DeployNft;
    cryptoPunks: CryptoPunksWrapper;
}
export interface RaribleBalancesSdk {
    /**
     * Returns balance of user, it can return balances for ERC20 and native ETH
     *
     * @param address balance owner
     * @param assetType type of asset. Supports ERC20 and ETH
     * @returns balance of user
     */
    getBalance(address: Address | EVMAddress, assetType: BalanceRequestAssetType): Promise<BigNumber>;
    /**
     * Transfer native token or ERC-20 to recipient
     * @param address Recipient of tokens
     * @param asset Object includes currency type and transfer value
     */
    transfer(address: Address | EVMAddress, asset: TransferBalanceAsset): Promise<EthereumTransaction>;
    /**
     * Convert ETH balance from/to the Wrapped Ether (ERC-20) token
     * @depreacted please use `deposit` or `withdraw`
     *
     * @param from ETH or ERC20 Wrapped Ether asset type
     * @param to ERC20 Wrapped Ether or ETH asset type
     * @param value Value to convert
     * @returns `EthereumTransaction`
     */
    convert(from: AssetType, to: AssetType, value: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * Adds balance to wrapped currency
     * Works for Polygon (Wrapped Matic) and Ethereum (Wrapped Eth)
     *
     * @param value - amount of tokens
     * @returns `EthereumTransaction`
     */
    deposit(value: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * Adds balance to wrapped currency
     * Works for Polygon (Wrapped Matic) and Ethereum (Wrapped Eth)
     *
     * @param valueInWei - amount of tokens in wei
     * @returns `EthereumTransaction`
     */
    depositWei(valueInWei: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * Withdraw wrapped balance to native currency
     * Works for Polygon (Wrapped matic) and Ethereum (Wrapped Eth)
     *
     * @param value - amount of tokens
     * @returns `EthereumTransaction`
     */
    withdraw(value: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * Withdraw wrapped balance to native currency
     * Works for Polygon (Wrapped matic) and Ethereum (Wrapped Eth)
     *
     * @param valueInWei - amount of tokens in wei
     * @returns `EthereumTransaction`
     */
    withdrawWei(valueInWei: BigNumberValue): Promise<EthereumTransaction>;
    /**
     * @returns address of Wrapped currency (ERC-20)
     * Works for polygon (wrapped Matic) and ethereum (wrapped Eth)
     */
    getWethContractAddress(): Promise<Address>;
}
export interface RaribleAuctionSdk {
    /**
     * Start new auction
     * @param request start auction request
     */
    start: AuctionStartAction;
    /**
     * Cancel started auction
     * @param hash Auction hash
     */
    cancel(hash: string): Promise<EthereumTransaction>;
    /**
     * Finish auction with at least one bid
     * @param hash Auction hash
     */
    finish(hash: string): Promise<EthereumTransaction>;
    /**
     * Put bid
     * @param request Put bid request
     */
    putBid: PutAuctionBidAction;
    /**
     * Buy out auction if it possible
     * @param request Buy out request
     */
    buyOut: BuyoutAuctionAction;
    /**
     * Generate hash of auction by id
     * @param auctionId Auction ID
     */
    getHash: (auctionId: string) => Promise<string>;
}
export interface RaribleSdk {
    order: RaribleOrderSdk;
    nft: RaribleNftSdk;
    auction: RaribleAuctionSdk;
    apis: RaribleEthereumApis;
    balances: RaribleBalancesSdk;
}
export declare function createRaribleSdk(ethereum: Maybe<Ethereum>, env: EthereumNetwork, sdkConfig?: IRaribleEthereumSdkConfig): RaribleSdk;
export { isErc1155v2Collection, isErc721v2Collection, isErc721v3Collection, isErc1155v1Collection, isErc721v1Collection, } from "./nft/mint";
export * from "./order/is-nft";
export * from "./common/get-ownership-id";
export * from "./common/parse-item-id";
export * from "./common/parse-ownership-id";
