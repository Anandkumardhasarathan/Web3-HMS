"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.burn = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const get_ownership_id_1 = require("../common/get-ownership-id");
const create_item_id_1 = require("../common/create-item-id");
const erc721_1 = require("./contracts/erc721");
const domain_1 = require("./contracts/domain");
const erc1155_1 = require("./contracts/erc1155");
function burn(ethereum, send, checkAssetType, getApis, request) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const checked = yield checkAssetType(request.assetType);
        const from = (0, types_1.toEVMAddress)(yield ethereum.getFrom());
        const apis = yield getApis();
        const ownership = yield apis.nftOwnership.getNftOwnershipByIdRaw({
            ownershipId: (0, get_ownership_id_1.getOwnershipId)(request.assetType.contract, (0, types_1.toBigNumber)(`${request.assetType.tokenId}`), from),
        });
        if (ownership.status === 200) {
            const lazyValueBn = (0, utils_1.toBn)(ownership.value.lazyValue);
            if (lazyValueBn.gt(0)) {
                if (!lazyValueBn.isEqualTo(ownership.value.value)) {
                    throw new Error("Unable to burn lazy minted item");
                }
                const creators = !request.creators || !request.creators.length ? [from] : (_a = request.creators) === null || _a === void 0 ? void 0 : _a.map(creator => creator.account);
                const signature = yield ethereum.personalSign(`I would like to burn my ${request.assetType.tokenId} item.`);
                if (!signature) {
                    throw new Error(`burn error: personal signature is empty (${signature})`);
                }
                return apis.nftItem.deleteLazyMintNftAsset({
                    itemId: (0, create_item_id_1.createItemId)(request.assetType.contract, (0, types_1.toBigNumber)(`${request.assetType.tokenId}`)),
                    burnLazyNftForm: {
                        creators,
                        signatures: [(0, types_1.toBinary)(signature)],
                    },
                });
            }
            switch (checked.assetClass) {
                case "ERC721": {
                    const erc721Contract = yield (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V2, checked.contract);
                    return send(erc721Contract.functionCall("burn", checked.tokenId));
                }
                case "ERC1155": {
                    if (request.amount) {
                        const erc1155Contract = yield (0, erc1155_1.getErc1155Contract)(ethereum, domain_1.ERC1155VersionEnum.ERC1155V1, checked.contract);
                        const owner = yield ethereum.getFrom();
                        return send(erc1155Contract.functionCall("burn", owner, checked.tokenId, request.amount));
                    }
                    throw new Error(`amount is ${request.amount}. Amount for burn ERC1155 is required`);
                }
                default:
                    throw new Error("Unexpected asset class");
            }
        }
        throw new Error("Ownership is not found");
    });
}
exports.burn = burn;
