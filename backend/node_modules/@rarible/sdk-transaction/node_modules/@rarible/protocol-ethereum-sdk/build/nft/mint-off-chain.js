"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestURI = exports.mintOffChain = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const sanitize_uri_1 = require("../common/sanitize-uri");
const common_1 = require("../common");
const get_token_id_1 = require("./get-token-id");
const mint_1 = require("./mint");
const mint_on_chain_1 = require("./mint-on-chain");
const erc721_1 = require("./contracts/erc721");
const domain_1 = require("./contracts/domain");
const erc1155_1 = require("./contracts/erc1155");
function mintOffChain(ethereum, signNft, nftCollectionApi, nftLazyMintApi, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, common_1.getBlockchainFromChainId)(yield ethereum.getChainId()) === "POLYGON") {
            throw new Error("Off-chain mint not supported for Polygon");
        }
        const creators = yield (0, mint_on_chain_1.getCreators)(data, ethereum);
        const { tokenId } = yield (0, get_token_id_1.getTokenId)(nftCollectionApi, data.collection.id, creators[0].account, data.nftTokenId);
        const mintData = getMintOffChainData(Object.assign(Object.assign({}, data), { uri: yield getRequestURI(ethereum, data) }), creators, tokenId);
        const minted = yield nftLazyMintApi.mintNftAsset({
            lazyNft: Object.assign({}, mintData, {
                tokenId,
                signatures: [yield signNft(mintData)],
            }),
        });
        return {
            type: mint_1.MintResponseTypeEnum.OFF_CHAIN,
            item: minted,
            owner: creators[0].account,
            tokenId,
            contract: minted.contract,
            itemId: `${minted.contract}:${tokenId}`,
        };
    });
}
exports.mintOffChain = mintOffChain;
function getMintOffChainData(data, creators, tokenId) {
    const base = {
        contract: data.collection.id,
        uri: data.uri,
        royalties: data.royalties || [],
        creators,
        tokenId,
    };
    if ("supply" in data) {
        return Object.assign({}, base, {
            "@type": "ERC1155",
            supply: (0, types_1.toBigNumber)(data.supply.toString()),
        });
    }
    return Object.assign({}, base, {
        "@type": "ERC721",
    });
}
function getRequestURI(ethereum, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (data.collection.type === "ERC721") {
            const erc721Contract = yield (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V3, data.collection.id);
            const uriPrefix = yield erc721Contract.functionCall("baseURI").call();
            return (0, sanitize_uri_1.sanitizeUri)(uriPrefix, data.uri);
        }
        else if (data.collection.type === "ERC1155") {
            const erc1155Contract = yield (0, erc1155_1.getErc1155Contract)(ethereum, domain_1.ERC1155VersionEnum.ERC1155V2, data.collection.id);
            const uriPrefix = yield erc1155Contract.functionCall("baseURI").call();
            return (0, sanitize_uri_1.sanitizeUri)(uriPrefix, data.uri);
        }
        throw new Error("Wrong collection type");
    });
}
exports.getRequestURI = getRequestURI;
