"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssetTransferProxy = exports.pureApproveFn = exports.approve = void 0;
const tslib_1 = require("tslib");
const approve_erc20_1 = require("./approve-erc20");
const approve_erc721_1 = require("./approve-erc721");
const approve_erc1155_1 = require("./approve-erc1155");
const approve_crypto_punk_1 = require("./approve-crypto-punk");
function approve(ethereum_1, send_1, getConfig_1, owner_1, asset_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, send, getConfig, owner, asset, infinite = true) {
        const config = yield getConfig();
        const operator = getAssetTransferProxy(asset.assetType.assetClass, config.transferProxies);
        if (!operator) {
            return undefined;
        }
        return pureApproveFn({ ethereum, send, operator, owner, asset, infinite });
    });
}
exports.approve = approve;
function pureApproveFn(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ ethereum, send, operator, owner, asset, infinite, }) {
        switch (asset.assetType.assetClass) {
            case "ERC20": {
                const contract = asset.assetType.contract;
                return (0, approve_erc20_1.approveErc20)(ethereum, send, contract, owner, operator, asset.value, infinite === undefined ? true : infinite);
            }
            case "ERC721": {
                const contract = asset.assetType.contract;
                return (0, approve_erc721_1.approveErc721)(ethereum, send, contract, owner, operator);
            }
            case "ERC1155": {
                const contract = asset.assetType.contract;
                return (0, approve_erc1155_1.approveErc1155)(ethereum, send, contract, owner, operator);
            }
            case "ERC721_LAZY":
                const contract = asset.assetType.contract;
                return (0, approve_erc721_1.approveErc721)(ethereum, send, contract, owner, operator);
            case "ERC1155_LAZY": {
                const contract = asset.assetType.contract;
                return (0, approve_erc1155_1.approveErc1155)(ethereum, send, contract, owner, operator);
            }
            case "CRYPTO_PUNKS": {
                const contract = asset.assetType.contract;
                return (0, approve_crypto_punk_1.approveCryptoPunk)(ethereum, send, contract, owner, operator, asset.assetType.tokenId);
            }
            default:
                return undefined;
        }
    });
}
exports.pureApproveFn = pureApproveFn;
function getAssetTransferProxy(assetClass, proxies) {
    switch (assetClass) {
        case "ERC20":
            return proxies.erc20;
        case "ERC721":
            return proxies.nft;
        case "ERC1155":
            return proxies.nft;
        case "ERC721_LAZY":
            return proxies.erc721Lazy;
        case "ERC1155_LAZY":
            return proxies.erc1155Lazy;
        case "CRYPTO_PUNKS":
            return proxies.cryptoPunks;
        default:
            return undefined;
    }
}
exports.getAssetTransferProxy = getAssetTransferProxy;
