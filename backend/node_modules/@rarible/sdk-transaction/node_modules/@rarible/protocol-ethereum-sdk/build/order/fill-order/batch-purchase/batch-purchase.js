"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBatchSupportedOrders = exports.BatchOrderFiller = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const check_asset_type_1 = require("../../check-asset-type");
const check_lazy_asset_type_1 = require("../../check-lazy-asset-type");
const rarible_v2_1 = require("../rarible-v2");
const open_sea_1 = require("../open-sea");
const seaport_1 = require("../seaport");
const looksrare_1 = require("../looksrare");
const origin_fee_reducer_1 = require("../common/origin-fee-reducer");
const x2y2_1 = require("../x2y2");
const amm_1 = require("../amm");
const exchange_wrapper_1 = require("../../contracts/exchange-wrapper");
const get_updated_call_1 = require("../common/get-updated-call");
const get_required_wallet_1 = require("../../../common/get-required-wallet");
const looksrare_v2_1 = require("../looksrare-v2");
const common_1 = require("../../../nft/common");
const approve_1 = require("../../approve");
class BatchOrderFiller {
    constructor(ethereum, send, getConfig, getApis, getBaseOrderFee, env, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getApis = getApis;
        this.getBaseOrderFee = getBaseOrderFee;
        this.env = env;
        this.sdkConfig = sdkConfig;
        /**
         * Buy batch of orders
         *
         * Note: Additional origin fees applied only for opensea orders
         */
        this.buy = this.getFillAction();
        this.v2Handler = new rarible_v2_1.RaribleV2OrderHandler(ethereum, send, getConfig, getBaseOrderFee);
        this.openSeaHandler = new open_sea_1.OpenSeaOrderHandler(ethereum, send, getConfig, getApis, getBaseOrderFee, sdkConfig);
        this.seaportHandler = new seaport_1.SeaportOrderHandler(ethereum, send, getConfig, getApis, getBaseOrderFee, env);
        this.looksrareHandler = new looksrare_1.LooksrareOrderHandler(ethereum, send, getConfig, getBaseOrderFee, env, getApis);
        this.looksrareV2Handler = new looksrare_v2_1.LooksrareV2OrderHandler(ethereum, send, getConfig, getBaseOrderFee, env, getApis);
        this.x2Y2Handler = new x2y2_1.X2Y2OrderHandler(ethereum, send, getConfig, getBaseOrderFee, getApis);
        this.ammHandler = new amm_1.AmmOrderHandler(ethereum, send, getConfig, getBaseOrderFee, getApis, env);
        this.checkAssetType = check_asset_type_1.checkAssetType.bind(this, getApis);
        this.checkLazyAssetType = check_lazy_asset_type_1.checkLazyAssetType.bind(this, getApis);
        this.getTransactionRequestData = this.getTransactionRequestData.bind(this);
    }
    getFillAction() {
        return action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.ethereum) {
                    throw new Error("Wallet undefined");
                }
                if (!request.length) {
                    throw new Error("Request is empty");
                }
                const originFeeReducer = new origin_fee_reducer_1.OriginFeeReducer();
                const preparedOrders = yield this.prepareOrders(request, originFeeReducer);
                return { preparedOrders, feeAddresses: originFeeReducer.getAddresses() };
            }),
        }).thenStep({
            id: "send-tx",
            run: (_a) => tslib_1.__awaiter(this, [_a], void 0, function* ({ preparedOrders, feeAddresses, }) {
                const { functionCall, options } = yield this.getTransactionRequestData(preparedOrders, feeAddresses);
                return this.send(functionCall, options);
            }),
        });
    }
    /**
     * Convert origin fees & invert and approve orders
     * @private
     */
    prepareOrders(requests, feesReducer) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const from = (0, types_1.toEVMAddress)(yield (0, get_required_wallet_1.getRequiredWallet)(this.ethereum).getFrom());
            const config = yield this.getConfig();
            const preparedOrders = yield Promise.all(requests.map((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!(0, common_1.isWeth)(request.order.take.assetType, config) && !(0, common_1.isETH)(request.order.take.assetType)) {
                    throw new Error("Batch purchase is available only for ETH/WETH currencies");
                }
                let approveAsset;
                validateBatchSupportedOrders(request.order);
                const feesData = feesReducer.getComplexReducedFeesData(request.originFees);
                let inverted = undefined;
                if (request.order.type === "RARIBLE_V2"
                // || request.order.type === "OPEN_SEA_V1"
                ) {
                    inverted = yield this.invertOrder(request, from);
                    if (request.assetType && inverted.make.assetType.assetClass === "COLLECTION") {
                        inverted.make.assetType = yield this.checkAssetType(request.assetType);
                        inverted.make.assetType = yield this.checkLazyAssetType(inverted.make.assetType);
                    }
                    approveAsset = yield this.getApproveAsset(request, feesData, inverted);
                }
                if (request.order.type === "SEAPORT_V1") {
                    approveAsset = yield this.getApproveAsset(request, feesData, inverted);
                }
                return {
                    request,
                    inverted,
                    fees: feesData.encodedFeesValue,
                    approveAsset,
                };
            })));
            const totalInfiniteApproval = requests.every(request => !!request.infinite);
            //group erc-20 assets for approving by order.type
            const approveAssetsByOrderType = groupAssetsByOrderType(preparedOrders);
            //sum erc-20 assets
            for (const [orderType, assets] of approveAssetsByOrderType) {
                const erc20Assets = groupErc20AssetsByContract(assets);
                for (const [, erc20Asset] of erc20Assets) {
                    //approve erc-20 tokens
                    yield this.approveErc20Asset(orderType, erc20Asset, totalInfiniteApproval);
                }
            }
            return preparedOrders;
        });
    }
    getApproveAsset(request, feesData, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (request.order.type) {
                case "RARIBLE_V2":
                    return this.v2Handler.getAssetToApprove(inverted);
                case "SEAPORT_V1":
                    return this.seaportHandler.getAssetToApprove(request, feesData);
                // case "OPEN_SEA_V1":
                // 	return this.openSeaHandler.getAssetToApprove(inverted)
                default:
                    throw new Error(`Unsupported order: ${request.order.type}`);
            }
        });
    }
    invertOrder(request, from) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (request.order.type) {
                case "RARIBLE_V2":
                    return this.v2Handler.invert(request, from);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.invert(request, from);
                default:
                    throw new Error(`Unsupported order: ${request.order.type}`);
            }
        });
    }
    approveErc20Asset(orderType, asset, isInfinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const wallet = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const approveInput = {
                ethereum: wallet,
                send: this.send,
                owner: (0, types_1.toEVMAddress)(yield wallet.getFrom()),
                asset,
                infinite: isInfinite,
            };
            const config = yield this.getConfig();
            switch (orderType) {
                case "RARIBLE_V2":
                    return (0, approve_1.pureApproveFn)(Object.assign(Object.assign({}, approveInput), { operator: config.transferProxies.erc20 }));
                case "SEAPORT_V1":
                    return (0, approve_1.pureApproveFn)(Object.assign(Object.assign({}, approveInput), { operator: config.exchange.wrapper }));
                default:
                    throw new Error(`Unsupported order: ${orderType}`);
            }
        });
    }
    /**
     * Prepare contract function call
     */
    getTransactionRequestData(preparedOrders, feeAddresses) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let totalValue = (0, utils_1.toBn)(0);
            const config = yield this.getConfig();
            const ordersCallData = yield Promise.all(preparedOrders.map((preparedOrder) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                const requestData = yield this.getOrderData(preparedOrder);
                totalValue = totalValue.plus(((_a = requestData.options) === null || _a === void 0 ? void 0 : _a.value) || 0);
                return requestData.data;
            })));
            const wrapperContract = (0, exchange_wrapper_1.createExchangeWrapperContract)(this.ethereum, config.exchange.wrapper);
            const functionCall = wrapperContract.functionCall("bulkPurchase", ordersCallData, feeAddresses[0], feeAddresses[1], true);
            let gasLimit = yield wrapperContract
                .functionCall("bulkPurchase", ordersCallData, feeAddresses[0], feeAddresses[1], false)
                .estimateGas({
                value: totalValue.toFixed(),
                from: yield (0, get_required_wallet_1.getRequiredWallet)(this.ethereum).getFrom(),
            });
            const gasLimitWithTheshold = (0, utils_1.toBn)(gasLimit).multipliedBy(1.1).integerValue(utils_1.BigNumber.ROUND_FLOOR).toNumber();
            return {
                functionCall,
                options: {
                    value: totalValue.toFixed(),
                    gas: gasLimitWithTheshold,
                    additionalData: (0, get_updated_call_1.getUpdatedCalldata)(this.sdkConfig),
                },
            };
        });
    }
    getOrderData(preparedOrder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (preparedOrder.request.order.type) {
                case "RARIBLE_V2":
                    return this.v2Handler.getTransactionDataForExchangeWrapper(preparedOrder.request.order, preparedOrder.inverted);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.getTransactionDataForExchangeWrapper(preparedOrder.request.order, preparedOrder.inverted, preparedOrder.request.originFees, preparedOrder.fees);
                case "SEAPORT_V1":
                    return this.seaportHandler.getTransactionDataForExchangeWrapper(preparedOrder.request, preparedOrder.request.originFees, preparedOrder.fees);
                case "LOOKSRARE":
                    return this.looksrareHandler.getTransactionDataForExchangeWrapper(preparedOrder.request, preparedOrder.request.originFees, preparedOrder.fees);
                case "LOOKSRARE_V2":
                    return this.looksrareV2Handler.getTransactionDataForExchangeWrapper(preparedOrder.request, preparedOrder.request.originFees, preparedOrder.fees);
                case "X2Y2":
                    return this.x2Y2Handler.getTransactionDataForExchangeWrapper(preparedOrder.request, preparedOrder.request.originFees, preparedOrder.fees);
                case "AMM":
                    return this.ammHandler.getTransactionDataForExchangeWrapper(preparedOrder.request, preparedOrder.fees);
                default:
                    //@ts-ignore
                    throw new Error(`Unsupported request type: ${preparedOrder.request.order.type}`);
            }
        });
    }
}
exports.BatchOrderFiller = BatchOrderFiller;
function groupAssetsByOrderType(preparedOrders) {
    return preparedOrders.reduce((acc, { approveAsset, request }) => {
        if (approveAsset) {
            if (acc.has(request.order.type)) {
                const oldArray = acc.get(request.order.type) || [];
                oldArray.push(approveAsset);
            }
            else {
                acc.set(request.order.type, [approveAsset]);
            }
        }
        return acc;
    }, new Map());
}
function groupErc20AssetsByContract(assets) {
    return assets.reduce((acc, asset) => {
        if ((0, common_1.isErc20)(asset.assetType)) {
            const sumAsset = acc.get(asset.assetType.contract);
            if (sumAsset) {
                acc.set(asset.assetType.contract, Object.assign(Object.assign({}, sumAsset), { value: (0, types_1.toBigNumber)((0, utils_1.toBn)(sumAsset.value).plus(asset.value).toFixed()) }));
            }
            else {
                acc.set(asset.assetType.contract, asset);
            }
        }
        return acc;
    }, new Map());
}
function validateBatchSupportedOrders(order) {
    if (order.type !== "RARIBLE_V2" &&
        order.type !== "OPEN_SEA_V1" &&
        order.type !== "LOOKSRARE" &&
        order.type !== "LOOKSRARE_V2" &&
        order.type !== "SEAPORT_V1" &&
        order.type !== "X2Y2" &&
        order.type !== "AMM") {
        throw new Error("Unsupported order type for batch purchase");
    }
}
exports.validateBatchSupportedOrders = validateBatchSupportedOrders;
