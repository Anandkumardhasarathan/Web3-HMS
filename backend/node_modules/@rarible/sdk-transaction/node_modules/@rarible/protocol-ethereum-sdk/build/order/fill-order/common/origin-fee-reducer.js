"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OriginFeeReducer = void 0;
const types_1 = require("@rarible/types");
const origin_fees_utils_1 = require("./origin-fees-utils");
/**
 * Class used to reduce multiple originFee Part records (from different fill requests) to 2 values.
 */
class OriginFeeReducer {
    constructor() {
        this.addresses = [types_1.EVM_ZERO_ADDRESS, types_1.EVM_ZERO_ADDRESS];
    }
    /**
     * Reduce fees to converted single uint fee value
     * @param originFees
     */
    reduce(originFees) {
        if (!(originFees === null || originFees === void 0 ? void 0 : originFees.length)) {
            return origin_fees_utils_1.ZERO_FEE_VALUE;
        }
        const reducedArray = this.getReducedFeesArray(originFees);
        return (0, origin_fees_utils_1.packFeesToUint)(reducedArray);
    }
    getReducedFeesArray(originFees) {
        if (!(originFees === null || originFees === void 0 ? void 0 : originFees.length)) {
            return [0, 0];
        }
        if (originFees.length > 2) {
            throw new Error("Supports max up to 2 different origin fee address per request");
        }
        return originFees.reduce((acc, originFee) => {
            const res = this.reducePart(originFee);
            acc[0] += res[0];
            acc[1] += res[1];
            return acc;
        }, [0, 0]);
    }
    getComplexReducedFeesData(originFees) {
        const reducedArray = this.getReducedFeesArray(originFees);
        return {
            encodedFeesValue: (0, origin_fees_utils_1.packFeesToUint)(reducedArray),
            totalFeeBasisPoints: reducedArray[0] + reducedArray[1],
        };
    }
    /**
     * Return addresses for fees
     */
    getAddresses() {
        return this.addresses;
    }
    reducePart(part) {
        let firstFee = 0;
        let secondFee = 0;
        if (part.account === this.addresses[0]) {
            firstFee += part.value;
        }
        else if (part.account === this.addresses[1]) {
            secondFee += part.value;
        }
        else if (this.addresses[0] === types_1.EVM_ZERO_ADDRESS) {
            firstFee += part.value;
            this.addresses[0] = part.account;
        }
        else if (this.addresses[1] === types_1.EVM_ZERO_ADDRESS) {
            secondFee += part.value;
            this.addresses[1] = part.account;
        }
        else {
            throw new Error("Supports max up to 2 different origin fee address per request");
        }
        return [firstFee, secondFee];
    }
}
exports.OriginFeeReducer = OriginFeeReducer;
