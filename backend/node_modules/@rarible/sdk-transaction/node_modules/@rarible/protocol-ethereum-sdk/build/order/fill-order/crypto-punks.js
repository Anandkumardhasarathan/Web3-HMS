"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPunksOrderHandler = void 0;
const tslib_1 = require("tslib");
const get_asset_with_fee_1 = require("../get-asset-with-fee");
const approve_1 = require("../approve");
const wait_tx_1 = require("../../common/wait-tx");
const cryptoPunks_1 = require("../../nft/contracts/cryptoPunks");
const invert_order_1 = require("./invert-order");
class CryptoPunksOrderHandler {
    constructor(ethereum, send, getConfig, getBaseOrderFeeConfig, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.sdkConfig = sdkConfig;
    }
    invert(request, maker) {
        const inverted = (0, invert_order_1.invertOrder)(request.order, request.amount, maker);
        inverted.data = {
            dataType: "CRYPTO_PUNKS_DATA",
        };
        return inverted;
    }
    approve(order, infinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const withFee = this.getMakeAssetWithFee(order);
            yield (0, wait_tx_1.waitTx)((0, approve_1.approve)(this.ethereum, this.send, () => this.getConfig(), order.maker, withFee, infinite));
        });
    }
    getTransactionData(initial, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                functionCall: this.getPunkOrderCallMethod(initial),
                options: this.getMatchV2Options(initial, inverted),
            };
        });
    }
    getPunkOrderCallMethod(initial) {
        if (!this.ethereum) {
            throw new Error("Wallet undefined");
        }
        if (initial.make.assetType.assetClass === "CRYPTO_PUNKS") {
            // Call "buyPunk" if makeAsset=cryptoPunk
            const contract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(this.ethereum, initial.make.assetType.contract);
            return contract.functionCall("buyPunk", initial.make.assetType.tokenId);
        }
        else if (initial.take.assetType.assetClass === "CRYPTO_PUNKS") {
            // Call "acceptBid" if takeAsset=cryptoPunk
            const contract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(this.ethereum, initial.take.assetType.contract);
            return contract.functionCall("acceptBidForPunk", initial.take.assetType.tokenId, initial.make.value);
        }
        else {
            throw new Error("Unsupported punk asset type");
        }
    }
    getMatchV2Options(left, right) {
        if (right.make.assetType.assetClass === "ETH") {
            const asset = this.getMakeAssetWithFee(right);
            return { value: asset.value };
        }
        else {
            return {};
        }
    }
    getMakeAssetWithFee(order) {
        return (0, get_asset_with_fee_1.getAssetWithFee)(order.make, this.getOrderFee());
    }
    getOrderFee() {
        return 0;
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("CRYPTO_PUNK");
    }
}
exports.CryptoPunksOrderHandler = CryptoPunksOrderHandler;
