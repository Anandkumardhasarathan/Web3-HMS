"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invertOrder = void 0;
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const is_nft_1 = require("../is-nft");
const ZERO = (0, types_1.toWord)("0x0000000000000000000000000000000000000000000000000000000000000000");
function invertOrder(order, amount, maker, salt = ZERO) {
    const isBid = (0, is_nft_1.isNft)(order.take.assetType) || order.take.assetType.assetClass === "COLLECTION";
    const [makeValue, takeValue] = calculateAmounts((0, utils_1.toBn)(order.make.value), (0, utils_1.toBn)(order.take.value), amount, isBid);
    checkValue(isBid ? takeValue : makeValue);
    return Object.assign(Object.assign({}, order), { make: Object.assign(Object.assign({}, order.take), { value: (0, types_1.toBigNumber)(makeValue.toString()) }), take: Object.assign(Object.assign({}, order.make), { value: (0, types_1.toBigNumber)(takeValue.toString()) }), maker, taker: order.maker, salt, signature: undefined });
}
exports.invertOrder = invertOrder;
function calculateAmounts(make, take, amount, bid) {
    if (bid) {
        return [amount, (0, utils_1.toBn)(amount).multipliedBy(make).div(take)];
    }
    else {
        return [(0, utils_1.toBn)(amount).multipliedBy(take).div(make), amount];
    }
}
function checkValue(value) {
    const floatValue = parseFloat(value.toString());
    if (floatValue < 1 && floatValue > 0) {
        throw new Error("Invalid order. Price per one item is less than minimum allowable currency amount.");
    }
}
