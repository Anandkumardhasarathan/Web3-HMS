"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderValidatorCode = exports.getTakerParamsTypes = exports.CollectionType = exports.StrategyType = exports.QuoteType = exports.LooksrareV2OrderHandler = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const types_2 = require("@rarible/types");
const types_3 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const OrderData_1 = require("@rarible/ethereum-api-client/build/models/OrderData");
const looksrare_v2_1 = require("../contracts/looksrare-v2");
const get_required_wallet_1 = require("../../common/get-required-wallet");
const exchange_wrapper_1 = require("../contracts/exchange-wrapper");
const is_nft_1 = require("../is-nft");
const looksrare_v2_validator_1 = require("../contracts/looksrare-v2-validator");
const types_4 = require("./types");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
const get_market_data_1 = require("./common/get-market-data");
class LooksrareV2OrderHandler {
    constructor(ethereum, send, getConfig, getBaseOrderFeeConfig, env, getApis) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.env = env;
        this.getApis = getApis;
    }
    convertMakerOrderToLooksrare(makerOrder, amount) {
        const { take, make } = makerOrder;
        if ((0, utils_1.toBn)(amount).gt(make.value)) {
            throw new Error(`Amount should be less or equal to ${make.value.toString()}`);
        }
        let contract;
        let tokenId;
        if ((0, is_nft_1.isNft)(make.assetType)) {
            contract = make.assetType.contract;
            tokenId = make.assetType.tokenId.toString();
        }
        else {
            throw new Error(`Only sell orders are supported. Make=${make.assetType.assetClass} is not NFT`);
        }
        let currency;
        if (take.assetType.assetClass === "ETH") {
            currency = types_2.EVM_ZERO_ADDRESS;
        }
        else if (take.assetType.assetClass === "ERC20") {
            currency = take.assetType.contract;
        }
        else {
            throw new Error("Take asset should be ETH or ERC-20 contract");
        }
        if (!makerOrder.signature) {
            throw new Error("Signature is null");
        }
        return {
            quoteType: getQuoteType(makerOrder.data.quoteType),
            globalNonce: makerOrder.data.globalNonce,
            subsetNonce: makerOrder.data.subsetNonce,
            orderNonce: makerOrder.data.orderNonce,
            collection: contract,
            currency: currency,
            signer: makerOrder.maker,
            strategyId: makerOrder.data.strategyId,
            collectionType: getCollectionType(makerOrder.make.assetType),
            startTime: makerOrder.start || 0,
            endTime: makerOrder.end || 0,
            price: take.value,
            additionalParameters: fixOddLengthData(makerOrder.data.additionalParameters),
            amounts: [amount.toString()],
            itemIds: [tokenId],
        };
    }
    prepareTransaction(request, originFees) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const wallet = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const config = yield this.getConfig();
            if (!config.exchange.looksrareV2) {
                throw new Error("Looksrare V2 contract does not exist");
            }
            if (originFees && originFees.length > 1) {
                throw new Error("Origin fees recipients shouldn't be greater than 1");
            }
            const contract = (0, looksrare_v2_1.createLooksrareV2Exchange)(wallet, config.exchange.looksrareV2);
            const order = this.convertMakerOrderToLooksrare(request.order, request.amount);
            const method = order.quoteType === QuoteType.Ask ? "executeTakerBid" : "executeTakerAsk";
            if (!config.looksrareOrderValidatorV2) {
                throw new Error("Looksrare order validator V2 does not exist");
            }
            const validator = (0, looksrare_v2_validator_1.createLooksrareV2Validator)(wallet, config.looksrareOrderValidatorV2);
            const merkleRoot = request.order.data.merkleRoot
                ? { root: request.order.data.merkleRoot, proof: request.order.data.merkleProof }
                : { root: "0x0000000000000000000000000000000000000000000000000000000000000000", proof: [] };
            const validity = yield validator
                .functionCall("checkMakerOrderValidity", order, request.order.signature, merkleRoot)
                .call();
            const errorCodes = validity.filter((num) => !!+num).map((num) => OrderValidatorCode[+num]);
            if (errorCodes.length) {
                throw new Error(`Order validation errors: ${errorCodes.join(", ")}`);
            }
            const functionCall = contract.functionCall(method, 
            //takerAsk
            {
                recipient: yield wallet.getFrom(),
                additionalParameters: "0x",
            }, 
            //makerBid
            order, request.order.signature, 
            //merkleTree,
            merkleRoot, (originFees === null || originFees === void 0 ? void 0 : originFees.length) && originFees[0] ? (_a = originFees[0]) === null || _a === void 0 ? void 0 : _a.account : types_2.EVM_ZERO_ADDRESS);
            return {
                functionCall,
                rawOrder: order,
            };
        });
    }
    getTransactionDataForExchangeWrapper(request, originFees, encodedFeesValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.prepareTransactionData(request, originFees, encodedFeesValue)).requestData;
        });
    }
    getTransactionData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { requestData, feeAddresses } = yield this.prepareTransactionData(request, request.originFees, undefined);
            const provider = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const config = yield this.getConfig();
            const wrapperContract = (0, exchange_wrapper_1.createExchangeWrapperContract)(provider, config.exchange.wrapper);
            const functionCall = wrapperContract.functionCall("singlePurchase", requestData.data, feeAddresses[0], feeAddresses[1]);
            return {
                functionCall,
                options: {
                    value: requestData.options.value.toString(),
                },
            };
        });
    }
    prepareTransactionData(request, originFees, encodedFeesValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { functionCall, rawOrder } = yield this.prepareTransaction(request, originFees);
            const price = rawOrder.price.toString();
            const { totalFeeBasisPoints, encodedFeesValue: localEncodedFee, feeAddresses } = (0, origin_fees_utils_1.originFeeValueConvert)(originFees);
            let valueWithOriginFees = (0, origin_fees_utils_1.calcValueWithFees)((0, types_3.toBigNumber)(price), totalFeeBasisPoints);
            const feeEncodedValue = encodedFeesValue !== null && encodedFeesValue !== void 0 ? encodedFeesValue : localEncodedFee;
            const data = {
                marketId: types_4.ExchangeWrapperOrderType.LOOKSRARE_V2_ORDERS,
                amount: price,
                fees: feeEncodedValue,
                data: yield functionCall.getData(),
            };
            if (request.addRoyalty) {
                let royaltyList = [];
                for (const itemId of rawOrder.itemIds) {
                    const apis = yield this.getApis();
                    const royalty = (yield apis.nftItem.getNftItemRoyaltyById({
                        itemId: `${rawOrder.collection}:${itemId}`,
                    })).royalty;
                    if (royalty === null || royalty === void 0 ? void 0 : royalty.length) {
                        royaltyList = royaltyList.concat(royalty);
                    }
                }
                if (royaltyList === null || royaltyList === void 0 ? void 0 : royaltyList.length) {
                    data.data = (0, get_market_data_1.encodeDataWithRoyalties)({
                        royalties: royaltyList,
                        data: yield functionCall.getData(),
                        provider: (0, get_required_wallet_1.getRequiredWallet)(this.ethereum),
                    });
                    const royaltiesAmount = (0, get_market_data_1.getRoyaltiesAmount)(royaltyList, price !== null && price !== void 0 ? price : 0);
                    valueWithOriginFees = (0, utils_1.toBn)(valueWithOriginFees.plus(royaltiesAmount).toString());
                    data.fees = (0, get_market_data_1.addFeeDependsOnExternalFee)(request.originFees, encodedFeesValue);
                }
            }
            return {
                requestData: {
                    data: data,
                    options: { value: valueWithOriginFees.toString() },
                },
                feeAddresses,
            };
        });
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("LOOKSRARE");
    }
}
exports.LooksrareV2OrderHandler = LooksrareV2OrderHandler;
var QuoteType;
(function (QuoteType) {
    QuoteType[QuoteType["Bid"] = 0] = "Bid";
    QuoteType[QuoteType["Ask"] = 1] = "Ask";
})(QuoteType || (exports.QuoteType = QuoteType = {}));
var StrategyType;
(function (StrategyType) {
    StrategyType[StrategyType["standard"] = 0] = "standard";
    StrategyType[StrategyType["collection"] = 1] = "collection";
    StrategyType[StrategyType["collectionWithMerkleTree"] = 2] = "collectionWithMerkleTree";
})(StrategyType || (exports.StrategyType = StrategyType = {}));
var CollectionType;
(function (CollectionType) {
    CollectionType[CollectionType["ERC721"] = 0] = "ERC721";
    CollectionType[CollectionType["ERC1155"] = 1] = "ERC1155";
})(CollectionType || (exports.CollectionType = CollectionType = {}));
const getTakerParamsTypes = (strategy) => {
    if (strategy === StrategyType.standard) {
        return [];
    }
    if (strategy === StrategyType.collection) {
        return ["uint256"]; // Item id
    }
    if (strategy === StrategyType.collectionWithMerkleTree) {
        return ["uint256", "bytes32[]"]; // Item id, merkle proof
    }
    return [];
};
exports.getTakerParamsTypes = getTakerParamsTypes;
function getQuoteType(quoteType) {
    if (quoteType === OrderData_1.OrderLooksRareDataV2QuoteType.BID) {
        return QuoteType.Bid;
    }
    else if (quoteType === OrderData_1.OrderLooksRareDataV2QuoteType.ASK) {
        return QuoteType.Ask;
    }
    else {
        throw new Error(`Unexpected QuoteType=${quoteType}`);
    }
}
function getCollectionType(asset) {
    if (asset.assetClass === "ERC721") {
        return CollectionType.ERC721;
    }
    else if (asset.assetClass === "ERC1155") {
        return CollectionType.ERC1155;
    }
    else {
        throw new Error(`Wrong collection type: ${asset.assetClass}, expected ERC721 or ERC1155`);
    }
}
function fixOddLengthData(input) {
    let hexString = input;
    if (hexString.startsWith("0x")) {
        hexString = hexString.slice(2);
    }
    if (hexString.length % 2 !== 0) {
        hexString = "0" + hexString;
    }
    return (0, types_1.toBinary)(`0x${hexString}`);
}
var OrderValidatorCode;
(function (OrderValidatorCode) {
    // 0. No error
    OrderValidatorCode[OrderValidatorCode["ORDER_EXPECTED_TO_BE_VALID"] = 0] = "ORDER_EXPECTED_TO_BE_VALID";
    // 1. Strategy & currency-related errors
    OrderValidatorCode[OrderValidatorCode["CURRENCY_NOT_ALLOWED"] = 101] = "CURRENCY_NOT_ALLOWED";
    OrderValidatorCode[OrderValidatorCode["STRATEGY_NOT_IMPLEMENTED"] = 111] = "STRATEGY_NOT_IMPLEMENTED";
    OrderValidatorCode[OrderValidatorCode["STRATEGY_INVALID_QUOTE_TYPE"] = 112] = "STRATEGY_INVALID_QUOTE_TYPE";
    OrderValidatorCode[OrderValidatorCode["STRATEGY_NOT_ACTIVE"] = 113] = "STRATEGY_NOT_ACTIVE";
    // 2. Maker order struct-related errors
    OrderValidatorCode[OrderValidatorCode["MAKER_ORDER_INVALID_STANDARD_SALE"] = 201] = "MAKER_ORDER_INVALID_STANDARD_SALE";
    OrderValidatorCode[OrderValidatorCode["MAKER_ORDER_PERMANENTLY_INVALID_NON_STANDARD_SALE"] = 211] = "MAKER_ORDER_PERMANENTLY_INVALID_NON_STANDARD_SALE";
    OrderValidatorCode[OrderValidatorCode["MAKER_ORDER_INVALID_CURRENCY_NON_STANDARD_SALE"] = 212] = "MAKER_ORDER_INVALID_CURRENCY_NON_STANDARD_SALE";
    OrderValidatorCode[OrderValidatorCode["MAKER_ORDER_TEMPORARILY_INVALID_NON_STANDARD_SALE"] = 213] = "MAKER_ORDER_TEMPORARILY_INVALID_NON_STANDARD_SALE";
    // 3. Nonce-related errors
    OrderValidatorCode[OrderValidatorCode["USER_SUBSET_NONCE_CANCELLED"] = 301] = "USER_SUBSET_NONCE_CANCELLED";
    OrderValidatorCode[OrderValidatorCode["USER_ORDER_NONCE_EXECUTED_OR_CANCELLED"] = 311] = "USER_ORDER_NONCE_EXECUTED_OR_CANCELLED";
    OrderValidatorCode[OrderValidatorCode["USER_ORDER_NONCE_IN_EXECUTION_WITH_OTHER_HASH"] = 312] = "USER_ORDER_NONCE_IN_EXECUTION_WITH_OTHER_HASH";
    OrderValidatorCode[OrderValidatorCode["INVALID_USER_GLOBAL_BID_NONCE"] = 321] = "INVALID_USER_GLOBAL_BID_NONCE";
    OrderValidatorCode[OrderValidatorCode["INVALID_USER_GLOBAL_ASK_NONCE"] = 322] = "INVALID_USER_GLOBAL_ASK_NONCE";
    // 4. errors related to signatures (EOA, EIP-1271) and merkle tree computations
    OrderValidatorCode[OrderValidatorCode["ORDER_HASH_PROOF_NOT_IN_MERKLE_TREE"] = 401] = "ORDER_HASH_PROOF_NOT_IN_MERKLE_TREE";
    OrderValidatorCode[OrderValidatorCode["MERKLE_PROOF_PROOF_TOO_LARGE"] = 402] = "MERKLE_PROOF_PROOF_TOO_LARGE";
    OrderValidatorCode[OrderValidatorCode["INVALID_SIGNATURE_LENGTH"] = 411] = "INVALID_SIGNATURE_LENGTH";
    OrderValidatorCode[OrderValidatorCode["INVALID_S_PARAMETER_EOA"] = 412] = "INVALID_S_PARAMETER_EOA";
    OrderValidatorCode[OrderValidatorCode["INVALID_V_PARAMETER_EOA"] = 413] = "INVALID_V_PARAMETER_EOA";
    OrderValidatorCode[OrderValidatorCode["NULL_SIGNER_EOA"] = 414] = "NULL_SIGNER_EOA";
    OrderValidatorCode[OrderValidatorCode["INVALID_SIGNER_EOA"] = 415] = "INVALID_SIGNER_EOA";
    OrderValidatorCode[OrderValidatorCode["MISSING_IS_VALID_SIGNATURE_FUNCTION_EIP1271"] = 421] = "MISSING_IS_VALID_SIGNATURE_FUNCTION_EIP1271";
    OrderValidatorCode[OrderValidatorCode["SIGNATURE_INVALID_EIP1271"] = 422] = "SIGNATURE_INVALID_EIP1271";
    // 5. Timestamp-related errors
    OrderValidatorCode[OrderValidatorCode["START_TIME_GREATER_THAN_END_TIME"] = 501] = "START_TIME_GREATER_THAN_END_TIME";
    OrderValidatorCode[OrderValidatorCode["TOO_LATE_TO_EXECUTE_ORDER"] = 502] = "TOO_LATE_TO_EXECUTE_ORDER";
    OrderValidatorCode[OrderValidatorCode["TOO_EARLY_TO_EXECUTE_ORDER"] = 503] = "TOO_EARLY_TO_EXECUTE_ORDER";
    // 6. Transfer-related (ERC20, ERC721, ERC1155 tokens), including transfers and approvals, errors.
    OrderValidatorCode[OrderValidatorCode["SAME_ITEM_ID_IN_BUNDLE"] = 601] = "SAME_ITEM_ID_IN_BUNDLE";
    OrderValidatorCode[OrderValidatorCode["ERC20_BALANCE_INFERIOR_TO_PRICE"] = 611] = "ERC20_BALANCE_INFERIOR_TO_PRICE";
    OrderValidatorCode[OrderValidatorCode["ERC20_APPROVAL_INFERIOR_TO_PRICE"] = 612] = "ERC20_APPROVAL_INFERIOR_TO_PRICE";
    OrderValidatorCode[OrderValidatorCode["ERC721_ITEM_ID_DOES_NOT_EXIST"] = 621] = "ERC721_ITEM_ID_DOES_NOT_EXIST";
    OrderValidatorCode[OrderValidatorCode["ERC721_ITEM_ID_NOT_IN_BALANCE"] = 622] = "ERC721_ITEM_ID_NOT_IN_BALANCE";
    OrderValidatorCode[OrderValidatorCode["ERC721_NO_APPROVAL_FOR_ALL_OR_ITEM_ID"] = 623] = "ERC721_NO_APPROVAL_FOR_ALL_OR_ITEM_ID";
    OrderValidatorCode[OrderValidatorCode["ERC1155_BALANCE_OF_DOES_NOT_EXIST"] = 631] = "ERC1155_BALANCE_OF_DOES_NOT_EXIST";
    OrderValidatorCode[OrderValidatorCode["ERC1155_BALANCE_OF_ITEM_ID_INFERIOR_TO_AMOUNT"] = 632] = "ERC1155_BALANCE_OF_ITEM_ID_INFERIOR_TO_AMOUNT";
    OrderValidatorCode[OrderValidatorCode["ERC1155_IS_APPROVED_FOR_ALL_DOES_NOT_EXIST"] = 633] = "ERC1155_IS_APPROVED_FOR_ALL_DOES_NOT_EXIST";
    OrderValidatorCode[OrderValidatorCode["ERC1155_NO_APPROVAL_FOR_ALL"] = 634] = "ERC1155_NO_APPROVAL_FOR_ALL";
    // 7. Asset-type errors
    OrderValidatorCode[OrderValidatorCode["POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC721"] = 701] = "POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC721";
    OrderValidatorCode[OrderValidatorCode["POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC1155"] = 702] = "POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC1155";
    // 8. Transfer manager-related errors
    OrderValidatorCode[OrderValidatorCode["NO_TRANSFER_MANAGER_APPROVAL_BY_USER_FOR_EXCHANGE"] = 801] = "NO_TRANSFER_MANAGER_APPROVAL_BY_USER_FOR_EXCHANGE";
    OrderValidatorCode[OrderValidatorCode["TRANSFER_MANAGER_APPROVAL_REVOKED_BY_OWNER_FOR_EXCHANGE"] = 802] = "TRANSFER_MANAGER_APPROVAL_REVOKED_BY_OWNER_FOR_EXCHANGE";
    // 9. Creator fee-related errors
    OrderValidatorCode[OrderValidatorCode["BUNDLE_ERC2981_NOT_SUPPORTED"] = 901] = "BUNDLE_ERC2981_NOT_SUPPORTED";
    OrderValidatorCode[OrderValidatorCode["CREATOR_FEE_TOO_HIGH"] = 902] = "CREATOR_FEE_TOO_HIGH";
})(OrderValidatorCode || (exports.OrderValidatorCode = OrderValidatorCode = {}));
