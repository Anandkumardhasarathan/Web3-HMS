"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeLooksRareData = exports.LooksrareOrderHandler = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const types_2 = require("@rarible/types");
const get_required_wallet_1 = require("../../common/get-required-wallet");
const to_vrs_1 = require("../../common/to-vrs");
const exchange_wrapper_1 = require("../contracts/exchange-wrapper");
const id_1 = require("../../common/id");
const is_nft_1 = require("../is-nft");
const types_3 = require("./types");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
const get_market_data_1 = require("./common/get-market-data");
class LooksrareOrderHandler {
    constructor(ethereum, send, getConfig, getBaseOrderFeeConfig, env, getApis, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.env = env;
        this.getApis = getApis;
        this.sdkConfig = sdkConfig;
    }
    convertMakerOrderToLooksrare(makerOrder, amount) {
        const { take, make } = makerOrder;
        if ((0, utils_1.toBn)(amount).gt(make.value)) {
            throw new Error(`Amount should be less or equal to ${make.value.toString()}`);
        }
        let isOrderAsk;
        let contract;
        let tokenId;
        if ((0, is_nft_1.isNft)(make.assetType)) {
            isOrderAsk = true;
            contract = make.assetType.contract;
            tokenId = make.assetType.tokenId.toString();
        }
        else {
            throw new Error(`Only sell orders are supported. Make=${make.assetType.assetClass} is not NFT`);
        }
        let currency;
        if (take.assetType.assetClass === "ETH") {
            currency = types_1.EVM_ZERO_ADDRESS;
        }
        else if (take.assetType.assetClass === "ERC20") {
            currency = take.assetType.contract;
        }
        else {
            throw new Error("Take asset should be ETH or ERC-20 contract");
        }
        if (!makerOrder.signature) {
            throw new Error("Signature is null");
        }
        const vrs = (0, to_vrs_1.toVrs)(makerOrder.signature || "0x");
        return Object.assign({ isOrderAsk, signer: makerOrder.maker, collection: contract, price: take.value, tokenId: tokenId, amount, strategy: makerOrder.data.strategy, currency, nonce: makerOrder.data.nonce, startTime: makerOrder.start || 0, endTime: makerOrder.end || 0, minPercentageToAsk: makerOrder.data.minPercentageToAsk, params: makerOrder.data.params || "0x" }, vrs);
    }
    getFulfillWrapperData(makerOrder, takerOrderData, assetClass) {
        const provider = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
        const typeNft = (0, id_1.id32)(assetClass).substring(0, 10);
        return encodeLooksRareData(provider, makerOrder, takerOrderData, typeNft);
    }
    prepareTransactionData(request, originFees, encodedFeesValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            if (request.originFees && request.originFees.length > 2) {
                throw new Error("Origin fees recipients shouldn't be greater than 2");
            }
            const makerOrder = this.convertMakerOrderToLooksrare(request.order, request.amount);
            const config = yield this.getConfig();
            makerOrder.currency = config.weth;
            const takerOrder = {
                isOrderAsk: false,
                taker: config.exchange.wrapper,
                price: makerOrder.price,
                tokenId: makerOrder.tokenId,
                minPercentageToAsk: makerOrder.minPercentageToAsk,
                params: makerOrder.params,
            };
            const fulfillData = this.getFulfillWrapperData(makerOrder, takerOrder, request.order.make.assetType.assetClass);
            const { totalFeeBasisPoints, encodedFeesValue: localEncodedFee, feeAddresses } = (0, origin_fees_utils_1.originFeeValueConvert)(originFees);
            let valueWithOriginFees = (0, origin_fees_utils_1.calcValueWithFees)((0, types_2.toBigNumber)(makerOrder.price.toString()), totalFeeBasisPoints);
            const feeEncodedValue = encodedFeesValue !== null && encodedFeesValue !== void 0 ? encodedFeesValue : localEncodedFee;
            const data = {
                marketId: types_3.ExchangeWrapperOrderType.LOOKSRARE_ORDERS,
                amount: makerOrder.price.toString(),
                fees: feeEncodedValue,
                data: fulfillData,
            };
            if (request.addRoyalty) {
                const apis = yield this.getApis();
                const royalties = (yield apis.nftItem.getNftItemRoyaltyById({
                    itemId: `${makerOrder.collection}:${makerOrder.tokenId}`,
                })).royalty;
                if (royalties === null || royalties === void 0 ? void 0 : royalties.length) {
                    data.data = (0, get_market_data_1.encodeDataWithRoyalties)({
                        royalties,
                        data: fulfillData,
                        provider: this.ethereum,
                    });
                    const royaltiesAmount = (0, get_market_data_1.getRoyaltiesAmount)(royalties, (_a = makerOrder.price.toString()) !== null && _a !== void 0 ? _a : 0);
                    valueWithOriginFees = (0, utils_1.toBn)(valueWithOriginFees.plus(royaltiesAmount).toString());
                    data.fees = (0, get_market_data_1.addFeeDependsOnExternalFee)(request.originFees, encodedFeesValue);
                }
            }
            return {
                requestData: {
                    data: data,
                    options: { value: valueWithOriginFees.toString() },
                },
                feeAddresses,
            };
        });
    }
    getTransactionDataForExchangeWrapper(request, originFees, encodedFeesValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.prepareTransactionData(request, originFees, encodedFeesValue)).requestData;
        });
    }
    getTransactionData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { requestData, feeAddresses } = yield this.prepareTransactionData(request, request.originFees, undefined);
            const provider = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const config = yield this.getConfig();
            const wrapperContract = (0, exchange_wrapper_1.createExchangeWrapperContract)(provider, config.exchange.wrapper);
            const functionCall = wrapperContract.functionCall("singlePurchase", requestData.data, feeAddresses[0], feeAddresses[1]);
            return {
                functionCall,
                options: {
                    value: requestData.options.value.toString(),
                },
            };
        });
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("LOOKSRARE");
    }
    getOrderFee() {
        return 0;
    }
}
exports.LooksrareOrderHandler = LooksrareOrderHandler;
function encodeLooksRareData(ethereum, makerOrder, takerOrder, typeNft) {
    const encoded = ethereum.encodeParameter(ORDERS_MATCH_TYPE, { makerOrder, takerOrder, typeNft });
    return `0x${encoded.slice(66)}`;
}
exports.encodeLooksRareData = encodeLooksRareData;
const MAKER_ORDER_TYPE = {
    components: [
        { name: "isOrderAsk", type: "bool" },
        { name: "signer", type: "address" },
        { name: "collection", type: "address" },
        { name: "price", type: "uint256" },
        { name: "tokenId", type: "uint256" },
        { name: "amount", type: "uint256" },
        { name: "strategy", type: "address" },
        { name: "currency", type: "address" },
        { name: "nonce", type: "uint256" },
        { name: "startTime", type: "uint256" },
        { name: "endTime", type: "uint256" },
        { name: "minPercentageToAsk", type: "uint256" },
        { name: "params", type: "bytes" },
        { name: "v", type: "uint8" },
        { name: "r", type: "bytes32" },
        { name: "s", type: "bytes32" },
    ],
    name: "makerOrder",
    type: "tuple",
};
const TAKER_ORDER_TYPE = {
    components: [
        { name: "isOrderAsk", type: "bool" },
        { name: "taker", type: "address" },
        { name: "price", type: "uint256" },
        { name: "tokenId", type: "uint256" },
        { name: "minPercentageToAsk", type: "uint256" },
        { name: "params", type: "bytes" },
    ],
    name: "takerOrder",
    type: "tuple",
};
const ORDERS_MATCH_TYPE = {
    components: [TAKER_ORDER_TYPE, MAKER_ORDER_TYPE, { name: "typeNft", type: "bytes4" }],
    name: "data",
    type: "tuple",
};
