"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApprovalActions = exports.approvedItemAmount = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const erc20_1 = require("../../contracts/erc20");
const erc721_1 = require("../../contracts/erc721");
const erc1155_1 = require("../../contracts/erc1155");
const wait_tx_1 = require("../../../common/wait-tx");
const item_1 = require("./item");
const constants_1 = require("./constants");
const approvedItemAmount = (ethereum, owner, item, operator) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if ((0, item_1.isErc721Item)(item.itemType) || (0, item_1.isErc1155Item)(item.itemType)) {
        const erc721 = (0, erc721_1.createErc721Contract)(ethereum, (0, types_1.toEVMAddress)(item.token));
        const allowance = yield erc721.functionCall("isApprovedForAll", owner, operator).call();
        return allowance ? constants_1.MAX_INT : (0, utils_1.toBn)(0);
    }
    else if (item.itemType === constants_1.ItemType.ERC20) {
        const erc20 = (0, erc20_1.createErc20Contract)(ethereum, (0, types_1.toEVMAddress)(item.token));
        return yield erc20.functionCall("allowance", owner, operator).call();
    }
    // We don't need to check approvals for native tokens
    return constants_1.MAX_INT;
});
exports.approvedItemAmount = approvedItemAmount;
/**
 * Get approval actions given a list of insufficent approvals.
 */
function getApprovalActions(ethereum, send, insufficientApprovals, wrapperAddress) {
    return Promise.all(insufficientApprovals
        .filter((approval, index) => index === insufficientApprovals.length - 1 || insufficientApprovals[index + 1].token !== approval.token)
        .map((_a) => tslib_1.__awaiter(this, [_a], void 0, function* ({ token, operator, itemType }) {
        if ((0, item_1.isErc721Item)(itemType)) {
            const erc721 = (0, erc721_1.createErc721Contract)(ethereum, (0, types_1.toEVMAddress)(token));
            return send(erc721.functionCall("setApprovalForAll", operator, true));
        }
        else if ((0, item_1.isErc1155Item)(itemType)) {
            const erc1155 = (0, erc1155_1.createErc1155Contract)(ethereum, (0, types_1.toEVMAddress)(token));
            return send(erc1155.functionCall("setApprovalForAll", operator, true));
        }
        else {
            const erc20 = (0, erc20_1.createErc20Contract)(ethereum, (0, types_1.toEVMAddress)(token));
            return send(erc20.functionCall("approve", wrapperAddress !== null && wrapperAddress !== void 0 ? wrapperAddress : operator, constants_1.MAX_INT.toFixed()));
        }
    }))
        .map((tx) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield (0, wait_tx_1.waitTx)(tx);
        return tx;
    })));
}
exports.getApprovalActions = getApprovalActions;
