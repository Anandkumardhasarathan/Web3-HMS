import type { Ethereum } from "@rarible/ethereum-provider";
import type { BigNumber } from "@rarible/utils";
import type { TimeBasedItemParams } from "./item";
import { getSummedTokenAndIdentifierAmounts } from "./item";
import type { OrderParameters } from "./types";
import type { InputCriteria, Item } from "./types";
import type { ItemType } from "./constants";
export type BalancesAndApprovals = {
    token: string;
    identifierOrCriteria: string;
    balance: BigNumber;
    approvedAmount: BigNumber;
    itemType: ItemType;
}[];
export type InsufficientBalances = {
    token: string;
    identifierOrCriteria: string;
    requiredAmount: BigNumber;
    amountHave: BigNumber;
    itemType: ItemType;
}[];
export type InsufficientApprovals = {
    token: string;
    identifierOrCriteria: string;
    approvedAmount: BigNumber;
    requiredApprovedAmount: BigNumber;
    operator: string;
    itemType: ItemType;
}[];
export declare const getBalancesAndApprovals: ({ ethereum, owner, items, criterias, operator, }: {
    ethereum: Ethereum;
    owner: string;
    items: Item[];
    criterias: InputCriteria[];
    operator: string;
}) => Promise<BalancesAndApprovals>;
export declare const getInsufficientBalanceAndApprovalAmounts: ({ balancesAndApprovals, tokenAndIdentifierAmounts, operator, }: {
    balancesAndApprovals: BalancesAndApprovals;
    tokenAndIdentifierAmounts: ReturnType<typeof getSummedTokenAndIdentifierAmounts>;
    operator: string;
}) => {
    insufficientBalances: InsufficientBalances;
    insufficientApprovals: InsufficientApprovals;
};
/**
 * 1. The offerer should have sufficient balance of all offered items.
 * 2. If the order does not indicate proxy utilization, the offerer should have sufficient approvals set
 *    for the Seaport contract for all offered ERC20, ERC721, and ERC1155 items.
 * 3. If the order does indicate proxy utilization, the offerer should have sufficient approvals set
 *    for their respective proxy contract for all offered ERC20, ERC721, and ERC1155 items.
 */
export declare const validateOfferBalancesAndApprovals: ({ offer, criterias, balancesAndApprovals, timeBasedItemParams, throwOnInsufficientBalances, throwOnInsufficientApprovals, operator, }: {
    balancesAndApprovals: BalancesAndApprovals;
    timeBasedItemParams?: TimeBasedItemParams;
    throwOnInsufficientBalances?: boolean;
    throwOnInsufficientApprovals?: boolean;
    operator: string;
} & Pick<OrderParameters, "offer"> & {
    criterias: InputCriteria[];
}) => InsufficientApprovals;
export declare const validateBasicFulfillBalancesAndApprovals: ({ offer, consideration, offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, disableCheckingBalances, }: {
    offererBalancesAndApprovals: BalancesAndApprovals;
    fulfillerBalancesAndApprovals: BalancesAndApprovals;
    timeBasedItemParams: TimeBasedItemParams;
    offererOperator: string;
    fulfillerOperator: string;
    disableCheckingBalances?: boolean;
} & Pick<OrderParameters, "offer" | "consideration">) => InsufficientApprovals;
export declare const validateStandardFulfillBalancesAndApprovals: ({ offer, consideration, offerCriteria, considerationCriteria, offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, disableCheckingBalances, }: Pick<OrderParameters, "offer" | "consideration"> & {
    offerCriteria: InputCriteria[];
    considerationCriteria: InputCriteria[];
    offererBalancesAndApprovals: BalancesAndApprovals;
    fulfillerBalancesAndApprovals: BalancesAndApprovals;
    timeBasedItemParams: TimeBasedItemParams;
    offererOperator: string;
    fulfillerOperator: string;
    disableCheckingBalances?: boolean;
}) => InsufficientApprovals;
