"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.approveBeforeStandardFulfillOrder = exports.approveBeforeBasicFulfillOrder = exports.fulfillOrder = exports.getSeaportContract = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const seaport_v14_1 = require("../../contracts/seaport-v14");
const seaport_1 = require("../../contracts/seaport");
const compare_case_insensitive_1 = require("../../../common/compare-case-insensitive");
const get_order_hash_1 = require("./get-order-hash");
const balance_and_approval_check_1 = require("./balance-and-approval-check");
const fulfill_1 = require("./fulfill");
const item_1 = require("./item");
const order_1 = require("./order");
const balance_and_approval_check_2 = require("./balance-and-approval-check");
const fulfill_basic_1 = require("./fulfill-basic");
const approval_1 = require("./approval");
const fulfill_standard_1 = require("./fulfill-standard");
const constants_1 = require("./constants");
const convert_to_seaport_order_1 = require("./convert-to-seaport-order");
function getSeaportContract(ethereum, protocol) {
    if ((0, compare_case_insensitive_1.compareCaseInsensitive)(protocol, constants_1.CROSS_CHAIN_SEAPORT_V1_4_ADDRESS) ||
        (0, compare_case_insensitive_1.compareCaseInsensitive)(protocol, constants_1.CROSS_CHAIN_SEAPORT_V1_5_ADDRESS) ||
        (0, compare_case_insensitive_1.compareCaseInsensitive)(protocol, constants_1.CROSS_CHAIN_SEAPORT_V1_6_ADDRESS)) {
        return (0, seaport_v14_1.createSeaportV14Contract)(ethereum, (0, types_1.toEVMAddress)(protocol));
    }
    else if ((0, compare_case_insensitive_1.compareCaseInsensitive)(protocol, constants_1.CROSS_CHAIN_SEAPORT_ADDRESS)) {
        return (0, seaport_1.createSeaportContract)(ethereum, (0, types_1.toEVMAddress)(protocol));
    }
    else {
        throw new Error("Unrecognized Seaport protocol");
    }
}
exports.getSeaportContract = getSeaportContract;
function fulfillOrder(ethereum_1, send_1, simpleOrder_1, _a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, send, simpleOrder, { tips, unitsToFill, disableCheckingBalances, }) {
        const seaportContract = (0, seaport_v14_1.createSeaportV14Contract)(ethereum, (0, types_1.toEVMAddress)(simpleOrder.data.protocol));
        const order = (0, convert_to_seaport_order_1.convertAPIOrderToSeaport)(simpleOrder);
        const { parameters: orderParameters } = order;
        const { offerer, offer, consideration } = orderParameters;
        const fulfillerAddress = yield ethereum.getFrom();
        const conduitKey = constants_1.OPENSEA_CONDUIT_KEY;
        const offererOperator = (0, constants_1.getConduitByKey)(orderParameters.conduitKey, simpleOrder.data.protocol);
        const fulfillerOperator = (0, constants_1.getConduitByKey)(conduitKey, simpleOrder.data.protocol);
        const extraData = "0x";
        const recipientAddress = types_1.EVM_ZERO_ADDRESS;
        const offerCriteria = [];
        const considerationCriteria = [];
        const [offererBalancesAndApprovals, fulfillerBalancesAndApprovals, orderStatus] = yield Promise.all([
            (0, balance_and_approval_check_2.getBalancesAndApprovals)({
                ethereum,
                owner: offerer,
                items: offer,
                criterias: offerCriteria,
                operator: offererOperator,
            }),
            (0, balance_and_approval_check_2.getBalancesAndApprovals)({
                ethereum,
                owner: fulfillerAddress,
                items: [...offer, ...consideration],
                criterias: [...offerCriteria, ...considerationCriteria],
                operator: fulfillerOperator,
            }),
            seaportContract.functionCall("getOrderStatus", (0, get_order_hash_1.getOrderHash)(orderParameters)).call(),
        ]);
        const orderStatusData = Object.assign({}, orderStatus);
        orderStatusData.totalFilled = (0, utils_1.toBn)(orderStatus.totalFilled);
        orderStatusData.totalSize = (0, utils_1.toBn)(orderStatus.totalSize);
        const { totalFilled, totalSize } = orderStatusData;
        const sanitizedOrder = (0, fulfill_1.validateAndSanitizeFromOrderStatus)(order, orderStatusData);
        const timeBasedItemParams = {
            startTime: sanitizedOrder.parameters.startTime,
            endTime: sanitizedOrder.parameters.endTime,
            currentBlockTimestamp: Math.floor(Date.now() / 1000),
            ascendingAmountTimestampBuffer: 300,
        };
        const tipConsiderationItems = (tips === null || tips === void 0 ? void 0 : tips.map(tip => (Object.assign(Object.assign({}, (0, order_1.mapInputItemToOfferItem)(tip)), { recipient: tip.recipient })))) || [];
        const isRecipientSelf = recipientAddress === types_1.EVM_ZERO_ADDRESS;
        // We use basic fulfills as they are more optimal for simple and "hot" use cases
        // We cannot use basic fulfill if user is trying to partially fill though.
        if (!unitsToFill && isRecipientSelf && (0, fulfill_1.shouldUseBasicFulfill)(sanitizedOrder.parameters, totalFilled)) {
            // TODO: Use fulfiller proxy if there are approvals needed directly, but none needed for proxy
            yield approveBeforeBasicFulfillOrder({
                ethereum,
                send,
                order,
                tips: tipConsiderationItems,
                offererBalancesAndApprovals,
                fulfillerBalancesAndApprovals,
                timeBasedItemParams,
                offererOperator,
                fulfillerOperator,
                disableCheckingBalances,
            });
            return (0, fulfill_basic_1.getfulfillBasicOrderData)({
                order: sanitizedOrder,
                timeBasedItemParams,
                conduitKey,
                tips: tipConsiderationItems,
                seaportContract,
            });
        }
        yield approveBeforeStandardFulfillOrder({
            ethereum,
            send,
            order: sanitizedOrder,
            unitsToFill,
            totalFilled,
            totalSize: totalSize.eq(0) ? (0, item_1.getMaximumSizeForOrder)(sanitizedOrder) : totalSize,
            offerCriteria,
            considerationCriteria,
            tips: tipConsiderationItems,
            offererBalancesAndApprovals,
            fulfillerBalancesAndApprovals,
            timeBasedItemParams,
            offererOperator,
            fulfillerOperator,
            disableCheckingBalances,
        });
        return (0, fulfill_standard_1.getFulfillStandardOrderData)({
            order: sanitizedOrder,
            unitsToFill,
            totalFilled,
            totalSize: totalSize.eq(0) ? (0, item_1.getMaximumSizeForOrder)(sanitizedOrder) : totalSize,
            offerCriteria,
            considerationCriteria,
            tips: tipConsiderationItems,
            extraData,
            timeBasedItemParams,
            conduitKey,
            recipientAddress,
            seaportContract,
        });
    });
}
exports.fulfillOrder = fulfillOrder;
function approveBeforeBasicFulfillOrder(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ ethereum, send, order, tips = [], offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, disableCheckingBalances, }) {
        const { offer, consideration } = order.parameters;
        const considerationIncludingTips = [...consideration, ...tips];
        const insufficientApprovals = (0, balance_and_approval_check_1.validateBasicFulfillBalancesAndApprovals)({
            offer,
            consideration: considerationIncludingTips,
            offererBalancesAndApprovals,
            fulfillerBalancesAndApprovals,
            timeBasedItemParams,
            offererOperator,
            fulfillerOperator,
            disableCheckingBalances,
        });
        const approvalActions = yield (0, approval_1.getApprovalActions)(ethereum, send, insufficientApprovals);
        return yield Promise.all(approvalActions);
    });
}
exports.approveBeforeBasicFulfillOrder = approveBeforeBasicFulfillOrder;
function approveBeforeStandardFulfillOrder(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ ethereum, send, order, tips = [], offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, unitsToFill = 0, totalSize, totalFilled, offerCriteria, considerationCriteria, disableCheckingBalances, }) {
        const orderWithAdjustedFills = unitsToFill
            ? (0, order_1.mapOrderAmountsFromUnitsToFill)(order, {
                unitsToFill,
                totalSize,
            })
            : // Else, we adjust the order by the remaining order left to be fulfilled
                (0, order_1.mapOrderAmountsFromFilledStatus)(order, {
                    totalFilled,
                    totalSize,
                });
        const { parameters: { offer, consideration }, } = orderWithAdjustedFills;
        const considerationIncludingTips = [...consideration, ...tips];
        const insufficientApprovals = (0, balance_and_approval_check_1.validateStandardFulfillBalancesAndApprovals)({
            offer,
            consideration: considerationIncludingTips,
            offerCriteria,
            considerationCriteria,
            offererBalancesAndApprovals,
            fulfillerBalancesAndApprovals,
            timeBasedItemParams,
            offererOperator,
            fulfillerOperator,
            disableCheckingBalances,
        });
        const approvalActions = yield (0, approval_1.getApprovalActions)(ethereum, send, insufficientApprovals);
        return yield Promise.all(approvalActions);
    });
}
exports.approveBeforeStandardFulfillOrder = approveBeforeStandardFulfillOrder;
