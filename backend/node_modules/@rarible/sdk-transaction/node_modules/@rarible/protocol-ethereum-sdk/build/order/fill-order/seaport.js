"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSeaportToken = exports.convertItemType = exports.convertOrderType = exports.SeaportOrderHandler = void 0;
const tslib_1 = require("tslib");
const SeaportOrderType_1 = require("@rarible/ethereum-api-client/build/models/SeaportOrderType");
const SeaportItemType_1 = require("@rarible/ethereum-api-client/build/models/SeaportItemType");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const utils_2 = require("@rarible/utils");
const axios_1 = tslib_1.__importDefault(require("axios"));
const is_nft_1 = require("../is-nft");
const get_required_wallet_1 = require("../../common/get-required-wallet");
const common_1 = require("../../nft/common");
const constants_1 = require("./seaport-utils/constants");
const seaport_wrapper_utils_1 = require("./seaport-utils/seaport-wrapper-utils");
const seaport_utils_1 = require("./seaport-utils/seaport-utils");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
class SeaportOrderHandler {
    constructor(ethereum, send, getConfig, getApis, getBaseOrderFeeConfig, env, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getApis = getApis;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.env = env;
        this.sdkConfig = sdkConfig;
    }
    sendTransaction(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { functionCall, options } = yield this.getTransactionData(request);
            return this.send(functionCall, options);
        });
    }
    getSignature(_a) {
        return tslib_1.__awaiter(this, arguments, void 0, function* ({ hash, protocol }) {
            var _b, _c, _d, _e, _f, _g, _h;
            try {
                const apis = yield this.getApis();
                const { signature } = yield apis.orderSignature.getSeaportOrderSignature({
                    hash: hash,
                });
                return signature;
            }
            catch (e) {
                const inactiveMsg = "Error when generating fulfillment data";
                const msg = ((_b = e === null || e === void 0 ? void 0 : e.value) === null || _b === void 0 ? void 0 : _b.message) || ((_c = e === null || e === void 0 ? void 0 : e.data) === null || _c === void 0 ? void 0 : _c.message);
                if (typeof msg === "string" && msg.includes(inactiveMsg)) {
                    throw new Error("Order is not active or cancelled");
                }
                if (this.env === "testnet" || this.env === "mumbai") {
                    try {
                        const orderData = {
                            listing: {
                                hash: hash,
                                chain: this.env === "testnet" ? "sepolia" : "mumbai",
                                protocol_address: protocol,
                            },
                            fulfiller: {
                                address: yield ((_d = this.ethereum) === null || _d === void 0 ? void 0 : _d.getFrom()),
                            },
                        };
                        const { data } = yield axios_1.default.post("https://testnets-api.opensea.io/v2/listings/fulfillment_data", orderData);
                        return data.fulfillment_data.orders[0].signature;
                    }
                    catch (e) {
                        console.error(e);
                        if (Array.isArray((_f = (_e = e === null || e === void 0 ? void 0 : e.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.errors)) {
                            throw new Error((_h = (_g = e === null || e === void 0 ? void 0 : e.response) === null || _g === void 0 ? void 0 : _g.data) === null || _h === void 0 ? void 0 : _h.errors.join(","));
                        }
                        throw e;
                    }
                }
                throw new Error(`api.getSeaportOrderSignature error: ${e}, hash=${hash}`);
            }
        });
    }
    getTransactionData(request, requestOptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const { order } = request;
            if (order.start === undefined || order.end === undefined) {
                throw new Error("Order should includes start/end fields");
            }
            const { unitsToFill, takeIsNft } = getUnitsToFill(request);
            let tips = [];
            if (!takeIsNft) {
                tips = this.convertOriginFeesToTips(request);
            }
            if (!order.signature || order.signature === "0x") {
                if (!request.order.hash) {
                    throw new Error("getSeaportOrderSignature error: order.hash does not exist");
                }
                order.signature = yield this.getSignature({
                    hash: request.order.hash,
                    protocol: request.order.data.protocol,
                });
                if (!order.signature) {
                    throw new Error("Can't fetch Seaport order signature");
                }
            }
            const { functionCall, options } = yield (0, seaport_utils_1.fulfillOrder)(ethereum, this.send.bind(this), order, {
                unitsToFill,
                tips,
                disableCheckingBalances: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.disableCheckingBalances,
            });
            return {
                functionCall,
                options,
            };
        });
    }
    convertOriginFeesToTips(request) {
        var _a;
        const { make } = request.order;
        const feeBase = make.assetType.assetClass === "ERC1155" && !(0, utils_1.toBn)(request.amount).isEqualTo(make.value)
            ? (0, utils_1.toBn)(request.order.take.value).div(make.value).multipliedBy(request.amount)
            : (0, utils_1.toBn)(request.order.take.value);
        return (_a = request.originFees) === null || _a === void 0 ? void 0 : _a.map(fee => ({
            token: getSeaportToken(request.order.take.assetType),
            amount: feeBase.multipliedBy((0, utils_1.toBn)(fee.value)).dividedBy(10000).integerValue(utils_2.BigNumber.ROUND_FLOOR).toFixed(),
            recipient: fee.account,
        }));
    }
    getTransactionDataForExchangeWrapper(request, originFees, feeValue, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            const { unitsToFill } = getUnitsToFill(request);
            const { totalFeeBasisPoints } = (0, origin_fees_utils_1.originFeeValueConvert)(originFees);
            if (!request.order.signature || request.order.signature === "0x") {
                request.order.signature = yield this.getSignature({
                    hash: request.order.hash,
                    protocol: request.order.data.protocol,
                });
                if (!request.order.signature) {
                    throw new Error("Can't fetch Seaport order signature");
                }
            }
            if (!config.exchange.wrapper) {
                throw new Error("Exchange wrapper is not defined for Seaport tx");
            }
            const takeAssetType = request.order.take.assetType;
            let feeValueWithCurrency = feeValue;
            if ((0, common_1.isWeth)(takeAssetType, config)) {
                feeValueWithCurrency = (0, origin_fees_utils_1.setFeesCurrency)(feeValueWithCurrency, true);
            }
            return (0, seaport_wrapper_utils_1.prepareSeaportExchangeData)(this.ethereum, this.send.bind(this), request.order, {
                unitsToFill: unitsToFill,
                encodedFeesValue: feeValueWithCurrency,
                totalFeeBasisPoints: totalFeeBasisPoints,
                disableCheckingBalances: options === null || options === void 0 ? void 0 : options.disableCheckingBalances,
            });
        });
    }
    getAssetToApprove(request, feesData) {
        const { make, take } = request.order;
        const totalPrice = (0, utils_1.toBn)(take.value).div(make.value).multipliedBy(request.amount);
        let valueWithOriginFees = (0, origin_fees_utils_1.calcValueWithFees)(totalPrice, feesData.totalFeeBasisPoints);
        return {
            assetType: take.assetType,
            value: (0, types_1.toBigNumber)(valueWithOriginFees.toFixed()),
        };
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("SEAPORT_V1");
    }
    getOrderFee() {
        return 0;
    }
}
exports.SeaportOrderHandler = SeaportOrderHandler;
function getUnitsToFill(request) {
    const takeIsNft = (0, is_nft_1.isNft)(request.order.take.assetType);
    const makeIsNft = (0, is_nft_1.isNft)(request.order.make.assetType);
    const unitsToFill = request.order.make.assetType.assetClass === "ERC1155" || request.order.take.assetType.assetClass === "ERC1155"
        ? request.amount
        : undefined;
    const isSupportedPartialFill = request.order.data.orderType === "PARTIAL_RESTRICTED" || request.order.data.orderType === "PARTIAL_OPEN";
    let isPartialFill;
    if (takeIsNft) {
        isPartialFill = unitsToFill ? unitsToFill.toString() !== request.order.take.value.toString() : false;
    }
    else if (makeIsNft) {
        isPartialFill = unitsToFill ? unitsToFill.toString() !== request.order.make.value.toString() : false;
    }
    else {
        throw new Error("Make/take asset in order is non-nft asset");
    }
    if (!isSupportedPartialFill && isPartialFill) {
        throw new Error("Order is not supported partial fill");
    }
    return {
        unitsToFill,
        takeIsNft,
    };
}
function convertOrderType(type) {
    switch (type) {
        case SeaportOrderType_1.SeaportOrderType.FULL_OPEN:
            return constants_1.OrderType.FULL_OPEN;
        case SeaportOrderType_1.SeaportOrderType.PARTIAL_OPEN:
            return constants_1.OrderType.PARTIAL_OPEN;
        case SeaportOrderType_1.SeaportOrderType.FULL_RESTRICTED:
            return constants_1.OrderType.FULL_RESTRICTED;
        case SeaportOrderType_1.SeaportOrderType.PARTIAL_RESTRICTED:
            return constants_1.OrderType.PARTIAL_RESTRICTED;
        default:
            throw new Error(`Unrecognized order type=${type}`);
    }
}
exports.convertOrderType = convertOrderType;
function convertItemType(type) {
    switch (type) {
        case SeaportItemType_1.SeaportItemType.NATIVE:
            return constants_1.ItemType.NATIVE;
        case SeaportItemType_1.SeaportItemType.ERC20:
            return constants_1.ItemType.ERC20;
        case SeaportItemType_1.SeaportItemType.ERC721:
            return constants_1.ItemType.ERC721;
        case SeaportItemType_1.SeaportItemType.ERC721_WITH_CRITERIA:
            return constants_1.ItemType.ERC721_WITH_CRITERIA;
        case SeaportItemType_1.SeaportItemType.ERC1155:
            return constants_1.ItemType.ERC1155;
        case SeaportItemType_1.SeaportItemType.ERC1155_WITH_CRITERIA:
            return constants_1.ItemType.ERC1155_WITH_CRITERIA;
        default:
            throw new Error(`Unrecognized item type=${type}`);
    }
}
exports.convertItemType = convertItemType;
function getSeaportToken(assetType) {
    switch (assetType.assetClass) {
        case "ETH":
            return types_1.EVM_ZERO_ADDRESS;
        case "ERC20":
            return assetType.contract;
        default:
            throw new Error("Asset type should be currency token");
    }
}
exports.getSeaportToken = getSeaportToken;
