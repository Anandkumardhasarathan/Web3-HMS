"use strict";
// noinspection JSCommentMatchesSignature
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpsertOrder = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const cryptoPunks_1 = require("../nft/contracts/cryptoPunks");
const get_required_wallet_1 = require("../common/get-required-wallet");
const wait_tx_1 = require("../common/wait-tx");
const check_min_payment_value_1 = require("../common/check-min-payment-value");
const common_1 = require("../common");
const add_fee_1 = require("./add-fee");
const erc20_1 = require("./contracts/erc20");
const ZERO = (0, types_1.toWord)("0x0000000000000000000000000000000000000000000000000000000000000000");
class UpsertOrder {
    constructor(orderFiller, send, getConfig, checkLazyOrder, approveFn, signOrder, getApis, ethereum) {
        this.orderFiller = orderFiller;
        this.send = send;
        this.getConfig = getConfig;
        this.checkLazyOrder = checkLazyOrder;
        this.approveFn = approveFn;
        this.signOrder = signOrder;
        this.getApis = getApis;
        this.ethereum = ethereum;
        this.upsert = action_1.Action.create({
            id: "approve",
            run: (_a) => tslib_1.__awaiter(this, [_a], void 0, function* ({ order, infinite }) {
                const checkedOrder = (yield this.checkLazyOrder(order));
                yield this.approve(checkedOrder, infinite);
                return checkedOrder;
            }),
        }).thenStep({
            id: "sign",
            run: (checked) => this.upsertRequest(checked),
        });
    }
    getOrder(hasOrder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("order" in hasOrder) {
                return hasOrder.order;
            }
            else {
                const apis = yield this.getApis();
                return apis.order.getValidatedOrderByHash({ hash: hasOrder.orderHash });
            }
        });
    }
    getPrice(hasPrice, assetType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("price" in hasPrice) {
                return hasPrice.price;
            }
            else {
                switch (assetType.assetClass) {
                    case "ETH":
                        return (0, utils_1.toBn)(hasPrice.priceDecimal).multipliedBy(common_1.ETHER_IN_WEI);
                    case "ERC20":
                        const decimals = yield (0, erc20_1.createErc20Contract)((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), assetType.contract)
                            .functionCall("decimals")
                            .call();
                        return (0, utils_1.toBn)(hasPrice.priceDecimal).multipliedBy((0, utils_1.toBn)(10).pow(Number(decimals)));
                    default:
                        throw new Error(`Asset type should be either ETH or ERC-20, received=${JSON.stringify(assetType)}`);
                }
            }
        });
    }
    approve(checkedOrder_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (checkedOrder, infinite = false) {
            const simple = UpsertOrder.orderFormToSimpleOrder(checkedOrder);
            const fee = yield this.orderFiller.getOrderFee(simple);
            const make = (0, add_fee_1.addFee)(checkedOrder.make, fee);
            const approveTx = this.approveFn(checkedOrder.maker, make, infinite);
            if (approveTx) {
                yield (0, wait_tx_1.waitTx)(approveTx);
            }
            return approveTx;
        });
    }
    upsertRequest(checked) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const simple = UpsertOrder.orderFormToSimpleOrder(checked);
            const apis = yield this.getApis();
            yield (0, check_min_payment_value_1.checkMinPaymentValue)((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), checked);
            return apis.order.upsertOrder({
                orderForm: Object.assign(Object.assign({}, checked), { signature: yield this.signOrder(simple) }),
            });
        });
    }
    prepareOrderForm(request, isMakeFill) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let data;
            switch (request.type) {
                case "DATA_V2":
                    data = {
                        dataType: "RARIBLE_V2_DATA_V2",
                        payouts: request.payouts,
                        originFees: request.originFees,
                        isMakeFill,
                    };
                    break;
                case "DATA_V3":
                    data = {
                        dataType: "RARIBLE_V2_DATA_V3",
                        payouts: request.payouts,
                        originFees: request.originFees,
                        isMakeFill,
                    };
                    break;
                default:
                    throw new Error("Unknown OrderRequest type");
            }
            return {
                maker: (0, types_1.toEVMAddress)(yield this.getOrderMaker(request)),
                type: "RARIBLE_V2",
                data: data,
                salt: (0, types_1.toBigNumber)((0, utils_1.toBn)((0, types_1.randomWord)(), 16).toString(10)),
                signature: (0, types_1.toBinary)("0x"),
                start: request.start,
                end: request.end,
            };
        });
    }
    getOrderMaker(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (request.maker) {
                return request.maker;
            }
            else {
                return yield (0, get_required_wallet_1.getRequiredWallet)(this.ethereum).getFrom();
            }
        });
    }
    static orderFormToSimpleOrder(form) {
        return Object.assign(Object.assign({}, form), { salt: (0, types_1.toBinary)((0, utils_1.toBn)(form.salt).toString(16)) });
    }
    updateCryptoPunkOrder(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.getOrder(request);
            if (order.type !== "CRYPTO_PUNK") {
                throw new Error(`can't update punk order with type: ${order.type}`);
            }
            yield this.updateCryptoPunkOrderByContract((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), order, request);
            return simpleToCryptoPunkOrder(order);
        });
    }
    updateCryptoPunkOrderByContract(ethereum, order, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const price = yield this.getPrice(request, {});
            if (order.make.assetType.assetClass === "CRYPTO_PUNKS") {
                const ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, order.make.assetType.contract);
                yield this.send(ethContract.functionCall("offerPunkForSale", order.make.assetType.tokenId, price));
            }
            else if (order.take.assetType.assetClass === "CRYPTO_PUNKS") {
                const ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, order.take.assetType.contract);
                yield this.send(ethContract.functionCall("enterBidForPunk", order.take.assetType.tokenId), {
                    value: price.toString(),
                });
            }
            else {
                throw new Error("Crypto punks asset has not been found");
            }
        });
    }
}
exports.UpsertOrder = UpsertOrder;
function simpleToCryptoPunkOrder(order) {
    return Object.assign(Object.assign({}, order), { cancelled: false, createdAt: "", fill: (0, types_1.toBigNumber)("0"), hash: ZERO, lastUpdateAt: "", makeStock: order.make.value });
}
