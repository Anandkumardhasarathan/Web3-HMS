"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBlockchainWallet = exports.AptosWallet = exports.ImmutableXWallet = exports.SolanaWallet = exports.TezosWallet = exports.FlowWallet = exports.EthereumWallet = void 0;
const tslib_1 = require("tslib");
const text_encoding_1 = require("text-encoding");
const domain_1 = require("./domain");
class EthereumWallet {
    constructor(ethereum) {
        this.ethereum = ethereum;
        this.walletType = domain_1.WalletType.ETHEREUM;
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethereum.getFrom();
            if (!address)
                throw new Error("Not connected to Ethereum blockchain");
            return {
                message,
                signature: yield this.ethereum.personalSign(message),
                publicKey: address,
            };
        });
    }
}
exports.EthereumWallet = EthereumWallet;
class FlowWallet {
    constructor(fcl, auth) {
        this.fcl = fcl;
        this.auth = auth;
        this.walletType = domain_1.WalletType.FLOW;
    }
    getAuth() {
        return this.auth;
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!message.length) {
                throw new Error("Message can't be empty");
            }
            const messageHex = Buffer.from(message).toString("hex");
            if (this.auth) {
                return Object.assign({ message }, (yield this._getSignatureFromAuth(messageHex)));
            }
            const currentUser = this.fcl.currentUser();
            const user = yield this.fcl.currentUser().snapshot();
            const address = user.addr;
            if (!address) {
                throw new Error("Not connected to Flow blockchain");
            }
            const account = yield this.fcl.account(address);
            const signatures = yield currentUser.signUserMessage(messageHex);
            if (typeof signatures === "string") {
                throw new Error(signatures);
            }
            const signature = signatures.find(s => {
                return s.addr.toLowerCase() === address.toLowerCase();
            });
            if (signature) {
                const pubKey = account.keys.find(k => k.index === signature.keyId);
                if (!pubKey) {
                    throw new Error(`Key with index "${signature.keyId}" not found on account with address ${address}`);
                }
                return {
                    message,
                    signature: signature.signature,
                    publicKey: pubKey.publicKey,
                };
            }
            throw new Error(`Signature of user address "${address}" not found`);
        });
    }
    _getSignatureFromAuth(msgHex) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.auth)
                throw new Error("Auth was not been passed");
            const authResult = yield this.auth();
            const signResult = yield authResult.signingFunction({
                message: msgHex,
                addr: authResult.addr,
            });
            if (!signResult || !signResult.signature) {
                throw new Error(`Signature of user address "${authResult.addr}" not found`);
            }
            const account = yield this.fcl.account(authResult.addr);
            const pubKey = account.keys.find(k => k.index === signResult.keyId);
            if (!pubKey) {
                throw new Error(`Key with index "${signResult.keyId}" not found on account with address ${authResult.addr}`);
            }
            return {
                signature: signResult.signature,
                publicKey: pubKey.publicKey,
            };
        });
    }
}
exports.FlowWallet = FlowWallet;
class TezosWallet {
    constructor(provider) {
        this.provider = provider;
        this.walletType = domain_1.WalletType.TEZOS;
    }
    sign(p, message, type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            type = type || "message";
            const edpk = yield p.public_key();
            if (typeof edpk === "undefined")
                throw new Error("cannot get public key from provider");
            const r = yield p.sign(message, type);
            return Object.assign({ edpk }, r);
        });
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this.provider.public_key();
            if (typeof publicKey === "undefined")
                throw new Error("Public key undefined");
            const result = yield this.sign(this.provider, message, "message");
            return {
                message,
                signature: result.signature,
                publicKey: `${result.edpk}_${result.prefix}`,
            };
        });
    }
}
exports.TezosWallet = TezosWallet;
class SolanaWallet {
    constructor(provider) {
        this.provider = provider;
        this.walletType = domain_1.WalletType.SOLANA;
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const data = new text_encoding_1.TextEncoder().encode(message);
            const result = yield this.provider.signMessage(data, "utf8");
            return {
                message,
                signature: Buffer.from(result.signature).toString("hex"),
                publicKey: result.publicKey.toString(),
            };
        });
    }
}
exports.SolanaWallet = SolanaWallet;
class ImmutableXWallet {
    constructor(wallet) {
        this.wallet = wallet;
        this.walletType = domain_1.WalletType.IMMUTABLEX;
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                message,
                signature: (yield this.wallet.link.sign({ message, description: message })).result,
                publicKey: this.wallet.getConnectionData().address,
            };
        });
    }
}
exports.ImmutableXWallet = ImmutableXWallet;
class AptosWallet {
    constructor(wallet) {
        this.wallet = wallet;
        this.walletType = domain_1.WalletType.APTOS;
    }
    signPersonalMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const accountInfo = yield this.wallet.getAccountInfo();
            const signResponse = yield this.wallet.signMessage(message);
            return {
                message: signResponse.message,
                signature: signResponse.signature,
                publicKey: accountInfo.publicKey,
            };
        });
    }
}
exports.AptosWallet = AptosWallet;
function isBlockchainWallet(x) {
    return typeof x === "object" && x !== null && "signPersonalMessage" in x && "walletType" in x;
}
exports.isBlockchainWallet = isBlockchainWallet;
