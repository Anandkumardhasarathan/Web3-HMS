import { __awaiter } from "tslib";
import { TextEncoder } from "text-encoding";
import { WalletType } from "./domain";
export class EthereumWallet {
    constructor(ethereum) {
        this.ethereum = ethereum;
        this.walletType = WalletType.ETHEREUM;
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethereum.getFrom();
            if (!address)
                throw new Error("Not connected to Ethereum blockchain");
            return {
                message,
                signature: yield this.ethereum.personalSign(message),
                publicKey: address,
            };
        });
    }
}
export class FlowWallet {
    constructor(fcl, auth) {
        this.fcl = fcl;
        this.auth = auth;
        this.walletType = WalletType.FLOW;
    }
    getAuth() {
        return this.auth;
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!message.length) {
                throw new Error("Message can't be empty");
            }
            const messageHex = Buffer.from(message).toString("hex");
            if (this.auth) {
                return Object.assign({ message }, (yield this._getSignatureFromAuth(messageHex)));
            }
            const currentUser = this.fcl.currentUser();
            const user = yield this.fcl.currentUser().snapshot();
            const address = user.addr;
            if (!address) {
                throw new Error("Not connected to Flow blockchain");
            }
            const account = yield this.fcl.account(address);
            const signatures = yield currentUser.signUserMessage(messageHex);
            if (typeof signatures === "string") {
                throw new Error(signatures);
            }
            const signature = signatures.find(s => {
                return s.addr.toLowerCase() === address.toLowerCase();
            });
            if (signature) {
                const pubKey = account.keys.find(k => k.index === signature.keyId);
                if (!pubKey) {
                    throw new Error(`Key with index "${signature.keyId}" not found on account with address ${address}`);
                }
                return {
                    message,
                    signature: signature.signature,
                    publicKey: pubKey.publicKey,
                };
            }
            throw new Error(`Signature of user address "${address}" not found`);
        });
    }
    _getSignatureFromAuth(msgHex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.auth)
                throw new Error("Auth was not been passed");
            const authResult = yield this.auth();
            const signResult = yield authResult.signingFunction({
                message: msgHex,
                addr: authResult.addr,
            });
            if (!signResult || !signResult.signature) {
                throw new Error(`Signature of user address "${authResult.addr}" not found`);
            }
            const account = yield this.fcl.account(authResult.addr);
            const pubKey = account.keys.find(k => k.index === signResult.keyId);
            if (!pubKey) {
                throw new Error(`Key with index "${signResult.keyId}" not found on account with address ${authResult.addr}`);
            }
            return {
                signature: signResult.signature,
                publicKey: pubKey.publicKey,
            };
        });
    }
}
export class TezosWallet {
    constructor(provider) {
        this.provider = provider;
        this.walletType = WalletType.TEZOS;
    }
    sign(p, message, type) {
        return __awaiter(this, void 0, void 0, function* () {
            type = type || "message";
            const edpk = yield p.public_key();
            if (typeof edpk === "undefined")
                throw new Error("cannot get public key from provider");
            const r = yield p.sign(message, type);
            return Object.assign({ edpk }, r);
        });
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this.provider.public_key();
            if (typeof publicKey === "undefined")
                throw new Error("Public key undefined");
            const result = yield this.sign(this.provider, message, "message");
            return {
                message,
                signature: result.signature,
                publicKey: `${result.edpk}_${result.prefix}`,
            };
        });
    }
}
export class SolanaWallet {
    constructor(provider) {
        this.provider = provider;
        this.walletType = WalletType.SOLANA;
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = new TextEncoder().encode(message);
            const result = yield this.provider.signMessage(data, "utf8");
            return {
                message,
                signature: Buffer.from(result.signature).toString("hex"),
                publicKey: result.publicKey.toString(),
            };
        });
    }
}
export class ImmutableXWallet {
    constructor(wallet) {
        this.wallet = wallet;
        this.walletType = WalletType.IMMUTABLEX;
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                message,
                signature: (yield this.wallet.link.sign({ message, description: message })).result,
                publicKey: this.wallet.getConnectionData().address,
            };
        });
    }
}
export class AptosWallet {
    constructor(wallet) {
        this.wallet = wallet;
        this.walletType = WalletType.APTOS;
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountInfo = yield this.wallet.getAccountInfo();
            const signResponse = yield this.wallet.signMessage(message);
            return {
                message: signResponse.message,
                signature: signResponse.signature,
                publicKey: accountInfo.publicKey,
            };
        });
    }
}
export function isBlockchainWallet(x) {
    return typeof x === "object" && x !== null && "signPersonalMessage" in x && "walletType" in x;
}
