"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XTZ = exports.normalizeId = exports.isValidBase64 = exports.getDataFromCurrencyId = exports.convertCurrencyIdToAssetType = exports.convertAssetTypeToCurrencyId = exports.isTokenCurrencyAssetType = exports.isNativeCurrencyAssetType = exports.isErc20 = exports.isEth = exports.isAssetType = exports.isRequestCurrencyAssetType = exports.getCurrencyId = exports.getCurrencyAssetType = void 0;
const types_1 = require("@rarible/types");
const api_client_1 = require("@rarible/api-client");
const sdk_common_1 = require("@rarible/sdk-common");
const aptos_sdk_1 = require("@rarible/aptos-sdk");
const eclipse_sdk_1 = require("@rarible/eclipse-sdk");
function getCurrencyAssetType(currency) {
    if (isRequestCurrencyAssetType(currency)) {
        return convertCurrencyIdToAssetType(currency);
    }
    else if (isAssetType(currency)) {
        return currency;
    }
    else {
        throw new Error(`Unrecognized RequestCurrency ${JSON.stringify(currency)}`);
    }
}
exports.getCurrencyAssetType = getCurrencyAssetType;
function getCurrencyId(currency) {
    if (isAssetType(currency)) {
        return convertAssetTypeToCurrencyId(currency);
    }
    else if (isRequestCurrencyAssetType(currency)) {
        return currency;
    }
    else {
        throw new Error(`Unrecognized RequestCurrency ${JSON.stringify(currency)}`);
    }
}
exports.getCurrencyId = getCurrencyId;
function isRequestCurrencyAssetType(x) {
    return typeof x === "string" && !!(0, types_1.toCurrencyId)(x);
}
exports.isRequestCurrencyAssetType = isRequestCurrencyAssetType;
function isAssetType(x) {
    return typeof x === "object" && x !== null && "@type" in x;
}
exports.isAssetType = isAssetType;
function isEth(x) {
    return x["@type"] === "ETH";
}
exports.isEth = isEth;
function isErc20(x) {
    return x["@type"] === "ERC20";
}
exports.isErc20 = isErc20;
function isNativeCurrencyAssetType(x) {
    return x["@type"] === "CURRENCY_NATIVE" && !!x.blockchain;
}
exports.isNativeCurrencyAssetType = isNativeCurrencyAssetType;
function isTokenCurrencyAssetType(x) {
    return x["@type"] === "CURRENCY_TOKEN" && !!x.contract;
}
exports.isTokenCurrencyAssetType = isTokenCurrencyAssetType;
function convertAssetTypeToCurrencyId(id) {
    if (isEth(id)) {
        return (0, types_1.toCurrencyId)(`${id.blockchain || api_client_1.Blockchain.ETHEREUM}:${types_1.ZERO_ADDRESS}`);
    }
    if (isErc20(id)) {
        return (0, types_1.toCurrencyId)(id.contract);
    }
    if (isNativeCurrencyAssetType(id)) {
        if (id.blockchain === api_client_1.Blockchain.APTOS) {
            return (0, types_1.toCurrencyId)(`${api_client_1.Blockchain.APTOS}:${aptos_sdk_1.ENCODED_APT_TOKEN_TYPE}`);
        }
        if (id.blockchain === api_client_1.Blockchain.ECLIPSE) {
            return (0, types_1.toCurrencyId)(`${api_client_1.Blockchain.ECLIPSE}:${eclipse_sdk_1.ECLIPSE_NATIVE_CURRENCY_ADDRESS}`);
        }
    }
    if (isTokenCurrencyAssetType(id)) {
        return (0, types_1.toCurrencyId)(id.contract);
    }
    throw new Error(`Unsupported currency type: ${id}`);
}
exports.convertAssetTypeToCurrencyId = convertAssetTypeToCurrencyId;
function convertCurrencyIdToAssetType(id) {
    const blockchain = (0, sdk_common_1.extractBlockchain)(id);
    const rawId = (0, sdk_common_1.extractId)(id);
    if (blockchain === api_client_1.Blockchain.APTOS) {
        const normalizedId = normalizeId(rawId);
        if (normalizedId === aptos_sdk_1.APT_TOKEN_TYPE) {
            return {
                "@type": "CURRENCY_NATIVE",
                blockchain: api_client_1.Blockchain.APTOS,
            };
        }
        return {
            "@type": "CURRENCY_TOKEN",
            contract: (0, types_1.toUnionContractAddress)(id),
        };
    }
    const { contract, tokenId } = getDataFromCurrencyId(id);
    if ((0, sdk_common_1.isEVMBlockchain)(blockchain) || blockchain === api_client_1.Blockchain.IMMUTABLEX) {
        if (contract === types_1.ZERO_ADDRESS) {
            return {
                "@type": "ETH",
                blockchain: blockchain,
            };
        }
        return {
            "@type": "ERC20",
            contract: (0, types_1.toUnionContractAddress)(`${blockchain}:${contract}`),
        };
    }
    if (blockchain === api_client_1.Blockchain.FLOW) {
        return {
            "@type": "FLOW_FT",
            contract: (0, types_1.toUnionContractAddress)(id),
        };
    }
    if (blockchain === api_client_1.Blockchain.TEZOS) {
        if (id === exports.XTZ) {
            return {
                "@type": "XTZ",
            };
        }
        return {
            "@type": "TEZOS_FT",
            contract: (0, types_1.toUnionContractAddress)(`TEZOS:${contract}`),
            tokenId: tokenId ? (0, types_1.toBigNumber)(tokenId) : undefined,
        };
    }
    if (blockchain === api_client_1.Blockchain.SOLANA) {
        if (contract === types_1.ZERO_ADDRESS) {
            return {
                "@type": "SOLANA_SOL",
            };
        }
        return {
            "@type": "SOLANA_NFT",
            itemId: (0, types_1.toItemId)("SOLANA:" + contract),
        };
    }
    if (blockchain === api_client_1.Blockchain.ECLIPSE) {
        if (contract === eclipse_sdk_1.ECLIPSE_NATIVE_CURRENCY_ADDRESS) {
            return {
                "@type": "CURRENCY_NATIVE",
                blockchain: api_client_1.Blockchain.ECLIPSE,
            };
        }
        return {
            "@type": "CURRENCY_TOKEN",
            contract: (0, types_1.toUnionContractAddress)(id),
        };
    }
    throw new Error(`Unsupported currency type: ${id}`);
}
exports.convertCurrencyIdToAssetType = convertCurrencyIdToAssetType;
/*
  Get data from currency id for non-Aptos IDs
 */
function getDataFromCurrencyId(id) {
    const blockchain = (0, sdk_common_1.extractBlockchain)(id);
    if (!(blockchain in api_client_1.Blockchain)) {
        throw new Error(`Unsupported blockchain: ${id}`);
    }
    if (blockchain === api_client_1.Blockchain.APTOS) {
        throw new Error("Current extractor doesn't support Aptos blockchain");
    }
    const extractedId = (0, sdk_common_1.extractId)(id);
    const [contract, tokenId] = extractedId.split(":");
    return {
        blockchain: blockchain,
        id: extractedId,
        contract,
        tokenId,
    };
}
exports.getDataFromCurrencyId = getDataFromCurrencyId;
const base64Regex = /^[a-zA-Z0-9+/]*={0,2}$/;
function isValidBase64(input) {
    return base64Regex.test(input);
}
exports.isValidBase64 = isValidBase64;
function normalizeId(input) {
    try {
        return isValidBase64(input) ? atob(input) : input;
    }
    catch (e) { }
    return input;
}
exports.normalizeId = normalizeId;
exports.XTZ = "TEZOS:tz1Ke2h7sDdakHJQh8WX4Z372du1KChsksyU";
