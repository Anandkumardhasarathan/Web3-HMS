"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HUMAN_READABLE_MSG_LIST = exports.getCallableExtraFields = exports.getInternalLoggerMiddleware = exports.getErrorMessageString = exports.formatDefaultError = exports.getWalletInfo = exports.loggerConfig = void 0;
const tslib_1 = require("tslib");
const build_1 = require("@rarible/logger/build");
const sdk_wallet_1 = require("@rarible/sdk-wallet");
const axios_1 = tslib_1.__importDefault(require("axios"));
const sdk_common_1 = require("@rarible/sdk-common");
const sdk_common_2 = require("@rarible/sdk-common");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const domain_1 = require("../../domain");
const get_sdk_context_1 = require("../get-sdk-context");
const middleware_1 = require("../middleware/middleware");
const utils_1 = require("../utils");
const logger_overrides_1 = require("./logger-overrides");
exports.loggerConfig = {
    service: "union-sdk",
    elkUrl: "https://logging.rarible.com/",
};
function getWalletInfo(wallet) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const info = {
            "wallet.blockchain": wallet.walletType,
        };
        switch (wallet.walletType) {
            case sdk_wallet_1.WalletType.ETHEREUM: {
                const [chainIdResult, addressResult] = yield Promise.allSettled([
                    wallet.ethereum.getChainId(),
                    wallet.ethereum.getFrom(),
                ]);
                info["wallet.address"] =
                    addressResult.status === "fulfilled"
                        ? (_a = addressResult === null || addressResult === void 0 ? void 0 : addressResult.value) === null || _a === void 0 ? void 0 : _a.toLowerCase()
                        : formatDefaultError(addressResult.reason);
                info["wallet.chainId"] =
                    chainIdResult.status === "fulfilled" ? chainIdResult === null || chainIdResult === void 0 ? void 0 : chainIdResult.value : formatDefaultError(chainIdResult.reason);
                break;
            }
            case sdk_wallet_1.WalletType.FLOW: {
                const [userData, authResult] = yield (0, sdk_common_1.promiseSettledRequest)([
                    wallet.fcl.currentUser().snapshot(),
                    typeof wallet.auth === "function" ? wallet.auth() : undefined,
                ]);
                info["wallet.address"] = (userData === null || userData === void 0 ? void 0 : userData.addr) || (authResult === null || authResult === void 0 ? void 0 : authResult.addr);
                info["wallet.flow.chainId"] = userData === null || userData === void 0 ? void 0 : userData.cid;
                break;
            }
            case sdk_wallet_1.WalletType.TEZOS: {
                info["wallet.tezos.kind"] = wallet.provider.kind;
                const [chainIdResult, addressResult] = yield Promise.allSettled([
                    wallet.provider.chain_id(),
                    wallet.provider.address(),
                ]);
                info["wallet.address"] =
                    addressResult.status === "fulfilled" ? addressResult.value : formatDefaultError(addressResult.reason);
                info["wallet.tezos.chainId"] =
                    chainIdResult.status === "fulfilled" ? chainIdResult.value : formatDefaultError(chainIdResult.reason);
                break;
            }
            case sdk_wallet_1.WalletType.SOLANA: {
                info["wallet.address"] = (_b = wallet.provider.publicKey) === null || _b === void 0 ? void 0 : _b.toString();
                break;
            }
            case sdk_wallet_1.WalletType.IMMUTABLEX: {
                const data = wallet.wallet.getConnectionData();
                info["wallet.address"] = data.address;
                info["wallet.network"] = data.ethNetwork;
                info["wallet.starkPubkey"] = data.starkPublicKey;
                break;
            }
            case sdk_wallet_1.WalletType.APTOS: {
                const [data] = yield (0, sdk_common_1.promiseSettledRequest)([wallet.wallet.getAccountInfo()]);
                info["wallet.address"] = data === null || data === void 0 ? void 0 : data.address;
                info["wallet.network"] = data === null || data === void 0 ? void 0 : data.network;
                break;
            }
            default:
                info["wallet.address"] = "unknown";
                info["wallet.network"] = "unrecognized WalletType";
        }
        return info;
    });
}
exports.getWalletInfo = getWalletInfo;
function formatDefaultError(err) {
    return `unknown (${getErrorMessageString(err)})`;
}
exports.formatDefaultError = formatDefaultError;
function getErrorMessageString(err) {
    try {
        if (!err) {
            return "not defined";
        }
        else if (typeof err === "string") {
            return err;
        }
        else if (err instanceof Error) {
            return (0, logger_overrides_1.getExecRevertedMessage)(err.message);
        }
        else if (err.message) {
            return typeof err.message === "string"
                ? (0, logger_overrides_1.getExecRevertedMessage)(err.message)
                : (0, sdk_common_1.getStringifiedData)(err.message) || "";
        }
        else if (err.status !== undefined && err.statusText !== undefined) {
            return JSON.stringify({
                url: err.url,
                status: err.status,
                statusText: err.statusText,
            });
        }
        else {
            return (0, sdk_common_1.getStringifiedData)(err) || "";
        }
    }
    catch (e) {
        return `getErrorMessageString parse error: ${e === null || e === void 0 ? void 0 : e.message}`;
    }
}
exports.getErrorMessageString = getErrorMessageString;
function getInternalLoggerMiddleware(logsLevel, sdkContext, externalLogger) {
    const remoteLogger = externalLogger !== null && externalLogger !== void 0 ? externalLogger : new build_1.RemoteLogger((msg) => axios_1.default.post(exports.loggerConfig.elkUrl, msg), {
        initialContext: (0, get_sdk_context_1.getSdkContext)(sdkContext),
        dropBatchInterval: 1000,
        maxByteSize: 3 * 10240,
    });
    return (callable, args) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const time = Date.now();
        return [
            callable,
            (responsePromise) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let wrappedError;
                const dataContainer = new logger_overrides_1.LoggerDataContainer({
                    args,
                    callable,
                    responsePromise,
                    sdkContext,
                    startTime: time,
                });
                try {
                    yield responsePromise;
                    if (logsLevel >= domain_1.LogsLevel.TRACE) {
                        remoteLogger.raw(yield dataContainer.getTraceData());
                    }
                }
                catch (err) {
                    wrappedError = wrapSpecialErrors(err);
                    if (logsLevel >= domain_1.LogsLevel.ERROR) {
                        remoteLogger.raw(dataContainer.getErrorData(wrappedError || err));
                    }
                }
                const returnedPromis = wrappedError
                    ? responsePromise.catch(() => {
                        throw wrappedError;
                    })
                    : responsePromise;
                returnedPromis
                    .then((response) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const tx = getTxFromMethodResponse(response);
                    if (tx) {
                        try {
                            yield tx.wait();
                            yield remoteLogger.raw(yield dataContainer.getTraceData({ method: `${callable.name}.wait` }));
                        }
                        catch (err) {
                            wrappedError = wrapSpecialErrors(err);
                            yield remoteLogger.raw(dataContainer.getErrorData(wrappedError || err, { method: `${callable.name}.wait` }));
                        }
                    }
                }))
                    .catch(() => { });
                return returnedPromis;
            }),
        ];
    });
}
exports.getInternalLoggerMiddleware = getInternalLoggerMiddleware;
function isUnionEthereumTx(original) {
    return sdk_transaction_1.BlockchainEthereumTransaction.isInstance && sdk_transaction_1.BlockchainEthereumTransaction.isInstance(original);
}
function getTxFromMethodResponse(response) {
    //burn, cancel/ buy, transfer
    if (isUnionEthereumTx(response))
        return response;
    //create collection
    if (isUnionEthereumTx(response === null || response === void 0 ? void 0 : response.tx))
        return response.tx;
    //mint
    if (isUnionEthereumTx(response === null || response === void 0 ? void 0 : response.transaction))
        return response.transaction;
    return undefined;
}
function isCallable(fn) {
    var _a;
    return fn instanceof middleware_1.WrappedAdvancedFn || ((_a = fn === null || fn === void 0 ? void 0 : fn.constructor) === null || _a === void 0 ? void 0 : _a.name) === "WrappedAdvancedFn";
}
function getCallableExtraFields(callable) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    try {
        if (typeof (callable === null || callable === void 0 ? void 0 : callable.name) !== "string")
            return {};
        if (isCallable(callable)) {
            const parent = callable.parent;
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.buy.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                const orderId = (0, utils_1.getOrderIdFromFillRequest)(request);
                return {
                    orderId,
                    platform: (_b = (_a = parent === null || parent === void 0 ? void 0 : parent.context) === null || _a === void 0 ? void 0 : _a.orderData) === null || _b === void 0 ? void 0 : _b.platform,
                    collectionId: (_d = (_c = parent === null || parent === void 0 ? void 0 : parent.context) === null || _c === void 0 ? void 0 : _c.orderData) === null || _d === void 0 ? void 0 : _d.nftCollection,
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.batchBuy.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                const orderIds = Array.isArray(request) ? request.map(req => (0, utils_1.getOrderIdFromFillRequest)(req)).join(",") : null;
                const contextData = parent === null || parent === void 0 ? void 0 : parent.context;
                const platforms = Array.isArray(contextData === null || contextData === void 0 ? void 0 : contextData.prepared)
                    ? contextData === null || contextData === void 0 ? void 0 : contextData.prepared.reduce((acc, req) => {
                        var _a, _b;
                        if (((_a = req === null || req === void 0 ? void 0 : req.orderData) === null || _a === void 0 ? void 0 : _a.platform) && !acc.includes((_b = req === null || req === void 0 ? void 0 : req.orderData) === null || _b === void 0 ? void 0 : _b.platform)) {
                            acc.push(req.orderData.platform);
                        }
                        return acc;
                    }, []).join(",")
                    : null;
                const collections = Array.isArray(contextData === null || contextData === void 0 ? void 0 : contextData.prepared)
                    ? contextData === null || contextData === void 0 ? void 0 : contextData.prepared.reduce((acc, req) => {
                        var _a, _b;
                        if (((_a = req === null || req === void 0 ? void 0 : req.orderData) === null || _a === void 0 ? void 0 : _a.nftCollection) && !acc.includes((_b = req === null || req === void 0 ? void 0 : req.orderData) === null || _b === void 0 ? void 0 : _b.nftCollection)) {
                            acc.push(req.orderData.nftCollection);
                        }
                        return acc;
                    }, []).join(",")
                    : null;
                return {
                    orderId: `[${orderIds}]`,
                    platform: `[${platforms}]`,
                    collectionId: `[${collections}]`,
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.bid.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                if (!request)
                    return {};
                return {
                    itemId: "itemId" in request ? request.itemId : undefined,
                    collectionId: "collectionId" in request ? request.collectionId : (0, utils_1.getCollectionFromItemId)(request.itemId),
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.bidUpdate.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                return { orderId: request === null || request === void 0 ? void 0 : request.orderId };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.cancel")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                return { orderId: request === null || request === void 0 ? void 0 : request.orderId };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.sell.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                return {
                    itemId: request === null || request === void 0 ? void 0 : request.itemId,
                    collectionId: request ? (0, utils_1.getCollectionFromItemId)(request.itemId) : undefined,
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.sellUpdate.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                return {
                    orderId: request === null || request === void 0 ? void 0 : request.orderId,
                    collectionId: (_f = (_e = parent === null || parent === void 0 ? void 0 : parent.context) === null || _e === void 0 ? void 0 : _e.orderData) === null || _f === void 0 ? void 0 : _f.nftCollection,
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("order.acceptBid.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                let orderId = (0, utils_1.getOrderIdFromFillRequest)(request);
                return {
                    orderId,
                    collectionId: (_h = (_g = parent === null || parent === void 0 ? void 0 : parent.context) === null || _g === void 0 ? void 0 : _g.orderData) === null || _h === void 0 ? void 0 : _h.nftCollection,
                };
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("nft.transfer.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                if (request === null || request === void 0 ? void 0 : request.itemId) {
                    return {
                        collectionId: (0, utils_1.getCollectionFromItemId)(request.itemId),
                    };
                }
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("nft.mint.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                if (request) {
                    return {
                        collectionId: (0, utils_1.getContractFromMintRequest)(request),
                    };
                }
            }
            if (callable === null || callable === void 0 ? void 0 : callable.name.startsWith("nft.burn.prepare.submit")) {
                const request = parent === null || parent === void 0 ? void 0 : parent.args[0];
                if (request) {
                    return {
                        collectionId: (0, utils_1.getCollectionFromItemId)(request.itemId),
                    };
                }
            }
        }
    }
    catch (e) { }
    return {};
}
exports.getCallableExtraFields = getCallableExtraFields;
function wrapSpecialErrors(err) {
    var _a, _b;
    if ((0, sdk_common_1.isCancelMessage)(err === null || err === void 0 ? void 0 : err.message) || (0, sdk_common_1.isCancelCode)((_a = err === null || err === void 0 ? void 0 : err.error) === null || _a === void 0 ? void 0 : _a.code)) {
        return new sdk_common_1.UserCancelError(err);
    }
    if ((_b = err === null || err === void 0 ? void 0 : err.message) === null || _b === void 0 ? void 0 : _b.includes(sdk_common_2.INVALID_TX_PARAMS_EIP_1559_ERROR)) {
        return new sdk_common_2.WrappedError(exports.HUMAN_READABLE_MSG_LIST[sdk_common_2.INVALID_TX_PARAMS_EIP_1559_ERROR], err);
    }
}
exports.HUMAN_READABLE_MSG_LIST = {
    [sdk_common_2.INVALID_TX_PARAMS_EIP_1559_ERROR]: "The problem is with the selected network of your wallet provider, try switching the network or re-entering the wallet. You can read more about this error [here](https://github.com/MetaMask/metamask-extension/issues/13341)",
};
