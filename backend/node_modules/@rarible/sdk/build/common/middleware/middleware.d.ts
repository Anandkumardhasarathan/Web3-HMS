import { Action } from "@rarible/action";
import CallableInstance from "callable-instance";
import { MethodWithPrepare } from "../../types/common";
import type { PreparedFillInfo } from "../../types/order/fill/domain";
/**
 * Middleware function type
 * Middleware function gets `callable` method and arguments with which it will be called.
 * Must return a Promise which will resolve as array [(new) function, callback]
 * 	where:
 * 		function - original method, or replace for it (f.e. wrapped).
 * 		callback - function which will be called with "promisified" result of execution `callable`,
 * 			should return received promise, new promise, or new result value
 */
export type Middleware<Callable extends (...args: any[]) => any = (...args: any[]) => any> = (callable: Callable, args: Parameters<Callable>) => Promise<[
    (...args: Parameters<Callable>) => ReturnType<Callable>,
    ((p: Promise<ReturnType<Callable>>) => Promise<ReturnType<Callable>>) | void
]>;
export declare class WrappedAdvancedFn<T extends (...args: any) => any = (...args: any[]) => any> extends CallableInstance<Parameters<T>, ReturnType<T>> {
    fn: T;
    args: Parameters<T>;
    parent?: WrappedAdvancedFn<T>;
    name?: string;
    context?: PreparedFillInfo;
    constructor(fn: T, args: Parameters<T>, o?: {
        parent?: WrappedAdvancedFn<T>;
        name?: string;
    });
    private fnCallable;
    setContext(context: PreparedFillInfo): void;
    static isWrappedAdvancedFn(instance: any): instance is WrappedAdvancedFn;
    static getParent(instance: any): WrappedAdvancedFn | undefined;
}
export declare class Middlewarer {
    private middlewares;
    /**
     * Add middleware to chain
     */
    use(middleware: Middleware): this;
    /**
     * Call method with middlewares chain
     *
     * @param callable - original method for call
     * @param ...args - callable arguments
     */
    call<Fun extends (...args: any[]) => Promise<any>>(callable: Fun, { args, parent, saveContext, }: {
        args: Parameters<Fun>;
        parent?: WrappedAdvancedFn;
        saveContext?: boolean;
    }): Promise<ReturnType<Fun>>;
    /**
     * Wrap function to execute with middlewares in future
     * @example
     * 	function fn(i: number) { ... }
     * 	const wrappedFn = middlewarer.wrap(fn)
     * 	fn(10)
     *
     * @param callable
     * @param meta metadata for new method
     */
    wrap<Fun extends (...args: any[]) => Promise<any> | MethodWithPrepare<any, any>>(callable: Fun, meta?: {
        methodName?: string;
        parent?: WrappedAdvancedFn;
    }): ((...args: Parameters<Fun>) => ReturnType<Fun>) | Fun;
    wrapMethodWithPrepare<T extends MethodWithPrepare<any, any>>(method: T, fnName: string): T;
    wrapFunction<T extends (...args: any) => any>(callable: T, fnName: string, { saveContext, parent, }?: {
        saveContext?: boolean;
        parent?: WrappedAdvancedFn;
    }): T;
    wrapAction<T extends Action<any, any, any>>(action: T, fnName: string, { parent }?: {
        parent?: WrappedAdvancedFn;
    }): T;
    /**
     * Wrap all methods in object
     *
     * @param object
     * @param meta metadata for new method
     */
    wrapObjectMethods(object: any, meta: {
        namespace: string;
    }): void;
    /**
     * Wrap methods in api controller
     *
     * @param object
     * @param meta metadata for new method
     */
    wrapApiControllerMethods(object: any, meta: {
        namespace: string;
    }): void;
    static skipMiddleware<T extends Function>(something: T): T & {
        skipMiddleware: true;
    };
}
