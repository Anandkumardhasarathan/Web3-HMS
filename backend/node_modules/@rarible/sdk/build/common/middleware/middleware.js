"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Middlewarer = exports.WrappedAdvancedFn = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const callable_instance_1 = tslib_1.__importDefault(require("callable-instance"));
const common_1 = require("../../types/common");
const utils_1 = require("./utils");
const SKIP_MIDDLEWARE = Symbol("SKIP_MIDDLEWARE");
class WrappedAdvancedFn extends callable_instance_1.default {
    constructor(fn, args, o = {}) {
        super("fnCallable");
        this.fn = fn;
        this.args = args;
        this.parent = o === null || o === void 0 ? void 0 : o.parent;
        Object.defineProperty(this, "name", { value: o.name || "fnCallable", writable: false });
        return this;
    }
    fnCallable(...args) {
        return this.fn(...args);
    }
    setContext(context) {
        this.context = context;
    }
    static isWrappedAdvancedFn(instance) {
        return instance instanceof WrappedAdvancedFn;
    }
    static getParent(instance) {
        if (!instance)
            return undefined;
        if (instance instanceof WrappedAdvancedFn || instance.constructor.name === "WrappedAdvancedFn") {
            return instance.getParent();
        }
    }
}
exports.WrappedAdvancedFn = WrappedAdvancedFn;
class Middlewarer {
    constructor() {
        this.middlewares = [];
    }
    /**
     * Add middleware to chain
     */
    use(middleware) {
        this.middlewares.push(middleware);
        return this;
    }
    /**
     * Call method with middlewares chain
     *
     * @param callable - original method for call
     * @param ...args - callable arguments
     */
    call(callable_1, _a) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (callable, { args, parent, saveContext, }) {
            let wrappedCallable = callable;
            const callbacks = [];
            if (saveContext || !!parent) {
                wrappedCallable = new WrappedAdvancedFn(wrappedCallable, args, {
                    parent,
                    name: callable.name,
                });
            }
            for (const mid of this.middlewares) {
                let cb = undefined;
                [wrappedCallable, cb] = yield mid(wrappedCallable, args);
                if (cb) {
                    callbacks.push(cb);
                }
            }
            let res = (0, utils_1.toPromise)(wrappedCallable(...args));
            for (const mid of callbacks) {
                res = (0, utils_1.toPromise)(mid(res));
            }
            const result = yield res;
            // wrapping submit methods
            if (typeof (result === null || result === void 0 ? void 0 : result.submit) === "function") {
                wrappedCallable.setContext(result);
                result.submit = this.wrap(result.submit, {
                    methodName: callable.name + ".submit",
                    parent: WrappedAdvancedFn.isWrappedAdvancedFn(wrappedCallable) ? wrappedCallable : undefined,
                });
            }
            return result;
        });
    }
    /**
     * Wrap function to execute with middlewares in future
     * @example
     * 	function fn(i: number) { ... }
     * 	const wrappedFn = middlewarer.wrap(fn)
     * 	fn(10)
     *
     * @param callable
     * @param meta metadata for new method
     */
    wrap(callable, meta = {}) {
        if (callable.hasOwnProperty(SKIP_MIDDLEWARE)) {
            return callable;
        }
        const fnName = (meta === null || meta === void 0 ? void 0 : meta.methodName) || callable.name || "anonymous";
        if (isAction(callable)) {
            this.wrapAction(callable, fnName, { parent: meta.parent });
            return callable;
        }
        else if (isMethodWithPrepare(callable)) {
            return this.wrapMethodWithPrepare(callable, fnName);
        }
        else {
            return this.wrapFunction(callable, fnName, { parent: meta.parent });
        }
    }
    wrapMethodWithPrepare(method, fnName) {
        const wrappedMethod = this.wrapFunction(method, fnName);
        wrappedMethod.prepare = this.wrapFunction(method.prepare, `${fnName}.prepare`, {
            saveContext: true,
        });
        return wrappedMethod;
    }
    wrapFunction(callable, fnName, { saveContext, parent, } = {}) {
        Object.defineProperty(callable, "name", { value: fnName, writable: false });
        return ((...args) => this.call(callable, { args, saveContext, parent }));
    }
    wrapAction(action, fnName, { parent } = {}) {
        // @ts-ignore
        for (let step of action.steps) {
            const originRun = step.run;
            step.run = (...args) => this.call(originRun, { args, parent });
            Object.defineProperty(originRun, "name", { value: fnName + "." + step.id, writable: false });
        }
        return action;
    }
    /**
     * Wrap all methods in object
     *
     * @param object
     * @param meta metadata for new method
     */
    wrapObjectMethods(object, meta) {
        for (const prop in object) {
            if (object.hasOwnProperty(prop) && typeof object[prop] === "function") {
                object[prop] = this.wrap(object[prop], {
                    methodName: (meta.namespace ? meta.namespace + "." : "") + prop,
                });
            }
        }
    }
    /**
     * Wrap methods in api controller
     *
     * @param object
     * @param meta metadata for new method
     */
    wrapApiControllerMethods(object, meta) {
        const IGNORED_PROPS = [
            "configuration",
            "fetchApi",
            "middleware",
            "constructor",
            "withMiddleware",
            "withPreMiddleware",
            "withPostMiddleware",
            "request",
            "createFetchParams",
            "clone",
        ];
        for (const prop in object) {
            if (!IGNORED_PROPS.includes(prop) && !prop.endsWith("Raw") && typeof object[prop] === "function") {
                object[prop] = this.wrap(object[prop].bind(object), {
                    methodName: (meta.namespace ? meta.namespace + "." : "") + prop,
                });
            }
        }
    }
    static skipMiddleware(something) {
        return Object.defineProperty(something, SKIP_MIDDLEWARE, { value: true, writable: false });
    }
}
exports.Middlewarer = Middlewarer;
function isAction(fn) {
    return fn instanceof action_1.Action || (fn && "after" in fn && "before" in fn && "start" in fn);
}
function isMethodWithPrepare(fn) {
    return fn instanceof common_1.MethodWithPrepare || (fn && "simplifiedMethod" in fn && "prepare" in fn);
}
