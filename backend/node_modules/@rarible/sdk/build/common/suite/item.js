"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemTestSuite = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const extract_blockchain_1 = require("../extract-blockchain");
const wait_for_1 = require("../wait-for");
class ItemTestSuite {
    constructor(blockchain, sdk, provider) {
        this.blockchain = blockchain;
        this.sdk = sdk;
        this.provider = provider;
        this.mintAndWait = (collectionId_1, ...args_1) => tslib_1.__awaiter(this, [collectionId_1, ...args_1], void 0, function* (collectionId, override = {}) {
            const common = yield this.createDefaultMintValues(this.blockchain, collectionId);
            const config = Object.assign(Object.assign({ lazyMint: false }, common), override);
            const result = yield this.sdk.nft.mint(config);
            yield result.transaction.wait();
            yield this.waitItem(result.itemId, config.supply);
            return result;
        });
        this.waitItem = (itemId, supply) => {
            return (0, wait_for_1.waitFor)(() => this.sdk.apis.item.getItemById({ itemId }), x => {
                if (supply)
                    return x.supply.toString() === supply.toString();
                return false;
            });
        };
        this.mintLazyAndWait = (collectionId_2, ...args_2) => tslib_1.__awaiter(this, [collectionId_2, ...args_2], void 0, function* (collectionId, override = {}) {
            const common = yield this.createDefaultMintValues(this.blockchain, collectionId);
            const config = Object.assign(Object.assign({ lazyMint: true }, common), override);
            const result = yield this.sdk.nft.mint(config);
            yield this.waitItem(result.itemId, config.supply);
            return result;
        });
    }
    createDefaultMintValues(blockchain, collectionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const creatorAddressString = yield this.provider.getFrom();
            const blockchainGroup = (0, extract_blockchain_1.toBlockchainGroup)(blockchain);
            const creatorAddress = (0, types_1.toUnionAddress)(`${blockchainGroup}:${creatorAddressString}`);
            return {
                uri: "ipfs://ipfs/QmfVqzkQcKR1vCNqcZkeVVy94684hyLki7QcVzd9rmjuG5",
                collectionId,
                creators: [
                    {
                        account: creatorAddress,
                        value: 10000,
                    },
                ],
                royalties: [],
                supply: 1,
            };
        });
    }
}
exports.ItemTestSuite = ItemTestSuite;
