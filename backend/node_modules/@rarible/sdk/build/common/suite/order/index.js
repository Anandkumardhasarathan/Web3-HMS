"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateExpirationDate = exports.OrderTestSuite = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const match_subset_1 = require("../../match-subset");
const wait_for_1 = require("../../wait-for");
const extract_blockchain_1 = require("../../extract-blockchain");
class OrderTestSuite {
    constructor(blockchain, sdk, ownerships) {
        this.blockchain = blockchain;
        this.sdk = sdk;
        this.ownerships = ownerships;
        this.sellWithPrepare = (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.sdk.order.sell.prepare({ itemId: request.itemId });
            const price = (0, utils_1.toBn)(request.price);
            const quantity = (0, utils_1.toBn)(request.quantity || 1);
            const orderId = yield response.submit({
                currency: request.currency,
                originFees: request.originFees,
                expirationDate: request.expiration || generateExpirationDate(),
                price: price.toString(),
                amount: quantity.toNumber(),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(quantity.toString()),
                makePrice: (0, types_1.toBigNumber)(price.toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return orderId;
        });
        this.sell = (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const price = (0, utils_1.toBn)(request.price);
            const quantity = (0, utils_1.toBn)(request.quantity || 1);
            const orderId = yield this.sdk.order.sell({
                itemId: request.itemId,
                currency: request.currency,
                originFees: request.originFees,
                expirationDate: request.expiration || generateExpirationDate(),
                price: price.toString(),
                amount: quantity.toNumber(),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(quantity.toString()),
                makePrice: (0, types_1.toBigNumber)(price.toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return orderId;
        });
        this.sellUpdate = (orderId, nextPrice) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepared = yield this.sdk.order.sellUpdate.prepare({ orderId });
            const order = yield this.sdk.apis.order.getOrderById({ id: orderId });
            const updatedOrderId = yield prepared.submit({ price: (0, utils_1.toBn)(nextPrice).toString() });
            const nextPriceBn = (0, utils_1.toBn)(nextPrice);
            const total = nextPriceBn.multipliedBy(order.make.value);
            yield this.waitOrderSubset(orderId, {
                makePrice: (0, types_1.toBigNumber)(nextPrice.toString()),
                take: {
                    value: (0, types_1.toBigNumber)(total.toString()),
                    type: order.take.type,
                },
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return updatedOrderId;
        });
        this.bidWithPrepare = (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.sdk.order.bid.prepare({ itemId: request.itemId });
            const price = (0, utils_1.toBn)(request.price);
            const quantity = (0, utils_1.toBn)(request.quantity || 1);
            const orderId = yield response.submit({
                currency: request.currency,
                originFees: request.originFees,
                expirationDate: request.expiration || generateExpirationDate(),
                price: price.toString(),
                amount: quantity.toNumber(),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(price.multipliedBy(quantity).toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return orderId;
        });
        this.bid = (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const price = (0, utils_1.toBn)(request.price);
            const quantity = (0, utils_1.toBn)(request.quantity || 1);
            const orderId = yield this.sdk.order.bid({
                itemId: request.itemId,
                currency: request.currency,
                originFees: request.originFees,
                expirationDate: request.expiration || generateExpirationDate(),
                price: price.toString(),
                amount: quantity.toNumber(),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(price.multipliedBy(quantity).toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return orderId;
        });
        this.bidByCollection = (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const price = (0, utils_1.toBn)(request.price);
            const quantity = (0, utils_1.toBn)(request.quantity || 1);
            const response = yield this.sdk.order.bid.prepare({
                collectionId: request.collectionId,
            });
            const orderId = yield response.submit({
                currency: request.currency,
                originFees: request.originFees,
                expirationDate: request.expiration || generateExpirationDate(),
                price: price.toString(),
                amount: quantity.toNumber(),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(price.multipliedBy(quantity).toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return orderId;
        });
        this.updateBidByPrepare = (orderId, nextPrice) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.sdk.order.bidUpdate.prepare({ orderId });
            const order = yield this.sdk.apis.order.getOrderById({ id: orderId });
            const nextPriceBn = (0, utils_1.toBn)(nextPrice);
            const total = nextPriceBn.multipliedBy(order.take.value);
            const updatedOrderId = yield response.submit({
                price: nextPriceBn.toString(),
            });
            yield this.waitOrderSubset(orderId, {
                takePrice: (0, types_1.toBigNumber)(nextPrice.toString()),
                make: {
                    value: (0, types_1.toBigNumber)(total.toString()),
                    type: order.make.type,
                },
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return updatedOrderId;
        });
        this.updateBid = (orderId, nextPrice) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const updatedOrderId = yield this.sdk.order.bidUpdate({
                orderId,
                price: (0, utils_1.toBn)(nextPrice),
            });
            yield this.waitOrderSubset(orderId, {
                makeStock: (0, types_1.toBigNumber)(nextPrice.toString()),
                status: api_client_1.OrderStatus.ACTIVE,
            });
            return updatedOrderId;
        });
        this.acceptBid = (itemId, orderId, quantity) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.sdk.apis.order.getOrderById({ id: orderId });
            const response = yield this.sdk.order.acceptBid.prepare({ orderId });
            const quantityBn = (0, utils_1.toBn)(quantity);
            const tx = yield response.submit({
                amount: quantityBn.toNumber(),
                infiniteApproval: true,
                itemId,
            });
            yield tx.wait();
            yield this.ownerships.waitForNewOwnership(itemId, (0, extract_blockchain_1.extractId)(order.maker));
            const alreadyFilled = (0, utils_1.toBn)(order.fill || 0);
            yield this.waitOrderSubset(orderId, {
                fill: (0, types_1.toBigNumber)(quantityBn.plus(alreadyFilled).toString()),
            });
            const filled = alreadyFilled.plus(quantityBn);
            const remain = (0, utils_1.toBn)(order.take.value).minus(filled);
            yield this.waitOrderSubset(orderId, {
                status: remain.isGreaterThan(0) ? api_client_1.OrderStatus.ACTIVE : api_client_1.OrderStatus.FILLED,
                makeStock: (0, types_1.toBigNumber)(remain.multipliedBy(order.takePrice).toString()),
            });
        });
        this.cancelOrder = (orderId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tx = yield this.sdk.order.cancel({ orderId });
            yield tx.wait();
            yield this.waitOrderSubset(orderId, {
                status: api_client_1.OrderStatus.CANCELLED,
                makeStock: (0, types_1.toBigNumber)("0"),
            });
        });
        this.waitOrder = (orderHash, predicate) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, wait_for_1.waitFor)(() => this.sdk.apis.order.getOrderById({ id: orderHash }), predicate);
        });
        this.waitOrderSubset = (orderHash, subset) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.waitOrder(orderHash, x => (0, match_subset_1.subsetMatch)(x, subset));
        });
        this.waitStatus = (orderHash, status) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.waitOrderSubset(orderHash, { status });
        });
    }
}
exports.OrderTestSuite = OrderTestSuite;
function generateExpirationDate(seconds = 3600) {
    return new Date(Date.now() + seconds * 1000);
}
exports.generateExpirationDate = generateExpirationDate;
