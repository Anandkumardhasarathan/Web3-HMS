"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNativeToken = exports.convertSupportedBlockchainToUnion = exports.extractUnionSupportedBlockchain = exports.getOrderId = exports.getBidEntity = exports.getContractFromMintRequest = exports.getCollectionFromItemId = exports.getItemIdData = exports.getOrderNftContractAddress = exports.getNftContractAddress = exports.getOrderIdFromFillRequest = void 0;
const types_1 = require("@rarible/types");
const sdk_common_1 = require("@rarible/sdk-common");
const api_client_1 = require("@rarible/api-client");
function getOrderIdFromFillRequest(req) {
    var _a;
    if (!req)
        return undefined;
    if ("orderId" in req) {
        return req === null || req === void 0 ? void 0 : req.orderId;
    }
    else if ("order" in req) {
        return (_a = req === null || req === void 0 ? void 0 : req.order) === null || _a === void 0 ? void 0 : _a.id;
    }
}
exports.getOrderIdFromFillRequest = getOrderIdFromFillRequest;
function getNftContractAddress(assetType) {
    switch (assetType["@type"]) {
        case "FLOW_NFT":
        case "TEZOS_NFT":
        case "ERC721":
        case "ERC721_Lazy":
        case "ERC1155":
        case "ERC1155_Lazy":
        case "CRYPTO_PUNKS":
        case "GEN_ART":
        case "COLLECTION":
        case "AMM_NFT":
            return assetType.contract;
        case "NFT":
        case "NFT_OF_COLLECTION":
            return (0, types_1.toUnionContractAddress)(assetType.collectionId);
        default:
            return undefined;
    }
}
exports.getNftContractAddress = getNftContractAddress;
function getOrderNftContractAddress(order) {
    return getNftContractAddress(order.make.type) || getNftContractAddress(order.take.type);
}
exports.getOrderNftContractAddress = getOrderNftContractAddress;
function getItemIdData(itemId) {
    if (!itemId) {
        throw new Error(`Not an item: ${itemId}`);
    }
    const [blockchain, address, tokenId] = itemId.split(":");
    if (blockchain === api_client_1.Blockchain.APTOS) {
        return {
            tokenId: tokenId,
            blockchain,
        };
    }
    return {
        collection: (0, types_1.toCollectionId)(`${blockchain}:${address}`),
        contract: address,
        tokenId: tokenId,
        blockchain,
    };
}
exports.getItemIdData = getItemIdData;
function getCollectionFromItemId(itemId) {
    const { collection } = getItemIdData(itemId);
    return collection;
}
exports.getCollectionFromItemId = getCollectionFromItemId;
function getContractFromMintRequest(request) {
    if ("collection" in request)
        return request.collection.id;
    if ("collectionId" in request)
        return request.collectionId;
    throw new Error("Wrong request: collection or collectionId has not been found");
}
exports.getContractFromMintRequest = getContractFromMintRequest;
function getBidEntity(request) {
    if ("itemId" in request) {
        return request.itemId;
    }
    else if ("collectionId" in request) {
        return request.collectionId;
    }
    else {
        throw new Error("Bit request should contains itemId or collectionId");
    }
}
exports.getBidEntity = getBidEntity;
function getOrderId(req) {
    if ("order" in req) {
        return req.order.id;
    }
    else if ("orderId" in req) {
        return req.orderId;
    }
    throw new Error("OrderId has not been found in request");
}
exports.getOrderId = getOrderId;
function extractUnionSupportedBlockchain(value) {
    const blockchain = (0, sdk_common_1.extractBlockchain)(value);
    return convertSupportedBlockchainToUnion(blockchain);
}
exports.extractUnionSupportedBlockchain = extractUnionSupportedBlockchain;
function convertSupportedBlockchainToUnion(blockchain) {
    if ((0, sdk_common_1.isEVMBlockchain)(blockchain)) {
        return "EVM";
    }
    return blockchain;
}
exports.convertSupportedBlockchainToUnion = convertSupportedBlockchainToUnion;
function isNativeToken(assetType) {
    return assetType["@type"] === "CURRENCY_NATIVE";
}
exports.isNativeToken = isNativeToken;
