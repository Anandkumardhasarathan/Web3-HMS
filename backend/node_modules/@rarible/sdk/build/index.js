"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSimpleFlowFungibleBalance = exports.WalletType = exports.getCollectionId = exports.createRaribleSdk = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const sdk_wallet_1 = require("@rarible/sdk-wallet");
Object.defineProperty(exports, "WalletType", { enumerable: true, get: function () { return sdk_wallet_1.WalletType; } });
const utils_1 = require("@rarible/utils");
const sdk_common_1 = require("@rarible/sdk-common");
const web3_js_1 = require("@solana/web3.js");
const domain_1 = require("./domain");
const config_1 = require("./config");
const prepare_1 = require("./types/nft/mint/prepare");
const ethereum_1 = require("./sdk-blockchains/ethereum");
const tezos_1 = require("./sdk-blockchains/tezos");
const union_1 = require("./sdk-blockchains/union");
const apis_1 = require("./common/apis");
const middleware_1 = require("./common/middleware/middleware");
const logger_middleware_1 = require("./common/logger/logger-middleware");
const solana_1 = require("./sdk-blockchains/solana");
const immutablex_1 = require("./sdk-blockchains/immutablex");
const common_1 = require("./types/common");
const get_sdk_context_1 = require("./common/get-sdk-context");
const flow_1 = require("./sdk-blockchains/flow");
const check_royalties_1 = require("./common/check-royalties");
const utils_2 = require("./common/utils");
const aptos_1 = require("./sdk-blockchains/aptos");
const eclipse_1 = require("./sdk-blockchains/eclipse");
/**
 * @module
 */
/**
 * Rarible sdk creation function
 *
 * @param provider undefined or BlockchainWallet
 * wallet can instantiate from @rarible/sdk-wallet package
 * @param env the environment that the sdk will interact with.
 * @param [config] config
 * @returns {IRaribleSdk} {@link IRaribleSdk}
 *
 * @example
 * ```typescript
 *    const web3 = new Web3(provider)
 *    const sdk = createRaribleSdk(web3, "prod")
 * ```
 */
function createRaribleSdk(provider, env, config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const wallet = provider && (0, sdk_wallet_1.getRaribleWallet)(provider);
    const sessionId = (0, utils_1.getRandomId)("union");
    const blockchainConfig = (0, config_1.getSdkConfig)(env);
    const apis = (0, apis_1.createApisSdk)(env, Object.assign(Object.assign({}, ((config === null || config === void 0 ? void 0 : config.apiClientParams) || {})), { apiKey: config === null || config === void 0 ? void 0 : config.apiKey }), config === null || config === void 0 ? void 0 : config.logs);
    const ethConfig = Object.assign(Object.assign({}, (_a = config === null || config === void 0 ? void 0 : config.blockchain) === null || _a === void 0 ? void 0 : _a.ETHEREUM), { params: config === null || config === void 0 ? void 0 : config.apiClientParams, logs: (config === null || config === void 0 ? void 0 : config.logs) ? { level: config === null || config === void 0 ? void 0 : config.logs, session: sessionId } : { level: domain_1.LogsLevel.TRACE, session: sessionId }, apiKey: config === null || config === void 0 ? void 0 : config.apiKey });
    const instance = (0, union_1.createUnionSdk)((0, ethereum_1.createEthereumSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.ETHEREUM), apis, api_client_1.Blockchain.ETHEREUM, blockchainConfig.ethereumEnv, ethConfig), (0, flow_1.createFlowSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.FLOW), apis, blockchainConfig.flowEnv, undefined, config), (0, tezos_1.createTezosSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.TEZOS), apis, blockchainConfig, config), (0, solana_1.createSolanaSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.SOLANA), apis, blockchainConfig.solanaNetwork, (_b = config === null || config === void 0 ? void 0 : config.blockchain) === null || _b === void 0 ? void 0 : _b.SOLANA), (0, eclipse_1.createEclipseSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.SOLANA), apis, blockchainConfig.solanaNetwork, {
        eclipseEndpoint: (_e = (_d = (_c = config === null || config === void 0 ? void 0 : config.blockchain) === null || _c === void 0 ? void 0 : _c.SOLANA) === null || _d === void 0 ? void 0 : _d.eclipseEndpoint) !== null && _e !== void 0 ? _e : blockchainConfig.eclipseAddress,
        eclipseMarketplaces: (((_g = (_f = config === null || config === void 0 ? void 0 : config.blockchain) === null || _f === void 0 ? void 0 : _f.SOLANA) === null || _g === void 0 ? void 0 : _g.eclipseMarketplaces) || []).map(val => new web3_js_1.PublicKey(val)),
    }, config === null || config === void 0 ? void 0 : config.logs), (0, immutablex_1.createImmutablexSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.IMMUTABLEX), apis, blockchainConfig.immutablexNetwork, config === null || config === void 0 ? void 0 : config.logs), (0, aptos_1.createAptosSdk)(filterWallet(wallet, sdk_wallet_1.WalletType.APTOS), apis, blockchainConfig.aptosNetwork, (_h = config === null || config === void 0 ? void 0 : config.blockchain) === null || _h === void 0 ? void 0 : _h.APTOS));
    const sdkContext = {
        wallet,
        env,
        config,
        sessionId,
        apiKey: config === null || config === void 0 ? void 0 : config.apiKey,
        providerId: (_j = config === null || config === void 0 ? void 0 : config.context) === null || _j === void 0 ? void 0 : _j.providerId,
        providerMeta: (_k = config === null || config === void 0 ? void 0 : config.context) === null || _k === void 0 ? void 0 : _k.providerMeta,
    };
    setupMiddleware({
        apis,
        internalSdk: instance,
        sdkContext,
        externalLogger: config === null || config === void 0 ? void 0 : config.logger,
    });
    return Object.assign(Object.assign({}, instance), { nft: Object.assign(Object.assign({}, instance.nft), { mintAndSell: createMintAndSell(instance.nft.mint, instance.order.sell, apis) }), order: Object.assign(Object.assign({}, instance.order), { sell: createSell(instance.order.sell, apis) }), apis,
        wallet, getSdkContext: get_sdk_context_1.getSdkContext.bind(null, sdkContext) });
}
exports.createRaribleSdk = createRaribleSdk;
/**
 * Create middleware controller & wrap methods
 */
function setupMiddleware({ apis, internalSdk, sdkContext, externalLogger }) {
    var _a, _b, _c, _d, _e;
    const middlewarer = new middleware_1.Middlewarer();
    if (((_a = sdkContext.config) === null || _a === void 0 ? void 0 : _a.logs) !== domain_1.LogsLevel.DISABLED) {
        middlewarer.use((0, logger_middleware_1.getInternalLoggerMiddleware)((_c = (_b = sdkContext.config) === null || _b === void 0 ? void 0 : _b.logs) !== null && _c !== void 0 ? _c : domain_1.LogsLevel.TRACE, sdkContext, externalLogger));
    }
    for (const middleware of (_e = (_d = sdkContext.config) === null || _d === void 0 ? void 0 : _d.middlewares) !== null && _e !== void 0 ? _e : []) {
        middlewarer.use(middleware);
    }
    for (const prop in apis) {
        //@ts-ignore
        //todo: better wrap for apis methods
        middlewarer.wrapApiControllerMethods(apis[prop], { namespace: "apis." + prop });
    }
    for (const prop in internalSdk) {
        //@ts-ignore
        middlewarer.wrapObjectMethods(internalSdk[prop], { namespace: prop });
    }
}
function filterWallet(wallet, blockchainType) {
    if ((wallet === null || wallet === void 0 ? void 0 : wallet.walletType) === blockchainType) {
        return wallet;
    }
    return undefined;
}
function createSell(sell, apis) {
    return new common_1.MethodWithPrepare(request => sell(request), (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { item, collection } = yield getSellItemData(request.itemId, apis);
        if (collection === null || collection === void 0 ? void 0 : collection.self) {
            yield (0, check_royalties_1.checkRoyalties)(request.itemId, apis);
        }
        const response = yield sell.prepare(Object.assign(Object.assign({}, request), { blockchain: (0, sdk_common_1.extractBlockchain)(request.itemId), withOriginFees: request.withOriginFees }));
        return Object.assign(Object.assign({}, response), { maxAmount: item.supply, submit: response.submit.before((input) => (Object.assign({ itemId: request.itemId }, input))) });
    }));
}
/*
  Get Item and Collection object in parallel or consistent requests depends on blockhain ItemId
 */
function getSellItemData(itemId, apis) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        const blockchain = (0, sdk_common_1.extractBlockchain)(itemId);
        if ([api_client_1.Blockchain.APTOS, api_client_1.Blockchain.SOLANA, api_client_1.Blockchain.ECLIPSE].includes(blockchain)) {
            const item = yield apis.item.getItemById({ itemId });
            let collection;
            const collectionId = item.collection || ((_a = item.itemCollection) === null || _a === void 0 ? void 0 : _a.id);
            if (collectionId) {
                collection = yield apis.collection.getCollectionById({
                    collection: collectionId,
                });
            }
            return { item, collection };
        }
        const [item, collection] = yield Promise.all([
            apis.item.getItemById({ itemId }),
            apis.collection.getCollectionById({ collection: (0, utils_2.getCollectionFromItemId)(itemId) }),
        ]);
        return { item, collection };
    });
}
function createMintAndSell(mint, sell, apis) {
    // @ts-expect-error
    return new common_1.MethodWithPrepare((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mintResponse = yield mint(request);
        if (mintResponse.type === prepare_1.MintType.ON_CHAIN) {
            yield mintResponse.transaction.wait();
        }
        yield (0, sdk_common_1.retry)(90, 2000, () => apis.item.getItemById({ itemId: mintResponse.itemId }));
        const { supply } = request, restRequest = tslib_1.__rest(request, ["supply"]);
        const orderId = yield sell(Object.assign(Object.assign({}, restRequest), { amount: supply, itemId: mintResponse.itemId }));
        return Object.assign(Object.assign({}, mintResponse), { orderId });
    }), (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const mintResponse = yield mint.prepare(request);
        const collectionId = getCollectionId(request);
        const blockchain = getBlockchainCollectionId(collectionId);
        const sellResponse = yield sell.prepare({ blockchain });
        const mintAction = mintResponse.submit.around((input) => (Object.assign({}, input)), (mintResponse, initial) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (mintResponse.type === prepare_1.MintType.ON_CHAIN) {
                yield mintResponse.transaction.wait();
            }
            yield (0, sdk_common_1.retry)(90, 2000, () => apis.item.getItemById({ itemId: mintResponse.itemId }));
            return { initial, mintResponse };
        }));
        const sellAction = sellResponse.submit.around(({ initial, mintResponse }) => (Object.assign(Object.assign({}, initial), { itemId: mintResponse.itemId, amount: initial.supply })), (orderId, { mintResponse }) => (Object.assign(Object.assign({}, mintResponse), { orderId })));
        return Object.assign(Object.assign(Object.assign({}, mintResponse), sellResponse), { submit: mintAction.thenAction(sellAction) });
    }));
}
/**
 * @internal
 */
function getCollectionId(req) {
    if ("collection" in req) {
        return req.collection.id;
    }
    return req.collectionId;
}
exports.getCollectionId = getCollectionId;
function getBlockchainCollectionId(contract) {
    const [blockchain] = contract.split(":");
    if (!(0, sdk_common_1.isSupportedBlockchain)(blockchain)) {
        throw new Error(`Unrecognized blockchain in contract ${contract}`);
    }
    return blockchain;
}
var balance_simple_1 = require("./sdk-blockchains/flow/balance-simple");
Object.defineProperty(exports, "getSimpleFlowFungibleBalance", { enumerable: true, get: function () { return balance_simple_1.getSimpleFlowFungibleBalance; } });
