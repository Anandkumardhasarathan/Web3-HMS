"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosBid = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const sdk_common_1 = require("@rarible/sdk-common");
const utils_1 = require("@rarible/utils");
const aptos_sdk_1 = require("@rarible/aptos-sdk");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const types_1 = require("@rarible/types");
const domain_1 = require("../../types/order/fill/domain");
const utils_2 = require("../../common/utils");
const get_expiration_date_1 = require("../../common/get-expiration-date");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const common_1 = require("./common");
class AptosBid {
    constructor(sdk, network, apis) {
        this.sdk = sdk;
        this.network = network;
        this.apis = apis;
        this.bid = this.bid.bind(this);
        this.bidBasic = this.bidBasic.bind(this);
        this.acceptBid = this.acceptBid.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
    }
    bid(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const item = "itemId" in prepare ? yield this.apis.item.getItemById({ itemId: prepare.itemId }) : null;
            const prepareCollectionId = "collectionId" in prepare ? (0, types_1.toUnionContractAddress)(prepare.collectionId) : undefined;
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c;
                    if (request.originFees && request.originFees.length > 1) {
                        throw new Error("Origin fees should consist only 1 item");
                    }
                    const feeObject = yield this.sdk.order.getFeeObject(((_a = request.originFees) === null || _a === void 0 ? void 0 : _a.length)
                        ? {
                            address: (0, sdk_common_1.extractId)(request.originFees[0].account),
                            value: request.originFees[0].value,
                        }
                        : undefined);
                    const currencyAssetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
                    if (currencyAssetType["@type"] !== "CURRENCY_NATIVE") {
                        throw new Error("Only native token currency is available for bid operation");
                    }
                    const expirationDate = request.expirationDate
                        ? (0, get_expiration_date_1.convertDateToTimestamp)(request.expirationDate)
                        : (0, get_expiration_date_1.getDefaultExpirationDateTimestamp)();
                    const collection = yield this.apis.collection.getCollectionById({
                        collection: item ? item.collection : prepareCollectionId,
                    });
                    if ("itemId" in prepare) {
                        if (((_b = collection.extra) === null || _b === void 0 ? void 0 : _b.standard) === "v1") {
                            if (!(item === null || item === void 0 ? void 0 : item.extra)) {
                                throw new Error("No extra field in API item");
                            }
                            const orderId = yield this.sdk.order.tokenOfferV1((0, sdk_common_1.extractId)(item.creators[0].account), item.extra.onChainCollectionName, item.extra.onChainTokenName, item.extra.propertyVersionV1, feeObject, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed(), expirationDate);
                            return (0, common_1.convertAptosToUnionOrderId)(orderId);
                        }
                        else {
                            const orderId = yield this.sdk.order.tokenOffer((0, sdk_common_1.extractId)(prepare.itemId), feeObject, expirationDate, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed());
                            return (0, common_1.convertAptosToUnionOrderId)(orderId);
                        }
                    }
                    else if ("collectionId" in prepare) {
                        if (((_c = collection.extra) === null || _c === void 0 ? void 0 : _c.standard) === "v1") {
                            const orderId = yield this.sdk.order.collectionOfferV1((0, sdk_common_1.extractId)(collection.owner), collection.name, feeObject, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed(), request.amount || 1, expirationDate);
                            return (0, common_1.convertAptosToUnionOrderId)(orderId);
                        }
                        else {
                            const orderId = yield this.sdk.order.collectionOffer((0, sdk_common_1.extractId)(prepare["collectionId"]), request.amount || 1, feeObject, expirationDate, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed());
                            return (0, common_1.convertAptosToUnionOrderId)(orderId);
                        }
                    }
                    else {
                        throw new Error("ItemID or CollectionID was expected");
                    }
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                multiple: false,
                maxAmount: item ? item.supply : null,
                baseFee: 0,
                getConvertableValue: () => tslib_1.__awaiter(this, void 0, void 0, function* () { return undefined; }),
                supportsExpirationDate: true,
                shouldTransferFunds: true,
                submit,
                nftData: {
                    nftCollection: (item === null || item === void 0 ? void 0 : item.collection) ? (0, types_1.toUnionContractAddress)(item.collection) : prepareCollectionId,
                },
            };
        });
    }
    bidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.bid(request);
            return prepare.submit(request);
        });
    }
    acceptBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const orderId = (0, utils_2.getOrderId)(request);
            const order = yield this.apis.order.getValidatedOrderById({
                id: orderId,
            });
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (buyRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c;
                    if (Array.isArray(buyRequest.itemId)) {
                        throw new Error("Array of itemIds is not supported");
                    }
                    if ((_a = buyRequest.originFees) === null || _a === void 0 ? void 0 : _a.length) {
                        throw new Error("Origin fees is not supported in acceptBid operation. You can set it during bid");
                    }
                    if (order.take.type["@type"] === "NFT_OF_COLLECTION") {
                        if (!buyRequest.itemId) {
                            throw new Error("ItemId property mustn't be empty");
                        }
                        const itemId = buyRequest.itemId;
                        const item = yield this.apis.item.getItemById({ itemId });
                        const collection = yield this.apis.collection.getCollectionById({
                            collection: item.collection,
                        });
                        if (((_b = collection.extra) === null || _b === void 0 ? void 0 : _b.standard) === "v1") {
                            const tx = yield this.sdk.order.acceptCollectionOfferV1((0, sdk_common_1.extractId)(orderId), item.extra.onChainTokenName, item.extra.propertyVersionV1);
                            return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                        }
                        else {
                            const tx = yield this.sdk.order.acceptCollectionOffer((0, sdk_common_1.extractId)(orderId), (0, sdk_common_1.extractId)(buyRequest.itemId));
                            return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                        }
                    }
                    if (order.take.type["@type"] === "NFT") {
                        const item = yield this.apis.item.getItemById({
                            itemId: order.take.type.itemId,
                        });
                        const collection = yield this.apis.collection.getCollectionById({
                            collection: item.collection,
                        });
                        if (((_c = collection.extra) === null || _c === void 0 ? void 0 : _c.standard) === "v1") {
                            const tx = yield this.sdk.order.acceptTokenOfferV1((0, sdk_common_1.extractId)(orderId), item.extra.onChainTokenName, item.extra.propertyVersionV1);
                            return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                        }
                        const tx = yield this.sdk.order.acceptTokenOffer((0, sdk_common_1.extractId)(orderId));
                        return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                    }
                    throw new Error("Type of order is not supported");
                }),
            });
            return {
                multiple: false,
                maxAmount: order.makeStock,
                baseFee: 0,
                supportsPartialFill: false,
                originFeeSupport: domain_1.OriginFeeSupport.NONE,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                submit,
                orderData: {
                    platform: order.platform,
                    nftCollection: (0, utils_2.getNftContractAddress)(order.take.type),
                },
            };
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.acceptBid(request);
            return response.submit(request);
        });
    }
}
exports.AptosBid = AptosBid;
