"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosListing = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const action_1 = require("@rarible/action");
const sdk_common_1 = require("@rarible/sdk-common");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const utils_1 = require("@rarible/utils");
const aptos_sdk_1 = require("@rarible/aptos-sdk");
const domain_1 = require("../../types/order/fill/domain");
const utils_2 = require("../../common/utils");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const common_1 = require("./common");
class AptosListing {
    constructor(sdk, network, apis) {
        this.sdk = sdk;
        this.network = network;
        this.apis = apis;
        this.sell = this.sell.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
        this.buy = this.buy.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
    }
    sell() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    const aptosItemId = (0, sdk_common_1.extractId)(request.itemId);
                    const aptosItem = yield this.apis.item.getItemById({ itemId: `${api_client_1.Blockchain.APTOS}:${aptosItemId}` });
                    const aptosCollection = yield this.apis.collection.getCollectionById({
                        collection: aptosItem.collection,
                    });
                    if (request.originFees && request.originFees.length > 1) {
                        throw new Error("Origin fees should consist only 1 item");
                    }
                    const feeObject = yield this.sdk.order.getFeeObject(((_a = request.originFees) === null || _a === void 0 ? void 0 : _a.length)
                        ? {
                            address: (0, sdk_common_1.extractId)(request.originFees[0].account),
                            value: request.originFees[0].value,
                        }
                        : undefined);
                    const assetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
                    if (assetType["@type"] !== "CURRENCY_NATIVE") {
                        throw new Error("Only native token currency is available for sell operation");
                    }
                    const startTime = Math.floor(Date.now() / 1000);
                    let objectAddress;
                    if (((_b = aptosCollection.extra) === null || _b === void 0 ? void 0 : _b.standard) === "v1") {
                        if (!aptosItem.extra) {
                            throw new Error("No extra field in API item");
                        }
                        const firstCreator = (0, sdk_common_1.extractId)(aptosItem.creators[0].account);
                        objectAddress = yield this.sdk.order.sellV1(feeObject, firstCreator, aptosItem.extra.onChainCollectionName, aptosItem.extra.onChainTokenName, aptosItem.extra.propertyVersionV1, startTime, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed());
                    }
                    else {
                        objectAddress = yield this.sdk.order.sell(aptosItemId, feeObject, startTime, (0, utils_1.toBn)(request.price.toString()).multipliedBy(aptos_sdk_1.APT_DIVIDER).toFixed());
                    }
                    return (0, common_1.convertAptosToUnionOrderId)(objectAddress);
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                baseFee: 0,
                supportsExpirationDate: true,
                shouldTransferNft: true,
                submit,
            };
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.sell();
            return prepare.submit(request);
        });
    }
    buy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.apis.order.getValidatedOrderById({
                id: (0, utils_2.getOrderId)(request),
            });
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (buyRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if ((_a = buyRequest.originFees) === null || _a === void 0 ? void 0 : _a.length) {
                        throw new Error("Origin fees is not supported in buy operation. You can set it during sell");
                    }
                    const aptosOrderId = (0, sdk_common_1.extractId)(order.id);
                    const tx = yield this.sdk.order.buy(aptosOrderId);
                    return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                }),
            });
            return {
                multiple: false,
                maxAmount: order.makeStock,
                baseFee: 0,
                supportsPartialFill: false,
                originFeeSupport: domain_1.OriginFeeSupport.NONE,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                submit,
                orderData: {
                    platform: order.platform,
                    nftCollection: (0, utils_2.getNftContractAddress)(order.make.type),
                },
            };
        });
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.buy(request);
            return response.submit(request);
        });
    }
}
exports.AptosListing = AptosListing;
