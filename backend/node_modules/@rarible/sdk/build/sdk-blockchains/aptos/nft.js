"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AptosNft = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const types_1 = require("@rarible/types");
const sdk_common_1 = require("@rarible/sdk-common");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const prepare_1 = require("../../types/nft/mint/prepare");
const get_collection_id_1 = require("../../common/get-collection-id");
class AptosNft {
    constructor(sdk, network, apis) {
        this.sdk = sdk;
        this.network = network;
        this.apis = apis;
        this.createCollectionBasic = this.createCollectionBasic.bind(this);
        this.mint = this.mint.bind(this);
        this.burn = this.burn.bind(this);
        this.burnBasic = this.burnBasic.bind(this);
        this.transfer = this.transfer.bind(this);
        this.preprocessMeta = this.preprocessMeta.bind(this);
        this.mintBasic = this.mintBasic.bind(this);
        this.transferBasic = this.transferBasic.bind(this);
    }
    preprocessMeta(meta) {
        const { name, description, image, animation_url, external_url, attributes } = meta;
        return {
            name: name || "",
            description: description || "",
            image: image,
            animation_url: animation_url,
            external_url: external_url,
            attributes: attributes.map(attr => ({
                key: attr.trait_type,
                value: attr.value,
            })),
        };
    }
    createCollectionBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { name, description, uri } = request;
            const { tx, collectionAddress } = yield this.sdk.nft.createCollection({
                name,
                description,
                uri,
            });
            return {
                tx: new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk),
                address: (0, types_1.toUnionContractAddress)(`${api_client_1.Blockchain.APTOS}:${collectionAddress}`),
            };
        });
    }
    // eslint-disable-next-line no-dupe-class-members
    mintBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepareResponse = yield this.mint(request);
            return prepareResponse.submit(request);
        });
    }
    mint(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                multiple: false,
                supportsRoyalties: false,
                supportsLazyMint: false,
                submit: action_1.Action.create({
                    id: "mint",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const unionColectionId = (0, get_collection_id_1.getCollectionId)(prepareRequest);
                        // const collection = await this.apis.collection.getCollectionById({
                        // 	collection: unionColectionId,
                        // })
                        const aptosCollectionId = (0, sdk_common_1.extractId)(unionColectionId);
                        const { tx, tokenAddress } = yield this.sdk.nft.mintWithCollectionAddress({
                            collectionAddress: aptosCollectionId,
                            name: "",
                            description: "",
                            uri: request.uri,
                        });
                        return {
                            type: prepare_1.MintType.ON_CHAIN,
                            transaction: new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk),
                            itemId: (0, types_1.toItemId)(`${api_client_1.Blockchain.APTOS}:${tokenAddress}`),
                        };
                    }),
                }),
            };
        });
    }
    transferBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.transfer(request);
            return response.submit(request);
        });
    }
    transfer(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const item = yield this.apis.item.getItemById({ itemId: prepare.itemId });
            const collectionId = item.collection || ((_a = item.itemCollection) === null || _a === void 0 ? void 0 : _a.id);
            return {
                multiple: parseFloat(item.supply) > 1,
                maxAmount: (0, types_1.toBigNumber)(item.supply),
                nftData: {
                    nftCollection: collectionId ? (0, types_1.toUnionContractAddress)(collectionId) : undefined,
                },
                submit: action_1.Action.create({
                    id: "transfer",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const aptosNftId = (0, sdk_common_1.extractId)(item.id);
                        const recipientAddress = (0, sdk_common_1.extractId)(request.to);
                        const aptosCollection = yield this.apis.collection.getCollectionById({
                            collection: item.collection,
                        });
                        if (((_b = aptosCollection.extra) === null || _b === void 0 ? void 0 : _b.standard) === "v1" && item.extra) {
                            const creator = (0, sdk_common_1.extractId)(item.creators[0].account);
                            const tx = yield this.sdk.nft.transferV1Token(recipientAddress, creator, aptosCollection.name, item.extra.onChainTokenName, item.extra.propertyVersionV1, `${request.amount}`);
                            return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                        }
                        const tx = yield this.sdk.nft.transfer(aptosNftId, recipientAddress);
                        return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                    }),
                }),
            };
        });
    }
    burn(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const item = yield this.apis.item.getItemById({ itemId: prepare.itemId });
            const collectionId = item.collection || ((_a = item.itemCollection) === null || _a === void 0 ? void 0 : _a.id);
            return {
                multiple: parseFloat(item.supply) > 1,
                maxAmount: (0, types_1.toBigNumber)(item.supply),
                nftData: {
                    nftCollection: collectionId ? (0, types_1.toUnionContractAddress)(collectionId) : undefined,
                },
                submit: action_1.Action.create({
                    id: "burn",
                    run: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const aptosItemId = (0, sdk_common_1.extractId)(prepare.itemId);
                        const tx = yield this.sdk.nft.burn(aptosItemId);
                        return new sdk_transaction_1.BlockchainAptosTransaction(tx, this.network, this.sdk);
                    }),
                }),
            };
        });
    }
    burnBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.burn(request);
            return response.submit(request);
        });
    }
}
exports.AptosNft = AptosNft;
