"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEclipseSdk = void 0;
const eclipse_sdk_1 = require("@rarible/eclipse-sdk");
const domain_1 = require("../../domain");
const not_implemented_1 = require("../../common/not-implemented");
const common_1 = require("../../types/common");
const domain_2 = require("../../types/order/fill/domain");
const balance_1 = require("./balance");
const nft_1 = require("./nft");
const order_1 = require("./order");
function createEclipseSdk(wallet, apis, cluster, config, logs) {
    const sdk = eclipse_sdk_1.EclipseSdk.create({
        connection: {
            cluster,
            endpoint: config === null || config === void 0 ? void 0 : config.eclipseEndpoint,
            commitmentOrConfig: "confirmed",
        },
        debug: logs !== domain_1.LogsLevel.DISABLED,
    });
    const balanceService = new balance_1.EclipseBalance(sdk, wallet, apis);
    const nftService = new nft_1.EclipseNft(sdk, wallet, apis);
    const orderService = new order_1.EclipseOrder(sdk, wallet, apis, config);
    return {
        nft: {
            mint: new common_1.MethodWithPrepare(not_implemented_1.nonImplementedAction, not_implemented_1.nonImplementedAction),
            burn: new common_1.MethodWithPrepare(nftService.burnBasic, nftService.burn),
            transfer: new common_1.MethodWithPrepare(nftService.transferBasic, nftService.transfer),
            generateTokenId: not_implemented_1.nonImplementedAction,
            createCollection: not_implemented_1.nonImplementedAction,
            preprocessMeta: not_implemented_1.notImplemented,
            uploadMeta: not_implemented_1.nonImplementedAction,
        },
        order: {
            fill: { prepare: not_implemented_1.nonImplementedAction },
            buy: new common_1.MethodWithPrepare(orderService.buyBasic, orderService.buy),
            batchBuy: new common_1.MethodWithPrepare(not_implemented_1.notImplemented, not_implemented_1.nonImplementedAction),
            acceptBid: new common_1.MethodWithPrepare(orderService.acceptBidBasic, orderService.acceptBid),
            sell: new common_1.MethodWithPrepare(orderService.sellBasic, orderService.sell),
            sellUpdate: new common_1.MethodWithPrepare(not_implemented_1.nonImplementedAction, not_implemented_1.nonImplementedAction),
            bid: new common_1.MethodWithPrepare(orderService.bidBasic, orderService.bid),
            bidUpdate: new common_1.MethodWithPrepare(not_implemented_1.nonImplementedAction, not_implemented_1.nonImplementedAction),
            cancel: orderService.cancelBasic,
        },
        balances: {
            getBalance: balanceService.getBalance,
            convert: not_implemented_1.nonImplementedAction,
            transfer: not_implemented_1.notImplemented,
            getBiddingBalance: not_implemented_1.nonImplementedAction,
            depositBiddingBalance: not_implemented_1.nonImplementedAction,
            withdrawBiddingBalance: not_implemented_1.nonImplementedAction,
        },
        restriction: {
            canTransfer: not_implemented_1.nonImplementedAction,
            getFutureOrderFees() {
                return Promise.resolve({ baseFee: 0, originFeeSupport: domain_2.OriginFeeSupport.NONE });
            },
        },
    };
}
exports.createEclipseSdk = createEclipseSdk;
