"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EclipseNft = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const action_1 = require("@rarible/action");
const types_2 = require("@rarible/types");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const address_converters_1 = require("../solana/common/address-converters");
class EclipseNft {
    constructor(sdk, wallet, apis) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.burn = this.burn.bind(this);
        this.burnBasic = this.burnBasic.bind(this);
        this.transfer = this.transfer.bind(this);
        this.transferBasic = this.transferBasic.bind(this);
    }
    burn(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new Error("Solana wallet not provided");
            }
            const item = yield this.apis.item.getItemById({ itemId: prepare.itemId });
            if (!item) {
                throw new Error(`Item with id ${prepare.itemId} not found`);
            }
            return {
                multiple: parseFloat(item.supply) > 1,
                maxAmount: (0, types_2.toBigNumber)(item.supply),
                nftData: {
                    nftCollection: item.collection && (0, types_1.toUnionContractAddress)(item.collection),
                },
                submit: action_1.Action.create({
                    id: "burn",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const amount = (_a = request === null || request === void 0 ? void 0 : request.amount) !== null && _a !== void 0 ? _a : 1;
                        const mint = (0, address_converters_1.extractPublicKey)(item.id);
                        const prepare = yield this.sdk.nft.burn({
                            mint: mint,
                            signer: this.wallet.provider,
                            amount: amount,
                            owner: this.wallet.provider.publicKey,
                        });
                        const tx = yield prepare.submit("processed");
                        return new sdk_transaction_1.BlockchainSolanaTransaction(tx, this.sdk, api_client_1.Blockchain.ECLIPSE);
                    }),
                }),
            };
        });
    }
    burnBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.burn(request);
            return response.submit(request);
        });
    }
    transfer(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new Error("Solana wallet not provided");
            }
            const item = yield this.apis.item.getItemById({ itemId: prepare.itemId });
            if (!item) {
                throw new Error(`Item with id ${prepare.itemId} not found`);
            }
            return {
                multiple: parseFloat(item.supply) > 1,
                maxAmount: (0, types_2.toBigNumber)(item.supply),
                nftData: {
                    nftCollection: item.collection ? (0, types_1.toUnionContractAddress)(item.collection) : undefined,
                },
                submit: action_1.Action.create({
                    id: "transfer",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const amount = (_a = request === null || request === void 0 ? void 0 : request.amount) !== null && _a !== void 0 ? _a : 1;
                        const mint = (0, address_converters_1.extractPublicKey)(item.id);
                        const prepare = yield this.sdk.nft.transfer({
                            mint: mint,
                            signer: this.wallet.provider,
                            amount: amount,
                            to: (0, address_converters_1.extractPublicKey)(request.to),
                            owner: this.wallet.provider.publicKey,
                        });
                        const tx = yield prepare.submit("processed");
                        return new sdk_transaction_1.BlockchainSolanaTransaction(tx, this.sdk, api_client_1.Blockchain.ECLIPSE);
                    }),
                }),
            };
        });
    }
    transferBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.transfer(request);
            return response.submit(request);
        });
    }
}
exports.EclipseNft = EclipseNft;
