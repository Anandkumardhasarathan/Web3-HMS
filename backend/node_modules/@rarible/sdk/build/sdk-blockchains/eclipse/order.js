"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EclipseOrder = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const action_1 = require("@rarible/action");
const api_client_1 = require("@rarible/api-client");
const web3_js_1 = require("@solana/web3.js");
const eclipse_sdk_1 = require("@rarible/eclipse-sdk");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const sdk_common_1 = require("@rarible/sdk-common");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const order_1 = require("../solana/common/order");
const utils_1 = require("../../common/utils");
const currencies_1 = require("../solana/common/currencies");
const address_converters_1 = require("./common/address-converters");
function supportedCurrencies() {
    return [{ blockchain: api_client_1.Blockchain.ECLIPSE, type: "NATIVE" }];
}
function getMintId(order) {
    let isCollectionOffer = false;
    let mintId;
    if (order.make.type["@type"] === "NFT") {
        mintId = (0, address_converters_1.extractPublicKey)(order.make.type.itemId);
    }
    else if (order.take.type["@type"] === "NFT") {
        mintId = (0, address_converters_1.extractPublicKey)(order.take.type.itemId);
    }
    else if (order.make.type["@type"] === "NFT_OF_COLLECTION") {
        mintId = (0, address_converters_1.extractPublicKey)(order.make.type.collectionId);
        isCollectionOffer = true;
    }
    else if (order.take.type["@type"] === "NFT_OF_COLLECTION") {
        mintId = (0, address_converters_1.extractPublicKey)(order.take.type.collectionId);
        isCollectionOffer = true;
    }
    else {
        throw new Error("Unsupported type");
    }
    return [mintId, isCollectionOffer];
}
function getMarketplace(config) {
    if (config.eclipseMarketplaces.length === 0) {
        throw new Error("Should have at least one marketplace in config");
    }
    if (config.eclipseMarketplaces.length > 1) {
        throw new Error("Should have only one marketplace in config");
    }
    return config.eclipseMarketplaces[0];
}
class EclipseOrder {
    constructor(sdk, wallet, apis, config) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.config = config;
        this.sell = this.sell.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
        this.cancelBasic = this.cancelBasic.bind(this);
        this.buy = this.buy.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
        this.fill = this.fill.bind(this);
        this.bid = this.bid.bind(this);
        this.bidBasic = this.bidBasic.bind(this);
        this.cancelBasic = this.cancelBasic.bind(this);
        this.acceptBid = this.acceptBid.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
    }
    sell() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new Error("Eclipse wallet not provided");
            }
            const marketplace = yield this.sdk.order.getMarketPlace({ marketIdentifier: getMarketplace(this.config) });
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.sellCommon(request, getMarketplace(this.config));
                }),
            });
            const baseFee = marketplace.feeBps2
                ? marketplace.feeBps2.toNumber() + marketplace.feeBps.toNumber()
                : marketplace.feeBps.toNumber();
            return {
                originFeeSupport: domain_1.OriginFeeSupport.NONE,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: supportedCurrencies(),
                baseFee,
                supportsExpirationDate: false,
                shouldTransferNft: false,
                submit: submit,
            };
        });
    }
    sellCommon(request, marketIdentifier) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const nftMint = (0, address_converters_1.extractPublicKey)(request.itemId);
            const amount = request.amount !== undefined ? request.amount : 1;
            const currency = (0, sdk_common_1.extractId)((0, get_currency_asset_type_1.getCurrencyId)(request.currency));
            const result = yield (yield this.sdk.order.sell({
                marketIdentifier,
                signer: this.wallet.provider,
                nftMint,
                price: new bignumber_js_1.default(request.price),
                tokensAmount: amount,
                paymentMint: new web3_js_1.PublicKey(currency),
            })).submit("processed");
            return (0, types_1.toOrderId)(`ECLIPSE:${result.orderId}`);
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.sell();
            return response.submit(request);
        });
    }
    bid(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new Error("Eclipse wallet not provided");
            }
            let nftOrCollection;
            let collectionId;
            if ("itemId" in prepare) {
                nftOrCollection = yield this.apis.item.getItemById({ itemId: prepare.itemId });
                collectionId = nftOrCollection.collection;
            }
            else if ("collectionId" in prepare) {
                nftOrCollection = yield this.apis.collection.getCollectionById({ collection: prepare.collectionId });
                collectionId = nftOrCollection.id;
            }
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const amount = request.amount !== undefined ? request.amount : 1;
                    const result = yield (yield this.sdk.order.bid({
                        marketIdentifier: getMarketplace(this.config),
                        signer: this.wallet.provider,
                        nftMint: nftOrCollection ? (0, address_converters_1.extractPublicKey)(nftOrCollection.id) : undefined,
                        paymentMint: new web3_js_1.PublicKey(eclipse_sdk_1.ECLIPSE_NATIVE_CURRENCY_ADDRESS),
                        price: new bignumber_js_1.default(request.price).multipliedBy(amount),
                        tokensAmount: amount,
                    })).submit("processed");
                    return (0, types_1.toOrderId)(`ECLIPSE:${result.orderId}`);
                }),
            });
            return {
                multiple: nftOrCollection && "supply" in nftOrCollection ? parseFloat(nftOrCollection.supply) > 1 : false,
                maxAmount: nftOrCollection && "supply" in nftOrCollection ? (0, types_1.toBigNumber)(nftOrCollection === null || nftOrCollection === void 0 ? void 0 : nftOrCollection.supply) : (0, types_1.toBigNumber)(1),
                originFeeSupport: domain_1.OriginFeeSupport.NONE,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, currencies_1.getCurrencies)(),
                baseFee: 0,
                getConvertableValue: _ => Promise.resolve(undefined),
                supportsExpirationDate: false,
                shouldTransferFunds: false,
                submit,
                nftData: {
                    nftCollection: collectionId ? (0, types_1.toUnionContractAddress)(collectionId) : undefined,
                },
            };
        });
    }
    bidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.bid(request);
            return response.submit(request);
        });
    }
    cancelBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.apis.order.getValidatedOrderById({
                id: request.orderId,
            });
            const isCancelBid = (0, utils_1.isNativeToken)(order.make.type);
            const cancel = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const order = yield this.apis.order.getValidatedOrderById({
                        id: request.orderId,
                    });
                    const orderAddress = new web3_js_1.PublicKey((0, sdk_common_1.extractId)(order.id));
                    if (isCancelBid) {
                        const res = yield (yield this.sdk.order.cancelBid({
                            signer: this.wallet.provider,
                            orderAddress,
                        })).submit("processed");
                        return new sdk_transaction_1.BlockchainSolanaTransaction(res, this.sdk, api_client_1.Blockchain.ECLIPSE);
                    }
                    else {
                        const res = yield (yield this.sdk.order.cancelSell({
                            signer: this.wallet.provider,
                            orderAddress,
                        })).submit("processed");
                        return new sdk_transaction_1.BlockchainSolanaTransaction(res, this.sdk, api_client_1.Blockchain.ECLIPSE);
                    }
                }),
            });
            return cancel(request);
        });
    }
    buy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fill(request, false);
        });
    }
    acceptBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fill(request, true);
        });
    }
    fill(request, shouldPayBaseFee) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new Error("Solana wallet not provided");
            }
            const order = yield (0, order_1.getPreparedOrder)(request, this.apis);
            const [nftMint, isCollectionOffer] = getMintId(order);
            const orderAddress = new web3_js_1.PublicKey((0, sdk_common_1.extractId)(order.id));
            if (order.status !== api_client_1.OrderStatus.ACTIVE) {
                throw new Error("Order is not active");
            }
            let itemsCount = 1;
            if (!isCollectionOffer) {
                const item = yield this.apis.item.getItemById({ itemId: (0, types_1.toItemId)(`ECLIPSE:${nftMint.toString()}`) });
                itemsCount = parseFloat(item.supply.toString());
            }
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (buyRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let nftMintAddress = nftMint;
                    if (isCollectionOffer) {
                        if (!buyRequest.itemId ||
                            (Array.isArray(buyRequest.itemId) && (buyRequest.itemId.length === 0 || buyRequest.itemId.length > 1))) {
                            throw new Error("Fill request should contain exactly one itemId for accepting collection bid");
                        }
                        nftMintAddress = (0, address_converters_1.extractPublicKey)(Array.isArray(buyRequest.itemId) ? buyRequest.itemId[0] : buyRequest.itemId);
                    }
                    const prepare1 = yield this.sdk.order.executeOrder({
                        signer: this.wallet.provider,
                        orderAddress,
                        nftMint: nftMintAddress,
                        amountToFill: buyRequest.amount,
                    });
                    const data = {
                        instructions: prepare1.data.instructions,
                        signers: prepare1.data.signers,
                    };
                    // revoke empty delegated token account
                    const tokenAccount = yield this.sdk.account.getTokenAccountForMint({
                        mint: nftMint,
                        owner: this.wallet.provider.publicKey,
                    });
                    if (tokenAccount) {
                        const accountInfo = yield this.sdk.account.getAccountInfo({ tokenAccount });
                        if (accountInfo.delegate && accountInfo.amount.toString() === "0") {
                            const prepare2 = this.sdk.account.revokeDelegate({
                                signer: this.wallet.provider,
                                tokenAccount,
                            });
                            data.instructions.push(...prepare2.data.instructions);
                            data.signers.push(...prepare2.data.signers);
                        }
                    }
                    return yield new eclipse_sdk_1.PreparedTransaction(this.sdk.connection, data, this.wallet.provider).submit("processed");
                }),
            }).after(tx => new sdk_transaction_1.BlockchainSolanaTransaction(tx, this.sdk, api_client_1.Blockchain.ECLIPSE));
            let baseFee = 0;
            if (shouldPayBaseFee) {
                const marketplace = yield this.sdk.order.getMarketPlace({ marketIdentifier: getMarketplace(this.config) });
                baseFee = marketplace.feeBps2
                    ? marketplace.feeBps2.toNumber() + marketplace.feeBps.toNumber()
                    : marketplace.feeBps.toNumber();
            }
            return {
                multiple: itemsCount > 1,
                maxAmount: order.makeStock,
                baseFee,
                supportsPartialFill: false,
                originFeeSupport: domain_1.OriginFeeSupport.NONE,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                submit,
                orderData: {
                    platform: order.platform,
                    nftCollection: (0, utils_1.getNftContractAddress)(order.make.type),
                },
            };
        });
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.buy(request);
            return response.submit(request);
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.acceptBid(request);
            return response.submit(request);
        });
    }
}
exports.EclipseOrder = EclipseOrder;
