"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumBalance = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const action_1 = require("@rarible/action");
const sdk_common_1 = require("@rarible/sdk-common");
const types_1 = require("@rarible/types");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const common_1 = require("./common");
class EthereumBalance {
    constructor(sdk, wallet, apis) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.depositBiddingBalance = action_1.Action.create({
            id: "send-tx",
            run: (request) => this.convert({
                blockchain: api_client_1.Blockchain.ETHEREUM,
                isWrap: true,
                value: request.amount,
            }),
        });
        this.withdrawBiddingBalance = action_1.Action.create({
            id: "send-tx",
            run: (request) => this.convert({
                blockchain: api_client_1.Blockchain.ETHEREUM,
                isWrap: false,
                value: request.amount,
            }),
        });
        this.getBalance = this.getBalance.bind(this);
        this.convert = this.convert.bind(this);
        this.getBiddingBalance = this.getBiddingBalance.bind(this);
        this.transfer = this.transfer.bind(this);
    }
    getBalance(address, currency) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const type = (0, get_currency_asset_type_1.getCurrencyAssetType)(currency);
            if (!(0, get_currency_asset_type_1.isEth)(type) && !(0, get_currency_asset_type_1.isErc20)(type)) {
                throw new Error("Unsupported asset type for getting balance");
            }
            const response = yield this.apis.balances.getBalance({
                currencyId: (0, get_currency_asset_type_1.getCurrencyId)(currency),
                owner: address,
            });
            return (0, utils_1.toBn)(response.decimal);
        });
    }
    convert(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tx = yield this.send(request);
            return new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet));
        });
    }
    send(request) {
        if (request.isWrap)
            return this.sdk.balances.deposit(request.value);
        return this.sdk.balances.withdraw(request.value);
    }
    getBiddingBalance(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currency = yield this.getBiddingCurrency(request);
            return this.getBalance(request.walletAddress, currency);
        });
    }
    getBiddingCurrency(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("currency" in request) {
                return request.currency;
            }
            else {
                const wrappedContract = yield this.sdk.balances.getWethContractAddress();
                const blockchain = (0, sdk_common_1.extractBlockchain)(request.walletAddress);
                if ((0, common_1.isEVMBlockchain)(blockchain)) {
                    return {
                        "@type": "ERC20",
                        contract: (0, common_1.convertEthereumContractAddress)(wrappedContract, blockchain),
                    };
                }
                throw new Error(`Bidding balance is not supported for ${blockchain}`);
            }
        });
    }
    transfer(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const evmAddress = (0, sdk_common_1.extractId)(request.recipient);
            const assetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
            if (!(0, get_currency_asset_type_1.isEth)(assetType) && !(0, get_currency_asset_type_1.isErc20)(assetType)) {
                throw new Error("Transfer request is available for ETH and ERC20 tokens");
            }
            const tx = yield this.sdk.balances.transfer((0, types_1.toEVMAddress)(evmAddress), {
                assetType: (0, common_1.convertToEthereumAssetType)(assetType),
                valueDecimal: request.amount,
            });
            return new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet));
        });
    }
}
exports.EthereumBalance = EthereumBalance;
