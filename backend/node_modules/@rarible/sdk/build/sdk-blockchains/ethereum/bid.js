"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateBidNotSupportedForThidKindOfOrderError = exports.InsufficientFundsError = exports.EthereumBid = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const types_2 = require("@rarible/types");
const api_client_1 = require("@rarible/api-client");
const action_1 = require("@rarible/action");
const add_fee_1 = require("@rarible/protocol-ethereum-sdk/build/order/add-fee");
const get_decimals_1 = require("@rarible/protocol-ethereum-sdk/build/common/get-decimals");
const get_price_1 = require("@rarible/protocol-ethereum-sdk/build/common/get-price");
const compare_case_insensitive_1 = require("@rarible/protocol-ethereum-sdk/build/common/compare-case-insensitive");
const utils_1 = require("@rarible/utils");
const build_1 = require("@rarible/logger/build");
const domain_1 = require("../../types/order/fill/domain");
const get_convertable_value_1 = require("../../common/get-convertable-value");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const get_expiration_date_1 = require("../../common/get-expiration-date");
const check_royalties_1 = require("../../common/check-royalties");
const common = tslib_1.__importStar(require("./common"));
const common_1 = require("./common");
class EthereumBid {
    constructor(sdk, wallet, apis, balanceService) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.balanceService = balanceService;
        this.bid = this.bid.bind(this);
        this.update = this.update.bind(this);
        this.getConvertableValue = this.getConvertableValue.bind(this);
        this.convertCurrency = this.convertCurrency.bind(this);
        this.bidBasic = this.bidBasic.bind(this);
        this.bidUpdateBasic = this.bidUpdateBasic.bind(this);
    }
    bidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.bid(request);
            return prepare.submit(request);
        });
    }
    bidUpdateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const updateResponse = yield this.update(request);
            return updateResponse.submit(request);
        });
    }
    bid(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("itemId" in prepare) {
                const { contract, domain } = (0, common_1.getEthereumItemId)(prepare.itemId);
                const collection = yield this.apis.collection.getCollectionById({
                    collection: (0, common_1.convertEthereumContractAddress)(contract, domain),
                });
                if (collection.self) {
                    yield (0, check_royalties_1.checkRoyalties)(prepare.itemId, this.apis);
                }
            }
            return this.bidDataV2(prepare);
        });
    }
    bidDataV2(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { ethAssetType, item, contract, blockchain } = yield getTakeAssetType(this.apis, prepare);
            const collection = yield this.apis.collection.getCollectionById({
                collection: contract,
            });
            const bidAction = this.sdk.order.bid.around((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                const expirationDate = request.expirationDate
                    ? (0, get_expiration_date_1.convertDateToTimestamp)(request.expirationDate)
                    : (0, get_expiration_date_1.getDefaultExpirationDateTimestamp)();
                const currencyAssetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
                const baseFee = yield this.sdk.order.getBaseOrderFee("RARIBLE_V2");
                return {
                    type: baseFee === 0 ? "DATA_V2" : "DATA_V3",
                    makeAssetType: common.getEthTakeAssetType(currencyAssetType),
                    takeAssetType: ethAssetType,
                    amount: (0, common_1.getOrderAmount)(request.amount, collection),
                    priceDecimal: request.price,
                    payouts: common.toEthereumParts(request.payouts),
                    originFees: common.toEthereumParts(request.originFees),
                    end: expirationDate,
                };
            }), (res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                yield ((_a = res.approveTx) === null || _a === void 0 ? void 0 : _a.wait());
                return common.convertEthereumOrderHash(res.order.hash, blockchain);
            }));
            const submit = action_1.Action.create({
                id: "convert",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _b;
                    yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                    const currency = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
                    if (currency["@type"] === "ERC20") {
                        const wrappedContract = yield this.sdk.balances.getWethContractAddress();
                        if (![api_client_1.Blockchain.MANTLE, api_client_1.Blockchain.CELO].includes(blockchain) &&
                            (0, compare_case_insensitive_1.compareCaseInsensitive)((0, common_1.convertToEthereumAddress)(currency.contract), wrappedContract)) {
                            const feeBp = ((_b = request.originFees) === null || _b === void 0 ? void 0 : _b.reduce((prev, curr) => prev + curr.value, 0)) || 0;
                            const quantity = (0, common_1.getOrderAmount)(request.amount, collection);
                            const value = yield this.getConvertableValueCommon(currency, request.price, quantity, feeBp, blockchain);
                            yield this.convertCurrency(value);
                        }
                    }
                    return request;
                }),
            }).thenAction(bidAction);
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: common.getSupportedCurrencies(api_client_1.Blockchain.ETHEREUM, true),
                multiple: collection.type === "ERC1155",
                maxAmount: item ? item.supply : null,
                baseFee: yield this.sdk.order.getBaseOrderFee(),
                getConvertableValue: this.getConvertableValue.bind(this, blockchain),
                supportsExpirationDate: true,
                shouldTransferFunds: false,
                submit,
                nftData: {
                    nftCollection: (0, types_1.toUnionContractAddress)(collection.id),
                },
            };
        });
    }
    getConvertableValue(blockchain, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const assetType = this.getAssetTypeForConvert(request);
            if (assetType["@type"] === "ERC20") {
                const wrappedCurrency = yield this.sdk.balances.getWethContractAddress();
                if (![api_client_1.Blockchain.MANTLE, api_client_1.Blockchain.CELO].includes(blockchain) &&
                    (0, compare_case_insensitive_1.compareCaseInsensitive)((0, common_1.convertToEthereumAddress)(assetType.contract), wrappedCurrency)) {
                    const feeBp = request.originFees.reduce((prev, curr) => prev + curr.value, 0);
                    return this.getConvertableValueCommon(assetType, request.price, request.amount, feeBp, blockchain);
                }
            }
            return undefined;
        });
    }
    getAssetTypeForConvert(request) {
        if (request.assetType)
            return request.assetType;
        if (request.currencyId)
            return (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currencyId);
        throw new Error("assetType or currencyId should be specified");
    }
    getConvertableValueCommon(assetType, price, quantity, originFeeBp, blockchain) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const wallet = common.assertWallet(this.wallet);
            const convertedAssetType = (0, common_1.convertToEthereumAssetType)(assetType);
            const valueRaw = (0, utils_1.toBn)(price).multipliedBy(quantity);
            const [convertedPrice, baseFeeBp] = yield Promise.all([
                (0, get_price_1.getPrice)(wallet.ethereum, convertedAssetType, valueRaw),
                this.sdk.order.getBaseOrderFee(),
            ]);
            const valueWithFee = (0, add_fee_1.addFee)({
                assetType: convertedAssetType,
                value: (0, types_2.toBigNumber)(convertedPrice.toString()),
            }, originFeeBp + baseFeeBp);
            const [assetDecimals, from] = yield Promise.all([
                (0, get_decimals_1.getDecimals)(wallet.ethereum, convertedAssetType),
                wallet.ethereum.getFrom(),
            ]);
            const fromUnion = (0, common_1.convertEthereumToUnionAddress)(from, api_client_1.Blockchain.ETHEREUM);
            const asset = { "@type": "ETH", blockchain };
            const value = (0, utils_1.toBn)(valueWithFee.value).integerValue().div((0, utils_1.toBn)(10).pow(assetDecimals));
            return (0, get_convertable_value_1.getCommonConvertableValue)(this.balanceService.getBalance, fromUnion, value, asset, assetType);
        });
    }
    convertCurrency(convertable) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ((convertable === null || convertable === void 0 ? void 0 : convertable.type) === "insufficient")
                throw new InsufficientFundsError();
            if ((convertable === null || convertable === void 0 ? void 0 : convertable.type) === "convertable") {
                const tx = yield this.sdk.balances.deposit(convertable.value);
                yield tx.wait();
            }
            return;
        });
    }
    update(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!prepareRequest.orderId) {
                throw new Error("OrderId has not been specified");
            }
            const [blockchain, hash] = prepareRequest.orderId.split(":");
            if (!(0, common_1.isEVMBlockchain)(blockchain)) {
                throw new Error("Not an ethereum order");
            }
            const order = yield this.apis.order.getValidatedOrderById({
                id: prepareRequest.orderId,
            });
            if (!(0, common_1.isRaribleOrderData)(order.data)) {
                throw new UpdateBidNotSupportedForThidKindOfOrderError(order.data["@type"]);
            }
            const bidUpdateAction = this.sdk.order.bidUpdate.around((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                return {
                    orderHash: (0, types_1.toWord)(hash),
                    priceDecimal: request.price,
                };
            }), (res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                yield ((_a = res.approveTx) === null || _a === void 0 ? void 0 : _a.wait());
                return common.convertEthereumOrderHash(res.order.hash, blockchain);
            }));
            const actionWithConvert = action_1.Action.create({
                id: "convert",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                    if ([api_client_1.Blockchain.MANTLE, api_client_1.Blockchain.CELO].includes(blockchain)) {
                        return request;
                    }
                    if ((0, common_1.isWETH)(order.make.type, yield this.sdk.balances.getWethContractAddress())) {
                        const feesBp = (0, common_1.getOrderFeesSum)(order);
                        const value = yield this.getConvertableValueCommon(order.make.type, request.price, order.take.value, feesBp, blockchain);
                        yield this.convertCurrency(value);
                    }
                    return request;
                }),
            }).thenAction(bidUpdateAction);
            return {
                originFeeSupport: (0, common_1.getOriginFeeSupport)(order.data),
                payoutsSupport: (0, common_1.getPayoutsSupport)(order.data),
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: common.getSupportedCurrencies(api_client_1.Blockchain.ETHEREUM, true),
                baseFee: yield this.sdk.order.getBaseOrderFee((0, common_1.convertOrderType)(order.data)),
                getConvertableValue: this.getConvertableValue.bind(this, blockchain),
                submit: actionWithConvert,
                orderData: {
                    nftCollection: "contract" in order.take.type ? order.take.type.contract : undefined,
                },
            };
        });
    }
}
exports.EthereumBid = EthereumBid;
class InsufficientFundsError extends Error {
    constructor() {
        super("Insufficient funds for convertation");
        this.name = "InsufficientFundsError";
    }
}
exports.InsufficientFundsError = InsufficientFundsError;
class UpdateBidNotSupportedForThidKindOfOrderError extends Error {
    constructor(type) {
        super(`Update bid is not supported for ${type} kind of order`);
        this.name = "UpdateBidNotSupportedForThidKindOfOrderError";
    }
}
exports.UpdateBidNotSupportedForThidKindOfOrderError = UpdateBidNotSupportedForThidKindOfOrderError;
function getTakeAssetType(apis, prepare) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ("itemId" in prepare) {
            const item = yield apis.item.getItemById({ itemId: prepare.itemId });
            const { tokenId, contract, domain } = (0, common_1.getEthereumItemId)(item.id);
            if (!item.contract)
                throw new Error("Contract is undefined");
            return {
                ethAssetType: {
                    tokenId: tokenId,
                    contract: (0, types_1.toEVMAddress)(contract),
                },
                item,
                contract: (0, types_1.toUnionContractAddress)(item.contract),
                blockchain: domain,
            };
        }
        else if ("collectionId" in prepare) {
            return {
                ethAssetType: {
                    assetClass: "COLLECTION",
                    contract: (0, common_1.convertToEthereumAddress)(prepare.collectionId),
                },
                contract: (0, types_1.toUnionContractAddress)(prepare.collectionId),
                blockchain: (0, common_1.extractEVMBlockchain)(prepare.collectionId),
            };
        }
        else {
            throw new build_1.Warning("ItemId or CollectionId must be assigned");
        }
    });
}
