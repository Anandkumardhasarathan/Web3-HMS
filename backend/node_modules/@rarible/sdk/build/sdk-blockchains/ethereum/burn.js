"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumBurn = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const types_1 = require("@rarible/types");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const sdk_common_1 = require("@rarible/sdk-common");
const common_1 = require("./common");
class EthereumBurn {
    constructor(sdk, wallet, apis, network) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.network = network;
        this.burn = this.burn.bind(this);
        this.burnBasic = this.burnBasic.bind(this);
    }
    burn(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { contract, tokenId, domain } = (0, common_1.getEthereumItemId)(prepare.itemId);
            const blockchain = (0, sdk_common_1.extractBlockchain)(prepare.itemId);
            const [item, collection] = yield Promise.all([
                this.apis.item.getItemById({ itemId: prepare.itemId }),
                this.apis.collection.getCollectionById({ collection: `${domain}:${contract}` }),
            ]);
            return {
                multiple: collection.type === "ERC1155",
                maxAmount: item.supply,
                nftData: {
                    nftCollection: item.collection && (0, types_1.toUnionContractAddress)(item.collection),
                },
                submit: action_1.Action.create({
                    id: "burn",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                        const amount = (request === null || request === void 0 ? void 0 : request.amount) !== undefined ? (0, types_1.toBigNumber)(request.amount.toFixed()) : undefined;
                        const tx = yield this.sdk.nft.burn({
                            assetType: {
                                contract: (0, types_1.toEVMAddress)(contract),
                                tokenId: tokenId,
                            },
                            amount,
                            creators: (0, common_1.toEthereumParts)(request === null || request === void 0 ? void 0 : request.creators),
                        });
                        return tx && new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet));
                    }),
                }),
            };
        });
    }
    burnBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.burn(request);
            return response.submit(request);
        });
    }
}
exports.EthereumBurn = EthereumBurn;
