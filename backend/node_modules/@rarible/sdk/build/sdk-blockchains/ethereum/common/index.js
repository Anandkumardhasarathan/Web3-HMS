"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEVMBlockchain = exports.EVMBlockchains = exports.isWETH = exports.isNft = exports.isRaribleOrderData = exports.assertBlockchainAndChainId = exports.checkWalletBlockchain = exports.getWalletNetwork = exports.getWalletBlockchain = exports.assertWallet = exports.getAssetTypeFromFillRequest = exports.getAssetTypeFromItemId = exports.getOrderId = exports.getOrderAmount = exports.getEthereumItemId = exports.convertEthereumItemId = exports.convertEthereumToUnionAddress = exports.convertEthereumCollectionId = exports.convertEthereumContractAddress = exports.convertOrderIdToEthereumHash = exports.convertEthereumOrderHash = exports.convertToEthereumAddress = exports.getSupportedCurrencies = exports.extractEVMBlockchain = exports.getEVMBlockchain = exports.getPayoutsSupport = exports.getOriginFeeSupport = exports.convertOrderType = exports.isRaribleV2Data = exports.isRaribleV1Data = exports.getOrderFeesSum = exports.getOriginFeesSum = exports.convertEthereumPart = exports.toEthereumParts = exports.getEthOrder = exports.getEthOrderType = exports.convertOrderDataToEth = exports.convertToEthereumAssetType = exports.convertToEthereumAsset = exports.getEthTakeAssetType = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const types_2 = require("@rarible/types");
const api_client_1 = require("@rarible/api-client");
const utils_1 = require("@rarible/utils");
const build_1 = require("@rarible/sdk-common/build");
Object.defineProperty(exports, "EVMBlockchains", { enumerable: true, get: function () { return build_1.EVMBlockchains; } });
Object.defineProperty(exports, "isEVMBlockchain", { enumerable: true, get: function () { return build_1.isEVMBlockchain; } });
const common_1 = require("@rarible/protocol-ethereum-sdk/build/common");
const sdk_common_1 = require("@rarible/sdk-common");
const OrderData_1 = require("@rarible/ethereum-api-client/build/models/OrderData");
const SeaportOrderType_1 = require("@rarible/ethereum-api-client/build/models/SeaportOrderType");
const SeaportItemType_1 = require("@rarible/ethereum-api-client/build/models/SeaportItemType");
const SudoSwapCurveType_1 = require("@rarible/ethereum-api-client/build/models/SudoSwapCurveType");
const SudoSwapPoolType_1 = require("@rarible/ethereum-api-client/build/models/SudoSwapPoolType");
const get_price_1 = require("@rarible/protocol-ethereum-sdk/build/common/get-price");
const get_expiration_date_1 = require("../../../common/get-expiration-date");
const domain_1 = require("../../../types/order/fill/domain");
function getEthTakeAssetType(currency) {
    switch (currency["@type"]) {
        case "ERC20":
            return {
                assetClass: currency["@type"],
                contract: convertToEthereumAddress(currency.contract),
            };
        case "ETH":
            return {
                assetClass: currency["@type"],
            };
        default:
            throw new Error("Invalid take asset type");
    }
}
exports.getEthTakeAssetType = getEthTakeAssetType;
function convertToEthereumAsset(ethereum, asset) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const assetType = convertToEthereumAssetType(asset.type);
        let value = (0, utils_1.toBn)(asset.value);
        if (asset.type["@type"] === "ERC20" || asset.type["@type"] === "ETH") {
            value = yield (0, get_price_1.getPrice)(ethereum, assetType, value);
        }
        return {
            assetType,
            value: (0, types_1.toBigNumber)(value.toString()),
        };
    });
}
exports.convertToEthereumAsset = convertToEthereumAsset;
function convertToEthereumAssetType(assetType) {
    switch (assetType["@type"]) {
        case "ETH": {
            return { assetClass: "ETH" };
        }
        case "ERC20": {
            return {
                assetClass: "ERC20",
                contract: convertToEthereumAddress(assetType.contract),
            };
        }
        case "ERC721": {
            return {
                assetClass: "ERC721",
                contract: convertToEthereumAddress(assetType.contract),
                tokenId: assetType.tokenId,
            };
        }
        case "ERC721_Lazy": {
            return {
                assetClass: "ERC721_LAZY",
                contract: convertToEthereumAddress(assetType.contract),
                tokenId: assetType.tokenId,
                uri: assetType.uri,
                creators: assetType.creators.map(c => ({
                    account: convertToEthereumAddress(c.account),
                    value: (0, utils_1.toBn)(c.value).toNumber(),
                })),
                royalties: assetType.royalties.map(r => ({
                    account: convertToEthereumAddress(r.account),
                    value: (0, utils_1.toBn)(r.value).toNumber(),
                })),
                signatures: assetType.signatures.map(str => (0, types_1.toBinary)(str)),
            };
        }
        case "ERC1155": {
            return {
                assetClass: "ERC1155",
                contract: convertToEthereumAddress(assetType.contract),
                tokenId: assetType.tokenId,
            };
        }
        case "ERC1155_Lazy": {
            return {
                assetClass: "ERC1155_LAZY",
                contract: convertToEthereumAddress(assetType.contract),
                tokenId: assetType.tokenId,
                uri: assetType.uri,
                supply: assetType.supply !== undefined ? (0, types_1.toBigNumber)(assetType.supply) : (0, types_1.toBigNumber)("1"),
                creators: assetType.creators.map(c => ({
                    account: convertToEthereumAddress(c.account),
                    value: (0, utils_1.toBn)(c.value).toNumber(),
                })),
                royalties: assetType.royalties.map(r => ({
                    account: convertToEthereumAddress(r.account),
                    value: (0, utils_1.toBn)(r.value).toNumber(),
                })),
                signatures: assetType.signatures.map(str => (0, types_1.toBinary)(str)),
            };
        }
        case "CRYPTO_PUNKS": {
            return {
                assetClass: "CRYPTO_PUNKS",
                contract: convertToEthereumAddress(assetType.contract),
                tokenId: assetType.tokenId,
            };
        }
        case "GEN_ART": {
            return {
                assetClass: "GEN_ART",
                contract: convertToEthereumAddress(assetType.contract),
            };
        }
        case "AMM_NFT": {
            return {
                assetClass: "AMM_NFT",
                contract: convertToEthereumAddress(assetType.contract),
            };
        }
        case "COLLECTION": {
            return {
                assetClass: "COLLECTION",
                contract: convertToEthereumAddress(assetType.contract),
            };
        }
        default: {
            throw new Error(`Unsupported asset type=${assetType["@type"]}`);
        }
    }
}
exports.convertToEthereumAssetType = convertToEthereumAssetType;
function convertOrderDataToEth(data) {
    switch (data["@type"]) {
        case "ETH_RARIBLE_V1": {
            return {
                dataType: "LEGACY",
                fee: +data.fee,
            };
        }
        case "ETH_RARIBLE_V2": {
            return {
                dataType: "RARIBLE_V2_DATA_V1",
                payouts: toEthereumParts(data.payouts),
                originFees: toEthereumParts(data.originFees),
            };
        }
        case "ETH_RARIBLE_V2_2": {
            return {
                dataType: "RARIBLE_V2_DATA_V2",
                payouts: toEthereumParts(data.payouts),
                originFees: toEthereumParts(data.originFees),
                isMakeFill: data.isMakeFill,
            };
        }
        case "ETH_RARIBLE_V2_3": {
            return {
                dataType: "RARIBLE_V2_DATA_V3",
                payouts: toEthereumParts(data.payouts),
                originFees: toEthereumParts(data.originFees),
                isMakeFill: data.isMakeFill,
            };
        }
        case "ETH_OPEN_SEA_V1": {
            return {
                dataType: "OPEN_SEA_V1_DATA_V1",
                exchange: convertToEthereumAddress(data.exchange),
                makerRelayerFee: data.makerRelayerFee,
                takerRelayerFee: data.takerRelayerFee,
                makerProtocolFee: data.makerProtocolFee,
                takerProtocolFee: data.takerProtocolFee,
                feeRecipient: convertToEthereumAddress(data.feeRecipient),
                feeMethod: OrderData_1.OrderOpenSeaV1DataV1FeeMethod[data.feeMethod],
                side: OrderData_1.OrderOpenSeaV1DataV1Side[data.side],
                saleKind: OrderData_1.OrderOpenSeaV1DataV1SaleKind[data.saleKind],
                howToCall: OrderData_1.OrderOpenSeaV1DataV1HowToCall[data.howToCall],
                callData: data.callData,
                replacementPattern: data.replacementPattern,
                staticTarget: convertToEthereumAddress(data.staticTarget),
                staticExtraData: data.staticExtraData,
                extra: data.extra,
            };
        }
        case "ETH_BASIC_SEAPORT_DATA_V1": {
            return {
                dataType: "BASIC_SEAPORT_DATA_V1",
                protocol: convertToEthereumAddress(data.protocol),
                orderType: SeaportOrderType_1.SeaportOrderType[data.orderType],
                offer: data.offer.map(offer => ({
                    itemType: SeaportItemType_1.SeaportItemType[offer.itemType],
                    token: convertToEthereumAddress(offer.token),
                    identifierOrCriteria: offer.identifierOrCriteria,
                    startAmount: offer.startAmount,
                    endAmount: offer.endAmount,
                })),
                consideration: data.consideration.map(data => ({
                    itemType: SeaportItemType_1.SeaportItemType[data.itemType],
                    token: convertToEthereumAddress(data.token),
                    identifierOrCriteria: data.identifierOrCriteria,
                    startAmount: data.startAmount,
                    endAmount: data.endAmount,
                    recipient: convertToEthereumAddress(data.recipient),
                })),
                zone: convertToEthereumAddress(data.zone),
                zoneHash: (0, types_1.toWord)(data.zoneHash),
                conduitKey: (0, types_1.toWord)(data.conduitKey),
                counter: data.counter,
                nonce: data.nonce,
            };
        }
        case "ETH_CRYPTO_PUNKS": {
            return {
                dataType: "CRYPTO_PUNKS_DATA",
            };
        }
        case "ETH_X2Y2_ORDER_DATA_V1": {
            return {
                dataType: "X2Y2_DATA",
                itemHash: (0, types_1.toWord)(data.itemHash),
                isCollectionOffer: data.isCollectionOffer,
                isBundle: data.isBundle,
                side: data.side,
                orderId: data.orderId,
            };
        }
        case "ETH_LOOKSRARE_ORDER_DATA_V1": {
            return {
                dataType: "LOOKSRARE_DATA_V1",
                minPercentageToAsk: data.minPercentageToAsk,
                strategy: convertToEthereumAddress(data.strategy),
                nonce: data.nonce,
                params: data.params && (0, types_1.toBinary)(data.params),
            };
        }
        case "ETH_LOOKSRARE_ORDER_DATA_V2": {
            return {
                dataType: "LOOKSRARE_DATA_V2",
                quoteType: OrderData_1.OrderLooksRareDataV2QuoteType[data.quoteType],
                globalNonce: data.globalNonce,
                orderNonce: data.orderNonce,
                subsetNonce: data.subsetNonce,
                strategyId: data.strategyId,
                additionalParameters: (0, types_1.toBinary)(data.strategyId),
                merkleRoot: data.merkleRoot && (0, types_1.toBinary)(data.merkleRoot),
                merkleProof: data.merkleProof,
            };
        }
        case "ETH_SUDOSWAP_AMM_DATA_V1": {
            return {
                dataType: "SUDOSWAP_AMM_DATA_V1",
                poolAddress: convertToEthereumAddress(data.poolAddress),
                bondingCurve: convertToEthereumAddress(data.bondingCurve),
                curveType: SudoSwapCurveType_1.SudoSwapCurveType[data.curveType],
                assetRecipient: convertToEthereumAddress(data.assetRecipient),
                poolType: SudoSwapPoolType_1.SudoSwapPoolType[data.poolType],
                delta: data.delta,
                fee: data.fee,
                feeDecimal: data.feeDecimal,
            };
        }
        default:
            throw new Error(`Unrecognized order data type: ${data["@type"]}`);
    }
}
exports.convertOrderDataToEth = convertOrderDataToEth;
function getEthOrderType(data) {
    switch (data["@type"]) {
        case "ETH_RARIBLE_V1":
            return "RARIBLE_V1";
        case "ETH_RARIBLE_V2":
        case "ETH_RARIBLE_V2_2":
        case "ETH_RARIBLE_V2_3":
            return "RARIBLE_V2";
        case "ETH_OPEN_SEA_V1":
            return "OPEN_SEA_V1";
        case "ETH_BASIC_SEAPORT_DATA_V1":
            return "SEAPORT_V1";
        case "ETH_CRYPTO_PUNKS":
            return "CRYPTO_PUNK";
        case "ETH_X2Y2_ORDER_DATA_V1":
            return "X2Y2";
        case "ETH_LOOKSRARE_ORDER_DATA_V1":
            return "LOOKSRARE";
        case "ETH_LOOKSRARE_ORDER_DATA_V2":
            return "LOOKSRARE_V2";
        case "ETH_SUDOSWAP_AMM_DATA_V1":
            return "AMM";
        default:
            throw new Error(`Unrecognized order data type: ${data["@type"]}`);
    }
}
exports.getEthOrderType = getEthOrderType;
function getEthOrder(ethereum, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return {
            hash: (0, types_1.toWord)(convertOrderIdToEthereumHash(order.id)),
            type: getEthOrderType(order.data),
            maker: convertToEthereumAddress(order.maker),
            make: yield convertToEthereumAsset(ethereum, order.make),
            take: yield convertToEthereumAsset(ethereum, order.take),
            taker: order.taker && convertToEthereumAddress(order.taker),
            salt: (0, types_1.toWord)(order.salt),
            start: order.startedAt && (0, get_expiration_date_1.convertDateToTimestamp)(new Date(order.startedAt)),
            end: order.endedAt && (0, get_expiration_date_1.convertDateToTimestamp)(new Date(order.endedAt)),
            signature: order.signature && (0, types_1.toBinary)(order.signature),
            data: convertOrderDataToEth(order.data),
        };
    });
}
exports.getEthOrder = getEthOrder;
function toEthereumParts(parts) {
    return (parts === null || parts === void 0 ? void 0 : parts.map(part => convertEthereumPart(part))) || [];
}
exports.toEthereumParts = toEthereumParts;
function convertEthereumPart(part) {
    return {
        account: convertToEthereumAddress(part.account),
        value: part.value,
    };
}
exports.convertEthereumPart = convertEthereumPart;
function getOriginFeesSum(originFees) {
    return originFees.reduce((prev, curr) => prev + curr.value, 0);
}
exports.getOriginFeesSum = getOriginFeesSum;
function getOrderFeesSum(order) {
    switch (order.data["@type"]) {
        case "ETH_RARIBLE_V1":
            return +order.data.fee;
        case "ETH_RARIBLE_V2":
        case "ETH_RARIBLE_V2_2":
        case "ETH_RARIBLE_V2_3":
            return getOriginFeesSum(order.data.originFees);
        default:
            throw new Error("Unexpected order dataType");
    }
}
exports.getOrderFeesSum = getOrderFeesSum;
function isRaribleV1Data(data) {
    return data["@type"] === "ETH_RARIBLE_V1";
}
exports.isRaribleV1Data = isRaribleV1Data;
function isRaribleV2Data(data) {
    return (data["@type"] === "ETH_RARIBLE_V2" || data["@type"] === "ETH_RARIBLE_V2_2" || data["@type"] === "ETH_RARIBLE_V2_3");
}
exports.isRaribleV2Data = isRaribleV2Data;
function convertOrderType(data) {
    if (isRaribleV1Data(data))
        return "RARIBLE_V1";
    if (isRaribleV2Data(data))
        return "RARIBLE_V2";
    throw new Error("Unknown order type " + data["@type"]);
}
exports.convertOrderType = convertOrderType;
function getOriginFeeSupport(data) {
    if (isRaribleV1Data(data)) {
        return domain_1.OriginFeeSupport.AMOUNT_ONLY;
    }
    if (isRaribleV2Data(data)) {
        return domain_1.OriginFeeSupport.FULL;
    }
    throw new Error("Unknown order type " + data["@type"]);
}
exports.getOriginFeeSupport = getOriginFeeSupport;
function getPayoutsSupport(data) {
    if (isRaribleV1Data(data)) {
        return domain_1.PayoutsSupport.SINGLE;
    }
    if (isRaribleV2Data(data)) {
        return domain_1.PayoutsSupport.MULTIPLE;
    }
    throw new Error("Unknown order type " + data["@type"]);
}
exports.getPayoutsSupport = getPayoutsSupport;
function getEVMBlockchain(network) {
    const blockchain = (0, common_1.getBlockchainBySDKNetwork)(network);
    if (!(0, build_1.isEVMBlockchain)(blockchain)) {
        throw new Error(`Network ${network} is not EVM compatible`);
    }
    return blockchain;
}
exports.getEVMBlockchain = getEVMBlockchain;
function extractEVMBlockchain(value) {
    const blockchain = (0, sdk_common_1.extractBlockchain)(value);
    if (!(0, build_1.isEVMBlockchain)(blockchain)) {
        throw new Error(`Blockchain ${blockchain} is not EVM compatible`);
    }
    return blockchain;
}
exports.extractEVMBlockchain = extractEVMBlockchain;
function getSupportedCurrencies(blockchain = api_client_1.Blockchain.ETHEREUM, forBids = false) {
    if (forBids) {
        return [{ blockchain, type: "ERC20" }];
    }
    return [
        { blockchain, type: "NATIVE" },
        { blockchain, type: "ERC20" },
    ];
}
exports.getSupportedCurrencies = getSupportedCurrencies;
function convertToEthereumAddress(contractAddress) {
    if (!(0, types_2.isRealBlockchainSpecified)(contractAddress)) {
        throw new Error("Not a union or contract address: " + contractAddress);
    }
    const [blockchain, address] = contractAddress.split(":");
    if (!(0, build_1.isEVMBlockchain)(blockchain)) {
        throw new Error("Not an Ethereum address");
    }
    return (0, types_1.toEVMAddress)(address);
}
exports.convertToEthereumAddress = convertToEthereumAddress;
function convertEthereumOrderHash(hash, blockchain) {
    return (0, types_1.toOrderId)(`${blockchain}:${hash}`);
}
exports.convertEthereumOrderHash = convertEthereumOrderHash;
function convertOrderIdToEthereumHash(orderId) {
    if (!(0, types_2.isRealBlockchainSpecified)(orderId)) {
        throw new Error(`Blockchain is not correct=${orderId}`);
    }
    const [blockchain, orderHash] = orderId.split(":");
    if (!(0, build_1.isEVMBlockchain)(blockchain)) {
        throw new Error("Not an Ethereum address");
    }
    return orderHash;
}
exports.convertOrderIdToEthereumHash = convertOrderIdToEthereumHash;
function convertEthereumContractAddress(address, blockchain) {
    if (!address)
        throw new Error("Address is undefined");
    return (0, types_1.toUnionContractAddress)(`${blockchain}:${address}`);
}
exports.convertEthereumContractAddress = convertEthereumContractAddress;
function convertEthereumCollectionId(address, blockchain) {
    return (0, types_1.toCollectionId)(`${blockchain}:${address}`);
}
exports.convertEthereumCollectionId = convertEthereumCollectionId;
function convertEthereumToUnionAddress(address, blockchain = api_client_1.Blockchain.ETHEREUM) {
    return (0, types_1.toUnionAddress)(`${blockchain}:${address}`);
}
exports.convertEthereumToUnionAddress = convertEthereumToUnionAddress;
function convertEthereumItemId(itemId, blockchain) {
    return (0, types_1.toItemId)(`${blockchain}:${itemId}`);
}
exports.convertEthereumItemId = convertEthereumItemId;
function getEthereumItemId(itemId) {
    if (!itemId) {
        throw new Error("ItemId has not been specified");
    }
    const [domain, contract, tokenId] = itemId.split(":");
    if (!(0, build_1.isEVMBlockchain)(domain)) {
        throw new Error(`Not an ethereum item: ${itemId}`);
    }
    return {
        itemId: `${contract}:${tokenId}`,
        contract,
        tokenId,
        domain,
    };
}
exports.getEthereumItemId = getEthereumItemId;
function getOrderAmount(orderAmount, collection) {
    let amount = collection.type === "ERC721" ? 1 : orderAmount;
    if (amount === undefined) {
        throw new Error("You should set amount of asset");
    }
    return amount;
}
exports.getOrderAmount = getOrderAmount;
function getOrderId(fillRequest) {
    if ("order" in fillRequest) {
        return fillRequest.order.id;
    }
    else if ("orderId" in fillRequest) {
        return fillRequest.orderId;
    }
    throw new Error("OrderId has not been found in request");
}
exports.getOrderId = getOrderId;
function getAssetTypeFromItemId(itemId) {
    const { contract, tokenId } = getEthereumItemId(itemId);
    return {
        contract: (0, types_1.toEVMAddress)(contract),
        tokenId,
    };
}
exports.getAssetTypeFromItemId = getAssetTypeFromItemId;
function getAssetTypeFromFillRequest(itemId) {
    if (!itemId) {
        return undefined;
    }
    if (Array.isArray(itemId)) {
        return itemId.map(item => {
            return getAssetTypeFromItemId(item);
        });
    }
    return getAssetTypeFromItemId(itemId);
}
exports.getAssetTypeFromFillRequest = getAssetTypeFromFillRequest;
function assertWallet(wallet) {
    if (!wallet)
        throw new build_1.WalletIsUndefinedError();
    return wallet;
}
exports.assertWallet = assertWallet;
function getWalletBlockchain(wallet) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (0, common_1.getBlockchainFromChainId)(yield assertWallet(wallet).ethereum.getChainId());
    });
}
exports.getWalletBlockchain = getWalletBlockchain;
function getWalletNetwork(wallet) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (0, common_1.getNetworkFromChainId)(yield assertWallet(wallet).ethereum.getChainId());
    });
}
exports.getWalletNetwork = getWalletNetwork;
function checkWalletBlockchain(wallet, blockchain) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const walletChainId = yield assertWallet(wallet).ethereum.getChainId();
        assertBlockchainAndChainId(walletChainId, blockchain);
    });
}
exports.checkWalletBlockchain = checkWalletBlockchain;
function assertBlockchainAndChainId(chainId, blockchain) {
    if ((0, common_1.getBlockchainFromChainId)(chainId) !== blockchain) {
        throw new Error(`Change network of your wallet to ${blockchain}`);
    }
}
exports.assertBlockchainAndChainId = assertBlockchainAndChainId;
function isRaribleOrderData(data) {
    return isRaribleV1Data(data) || isRaribleV2Data(data);
}
exports.isRaribleOrderData = isRaribleOrderData;
function isNft(type) {
    switch (type["@type"]) {
        case "ERC721":
        case "ERC1155":
        case "ERC721_Lazy":
        case "ERC1155_Lazy":
        case "CRYPTO_PUNKS":
            return true;
        default:
            return false;
    }
}
exports.isNft = isNft;
function isWETH(assetType, wethAddress) {
    return assetType["@type"] === "ERC20" && convertToEthereumAddress(assetType.contract) === wethAddress;
}
exports.isWETH = isWETH;
