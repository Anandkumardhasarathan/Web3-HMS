"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumCreateCollection = void 0;
const tslib_1 = require("tslib");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const sdk_common_1 = require("@rarible/sdk-common");
const common_1 = require("@rarible/protocol-ethereum-sdk/build/common");
const common_2 = require("./common");
class EthereumCreateCollection {
    constructor(sdk, wallet) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.createCollectionSimplified = this.createCollectionSimplified.bind(this);
    }
    convertOperatorsAddresses(operators) {
        if (!operators) {
            throw new Error("Operators should be provided in case of deploy private collection");
        }
        return operators.map(o => (0, common_2.convertToEthereumAddress)(o));
    }
    convertResponse(response) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const chainId = yield (0, common_2.assertWallet)(this.wallet).ethereum.getChainId();
            const network = yield (0, common_1.getNetworkFromChainId)(chainId);
            const blockchain = yield (0, common_1.getBlockchainFromChainId)(chainId);
            return {
                tx: new sdk_transaction_1.BlockchainEthereumTransaction(response.tx, network),
                address: (0, common_2.convertEthereumContractAddress)(response.address, blockchain),
            };
        });
    }
    startCreateCollection(asset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const deployCommonArguments = [
                asset.arguments.name,
                asset.arguments.symbol,
                asset.arguments.baseURI,
                asset.arguments.contractURI,
            ];
            if (asset.arguments.isUserToken) {
                const operators = this.convertOperatorsAddresses(asset.arguments.operators);
                if (asset.assetType === "ERC721") {
                    return this.sdk.nft.deploy.erc721.deployUserToken(...deployCommonArguments, operators);
                }
                else if (asset.assetType === "ERC1155") {
                    return this.sdk.nft.deploy.erc1155.deployUserToken(...deployCommonArguments, operators);
                }
                else {
                    throw new Error("Unsupported asset type");
                }
            }
            else {
                if (asset.assetType === "ERC721") {
                    return this.sdk.nft.deploy.erc721.deployToken(...deployCommonArguments);
                }
                else if (asset.assetType === "ERC1155") {
                    return this.sdk.nft.deploy.erc1155.deployToken(...deployCommonArguments);
                }
                else {
                    throw new Error("Unsupported asset type");
                }
            }
        });
    }
    createCollectionSimplified(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!isEthereumRequest(request)) {
                throw new Error("Wrong blockchain");
            }
            return this.convertResponse(yield this.startCreateCollection({
                assetType: request.type,
                arguments: {
                    name: request.name,
                    symbol: request.symbol,
                    baseURI: request.baseURI,
                    contractURI: request.contractURI,
                    isUserToken: !request.isPublic,
                    operators: "operators" in request ? request.operators : [],
                },
            }));
        });
    }
}
exports.EthereumCreateCollection = EthereumCreateCollection;
function isEthereumRequest(x) {
    return (0, sdk_common_1.isEVMBlockchain)(x.blockchain);
}
