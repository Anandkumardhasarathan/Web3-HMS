"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumCryptopunk = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const common_1 = require("./common");
class EthereumCryptopunk {
    constructor(sdk, wallet) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.wrap = action_1.Action.create({
            id: "approve-tx",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!request.punkId) {
                    throw new Error("PunkId has not been specified");
                }
                const tx = yield this.sdk.nft.cryptoPunks.approveForWrapper(request.punkId);
                if (tx) {
                    yield new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet)).wait();
                }
                return request;
            }),
        }).thenStep({
            id: "wrap-tx",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const tx = yield this.sdk.nft.cryptoPunks.wrap(request.punkId);
                return new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet));
            }),
        });
        this.unwrap = action_1.Action.create({
            id: "unwrap-tx",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!request.punkId) {
                    throw new Error("PunkId has not been specified");
                }
                const tx = yield this.sdk.nft.cryptoPunks.unwrap(request.punkId);
                return new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet));
            }),
        });
    }
}
exports.EthereumCryptopunk = EthereumCryptopunk;
