"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumFill = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const build_1 = require("@rarible/logger/build");
const sdk_common_1 = require("@rarible/sdk-common");
const domain_1 = require("../../types/order/fill/domain");
const check_payouts_1 = require("../../common/check-payouts");
const common_1 = require("./common");
class EthereumFill {
    constructor(sdk, wallet, apis) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.fill = this.fill.bind(this);
        this.buy = this.buy.bind(this);
        this.batchBuy = this.batchBuy.bind(this);
        this.acceptBid = this.acceptBid.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
        this.batchBuyBasic = this.batchBuyBasic.bind(this);
        this.getBuyAmmInfo = this.getBuyAmmInfo.bind(this);
        this.getBuyTxData = this.getBuyTxData.bind(this);
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.buy(request);
            return prepare.submit(request);
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.acceptBid(request);
            return prepare.submit(request);
        });
    }
    getFillOrderRequest(order, fillRequest) {
        var _a, _b, _c, _d;
        let request;
        switch (order.type) {
            case "RARIBLE_V1": {
                request = {
                    order,
                    amount: fillRequest.amount,
                    infinite: fillRequest.infiniteApproval,
                    originFee: ((_b = (_a = fillRequest.originFees) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.value) ? fillRequest.originFees[0].value : 0,
                    payout: ((_d = (_c = fillRequest.payouts) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.account)
                        ? (0, common_1.convertToEthereumAddress)(fillRequest.payouts[0].account)
                        : undefined,
                };
                break;
            }
            case "RARIBLE_V2": {
                request = {
                    order,
                    amount: fillRequest.amount,
                    infinite: fillRequest.infiniteApproval,
                    payouts: (0, common_1.toEthereumParts)(fillRequest.payouts),
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                };
                break;
            }
            case "OPEN_SEA_V1": {
                request = {
                    order,
                    originFees: order.take.assetType.assetClass === "ETH" ? (0, common_1.toEthereumParts)(fillRequest.originFees) : [],
                    payouts: (0, common_1.toEthereumParts)(fillRequest.payouts),
                    infinite: fillRequest.infiniteApproval,
                };
                break;
            }
            case "SEAPORT_V1": {
                request = {
                    order,
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                    amount: fillRequest.amount,
                };
                break;
            }
            case "LOOKSRARE": {
                request = {
                    order,
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                    amount: fillRequest.amount,
                };
                break;
            }
            case "LOOKSRARE_V2": {
                request = {
                    order,
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                    amount: fillRequest.amount,
                };
                break;
            }
            case "X2Y2": {
                request = {
                    order,
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                    amount: fillRequest.amount,
                };
                break;
            }
            case "AMM": {
                return {
                    order,
                    originFees: (0, common_1.toEthereumParts)(fillRequest.originFees),
                    amount: fillRequest.amount,
                    assetType: (0, common_1.getAssetTypeFromFillRequest)(fillRequest.itemId),
                    addRoyalty: fillRequest.addRoyalties,
                };
            }
            default: {
                throw new Error("Unsupported order type");
            }
        }
        if (fillRequest.addRoyalties) {
            throw new build_1.Warning("Adding royalties is available only for AMM orders");
        }
        if (fillRequest.itemId) {
            if (Array.isArray(fillRequest.itemId)) {
                throw new Error("Array of itemIds is supported only for AMM orders");
            }
            const { contract, tokenId } = (0, common_1.getEthereumItemId)(fillRequest.itemId);
            request.assetType = {
                contract: (0, types_1.toEVMAddress)(contract),
                tokenId,
            };
        }
        return request;
    }
    getSupportFlags(order) {
        switch (order.data["@type"]) {
            case "ETH_RARIBLE_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.AMOUNT_ONLY,
                    payoutsSupport: domain_1.PayoutsSupport.SINGLE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            }
            case "ETH_RARIBLE_V2":
            case "ETH_RARIBLE_V2_2": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            }
            case "ETH_RARIBLE_V2_3":
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            case "ETH_OPEN_SEA_V1": {
                return {
                    originFeeSupport: order.take.type["@type"] === "ETH" ? domain_1.OriginFeeSupport.FULL : domain_1.OriginFeeSupport.NONE,
                    payoutsSupport: domain_1.PayoutsSupport.SINGLE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: false,
                };
            }
            case "ETH_BASIC_SEAPORT_DATA_V1": {
                const supportsPartialFill = order.data.orderType === "PARTIAL_OPEN" || order.data.orderType === "PARTIAL_RESTRICTED";
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill,
                };
            }
            case "ETH_LOOKSRARE_ORDER_DATA_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            }
            case "ETH_LOOKSRARE_ORDER_DATA_V2": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            }
            case "ETH_SUDOSWAP_AMM_DATA_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                };
            }
            case "ETH_X2Y2_ORDER_DATA_V1": {
                return {
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.NONE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: false,
                };
            }
            default:
                throw new Error("Unsupported order type");
        }
    }
    getPlatform(order) {
        switch (order.data["@type"]) {
            case "ETH_RARIBLE_V1":
            case "ETH_RARIBLE_V2":
            case "ETH_RARIBLE_V2_2":
            case "ETH_RARIBLE_V2_3":
                return api_client_1.Platform.RARIBLE;
            case "ETH_OPEN_SEA_V1":
            case "ETH_BASIC_SEAPORT_DATA_V1":
                return api_client_1.Platform.OPEN_SEA;
            case "ETH_LOOKSRARE_ORDER_DATA_V1":
            case "ETH_LOOKSRARE_ORDER_DATA_V2":
                return api_client_1.Platform.LOOKSRARE;
            case "ETH_SUDOSWAP_AMM_DATA_V1":
                return api_client_1.Platform.SUDOSWAP;
            case "ETH_X2Y2_ORDER_DATA_V1":
                return api_client_1.Platform.X2Y2;
            case "ETH_CRYPTO_PUNKS":
                return api_client_1.Platform.CRYPTO_PUNKS;
            default:
                return api_client_1.Platform.RARIBLE;
        }
    }
    getMaxAmount(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (order.take.type["@type"] === "COLLECTION") {
                return null;
            }
            if ((0, common_1.isNft)(order.take.type)) {
                if (this.wallet === undefined) {
                    throw new Error("Wallet undefined");
                }
                const address = yield this.wallet.ethereum.getFrom();
                const ownershipId = `${order.take.type.contract}:${order.take.type.tokenId}:${(0, types_1.toEVMAddress)(address)}`;
                const ownership = yield this.apis.ownership.getOwnershipById({ ownershipId });
                return (0, types_1.toBigNumber)(utils_1.BigNumber.min(ownership.value, order.take.value).toFixed());
            }
            return order.makeStock;
        });
    }
    isMultiple(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let contract;
            if ((0, common_1.isNft)(order.take.type) || order.take.type["@type"] === "COLLECTION") {
                contract = order.take.type.contract;
            }
            else if ((0, common_1.isNft)(order.make.type) || order.make.type["@type"] === "COLLECTION") {
                contract = order.make.type.contract;
            }
            else if (order.make.type["@type"] === "AMM_NFT") {
                return false;
            }
            else {
                throw new Error("Nft has not been found");
            }
            const collection = yield this.apis.collection.getCollectionById({
                collection: contract,
            });
            return collection.type === "ERC1155";
        });
    }
    hasCollectionAssetType(order) {
        return order.take.type["@type"] === "COLLECTION" || order.make.type["@type"] === "COLLECTION";
    }
    commonFill(action_1, request_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (action, request, isBid = false) {
            const orderId = (0, common_1.getOrderId)(request);
            const blockchain = (0, sdk_common_1.extractBlockchain)(orderId);
            if (!(0, common_1.isEVMBlockchain)(blockchain))
                throw new Error("Not an EVM order");
            const order = yield this.apis.order.getValidatedOrderById({ id: orderId });
            const ethOrder = yield (0, common_1.getEthOrder)((0, common_1.assertWallet)(this.wallet).ethereum, order);
            const submit = action.around((fillRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                (0, check_payouts_1.checkPayouts)(fillRequest.payouts);
                if (fillRequest.unwrap) {
                    throw new build_1.Warning("Unwrap is not supported yet");
                }
                if (this.hasCollectionAssetType(order) && !fillRequest.itemId) {
                    throw new build_1.Warning("For collection order you should pass itemId");
                }
                return this.getFillOrderRequest(ethOrder, fillRequest);
            }), (tx) => tslib_1.__awaiter(this, void 0, void 0, function* () { return new sdk_transaction_1.BlockchainEthereumTransaction(tx, yield (0, common_1.getWalletNetwork)(this.wallet)); }));
            const nftAssetType = isBid ? order.take.type : order.make.type;
            return Object.assign(Object.assign({}, this.getSupportFlags(order)), { multiple: yield this.isMultiple(order), maxAmount: yield this.getMaxAmount(order), baseFee: yield this.sdk.order.getFillOrderBaseFee(ethOrder, request.withOriginFees), submit, orderData: {
                    platform: this.getPlatform(order),
                    nftCollection: "contract" in nftAssetType && nftAssetType.contract !== undefined
                        ? (0, types_1.toUnionContractAddress)(nftAssetType.contract)
                        : undefined,
                } });
        });
    }
    /**
     * @deprecated
     * @param request
     */
    fill(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.commonFill(this.sdk.order.fill, request);
        });
    }
    buy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.commonFill(this.sdk.order.buy, request);
        });
    }
    acceptBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.commonFill(this.sdk.order.acceptBid, request, true);
        });
    }
    batchBuy(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const orders = {}; // ethereum orders cache
            const submit = this.sdk.order.buyBatch.around((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const walletChainId = yield (0, common_1.assertWallet)(this.wallet).ethereum.getChainId();
                return request.map(req => {
                    const blockchain = (0, sdk_common_1.extractBlockchain)(req.orderId);
                    (0, common_1.assertBlockchainAndChainId)(walletChainId, blockchain);
                    (0, check_payouts_1.checkPayouts)(req.payouts);
                    const order = orders[req.orderId];
                    if (!order) {
                        throw new Error(`Order with id ${req.orderId} not precached`);
                    }
                    if (req.unwrap) {
                        throw new Error("Unwrap is not supported yet");
                    }
                    return this.getFillOrderRequest(order, req);
                });
            }), (tx, request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const network = yield (0, common_1.getWalletNetwork)(this.wallet);
                return new sdk_transaction_1.BlockchainEthereumTransaction(tx, network, (getEvents) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _a;
                    try {
                        const events = (yield getEvents()) || [];
                        let executionEvents = [];
                        for (let event of events) {
                            if ("0" in event && ((_a = event[0]) === null || _a === void 0 ? void 0 : _a.event) === "Execution") {
                                if (Array.isArray(event)) {
                                    executionEvents.push(...event);
                                }
                                else {
                                    // cycling over events "subarray", because web3 provider
                                    // returning it not as real array, but as object
                                    let i = 0;
                                    while (event[i]) {
                                        executionEvents.push(event[i]);
                                        i += 1;
                                    }
                                }
                            }
                            else if (event.event === "Execution") {
                                executionEvents.push(event);
                            }
                        }
                        if (executionEvents) {
                            return {
                                type: "BATCH_BUY",
                                results: request.map((req, index) => {
                                    var _a, _b, _c;
                                    return ({
                                        orderId: req.orderId,
                                        result: (((_a = executionEvents[index]) === null || _a === void 0 ? void 0 : _a.data) || ((_c = (_b = executionEvents[index]) === null || _b === void 0 ? void 0 : _b.raw) === null || _c === void 0 ? void 0 : _c.data)) === // ethers variant // web3 variant
                                            "0x0000000000000000000000000000000000000000000000000000000000000001",
                                    });
                                }),
                            };
                        }
                        else {
                            return undefined;
                        }
                    }
                    catch (e) {
                        console.error("Can't parse transaction events", e);
                        return undefined;
                    }
                }));
            }));
            const prepared = yield Promise.all(prepareRequest.map((req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const orderId = (0, common_1.getOrderId)(req);
                const unionOrder = yield this.apis.order.getOrderById({ id: orderId });
                const blockchain = (0, sdk_common_1.extractBlockchain)(orderId);
                const order = yield (0, common_1.getEthOrder)((0, common_1.assertWallet)(this.wallet).ethereum, unionOrder);
                orders[orderId] = order;
                if (unionOrder.status !== "ACTIVE") {
                    throw new Error(`Order with id ${orderId} is not active`);
                }
                if (order.type !== "OPEN_SEA_V1" &&
                    order.type !== "RARIBLE_V2" &&
                    order.type !== "SEAPORT_V1" &&
                    order.type !== "LOOKSRARE" &&
                    order.type !== "LOOKSRARE_V2" &&
                    order.type !== "AMM" &&
                    order.type !== "X2Y2") {
                    throw new Error(`Order type ${order.type} is not supported for batch buy`);
                }
                if (order.make.assetType.assetClass === "ETH" || order.make.assetType.assetClass === "ERC20") {
                    throw new Error("Bid orders is not supported");
                }
                return Object.assign(Object.assign({ orderId }, this.getSupportFlags(unionOrder)), { multiple: yield this.isMultiple(unionOrder), maxAmount: yield this.getMaxAmount(unionOrder), baseFee: yield this.sdk.order.getFillOrderBaseFee(order, req.withOriginFees), orderData: {
                        platform: this.getPlatform(unionOrder),
                        nftCollection: "contract" in order.make.assetType
                            ? (0, common_1.convertEthereumContractAddress)(order.make.assetType.contract, blockchain)
                            : undefined,
                    } });
            })));
            return {
                submit,
                prepared,
            };
        });
    }
    getBuyAmmInfo(request) {
        return this.sdk.order.getBuyAmmInfo({
            hash: request.hash,
            numNFTs: request.numNFTs,
        });
    }
    getBuyTxData(input) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const unionOrderId = (0, common_1.getOrderId)(input.request);
            const order = yield this.apis.order.getValidatedOrderById({ id: unionOrderId });
            const ethOrder = yield (0, common_1.getEthOrder)((0, common_1.assertWallet)(this.wallet).ethereum, order);
            let from;
            if (input.from) {
                from = (0, types_1.toEVMAddress)((0, sdk_common_1.extractId)(input.from));
            }
            else if (this.wallet) {
                from = (0, types_1.toEVMAddress)(yield this.wallet.ethereum.getFrom());
            }
            else {
                throw new Error("Request doesn't contain `from` address");
            }
            const ethRequest = this.getFillOrderRequest(ethOrder, input.request);
            return this.sdk.order.getBuyTxData({
                request: ethRequest,
                from,
            });
        });
    }
    batchBuyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.batchBuy(request);
            return response.submit(request);
        });
    }
}
exports.EthereumFill = EthereumFill;
