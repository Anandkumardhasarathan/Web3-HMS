"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEthereumSdk = void 0;
const protocol_ethereum_sdk_1 = require("@rarible/protocol-ethereum-sdk");
const api_client_1 = require("@rarible/api-client");
const types_1 = require("@rarible/types");
const domain_1 = require("../../domain");
const middleware_1 = require("../../common/middleware/middleware");
const upload_meta_1 = require("../union/meta/upload-meta");
const apis_1 = require("../../common/apis");
const common_1 = require("../../types/common");
const mint_1 = require("./mint");
const sell_1 = require("./sell");
const fill_1 = require("./fill");
const burn_1 = require("./burn");
const transfer_1 = require("./transfer");
const bid_1 = require("./bid");
const cancel_1 = require("./cancel");
const balance_1 = require("./balance");
const token_id_1 = require("./token-id");
const create_collection_1 = require("./create-collection");
const cryptopunk_1 = require("./cryptopunk");
function createEthereumSdk(wallet, apis, blockchain, network, config) {
    var _a, _b;
    const sdkConfig = {
        apiClientParams: Object.assign(Object.assign({}, ((config === null || config === void 0 ? void 0 : config.params) || {})), { middleware: [
                ...(((_a = config.logs) === null || _a === void 0 ? void 0 : _a.level) !== domain_1.LogsLevel.DISABLED
                    ? [(0, apis_1.getErrorHandlerMiddleware)(apis_1.NetworkErrorCode.ETHEREUM_NETWORK_ERR)]
                    : []),
                ...(((_b = config === null || config === void 0 ? void 0 : config.params) === null || _b === void 0 ? void 0 : _b.middleware) || []),
            ] }),
        logs: config.logs,
        ethereum: config[api_client_1.Blockchain.ETHEREUM],
        polygon: config[api_client_1.Blockchain.POLYGON],
        marketplaceMarker: config.marketplaceMarker ? (0, types_1.toBinary)(config.marketplaceMarker) : undefined,
        apiKey: config.apiKey,
    };
    const sdk = (0, protocol_ethereum_sdk_1.createRaribleSdk)(wallet === null || wallet === void 0 ? void 0 : wallet.ethereum, network, sdkConfig);
    const sellService = new sell_1.EthereumSell(sdk, wallet, apis);
    const balanceService = new balance_1.EthereumBalance(sdk, wallet, apis);
    const bidService = new bid_1.EthereumBid(sdk, wallet, apis, balanceService);
    const mintService = new mint_1.EthereumMint(sdk, wallet, apis);
    const fillService = new fill_1.EthereumFill(sdk, wallet, apis);
    const { createCollectionSimplified } = new create_collection_1.EthereumCreateCollection(sdk, wallet);
    const cryptopunkService = new cryptopunk_1.EthereumCryptopunk(sdk, wallet);
    const transferService = new transfer_1.EthereumTransfer(sdk, wallet, apis);
    const burnService = new burn_1.EthereumBurn(sdk, wallet, apis, network);
    const cancelService = new cancel_1.EthereumCancel(sdk, wallet, apis);
    const preprocessMeta = middleware_1.Middlewarer.skipMiddleware(mintService.preprocessMeta);
    const metaUploader = new upload_meta_1.MetaUploader(api_client_1.Blockchain.ETHEREUM, preprocessMeta);
    return {
        nft: {
            mint: new common_1.MethodWithPrepare(mintService.mintBasic, mintService.prepare),
            burn: new common_1.MethodWithPrepare(burnService.burnBasic, burnService.burn),
            transfer: new common_1.MethodWithPrepare(transferService.transferBasic, transferService.transfer),
            generateTokenId: new token_id_1.EthereumTokenId(sdk, apis).generateTokenId,
            createCollection: createCollectionSimplified,
            preprocessMeta,
            uploadMeta: metaUploader.uploadMeta,
        },
        order: {
            fill: { prepare: fillService.fill },
            buy: new common_1.MethodWithPrepare(fillService.buyBasic, fillService.buy),
            batchBuy: new common_1.MethodWithPrepare(fillService.batchBuyBasic, fillService.batchBuy),
            acceptBid: new common_1.MethodWithPrepare(fillService.acceptBidBasic, fillService.acceptBid),
            sell: new common_1.MethodWithPrepare(sellService.sellBasic, sellService.sell),
            sellUpdate: new common_1.MethodWithPrepare(sellService.sellUpdateBasic, sellService.update),
            bid: new common_1.MethodWithPrepare(bidService.bidBasic, bidService.bid),
            bidUpdate: new common_1.MethodWithPrepare(bidService.bidUpdateBasic, bidService.update),
            cancel: cancelService.cancel,
        },
        balances: {
            getBalance: balanceService.getBalance,
            convert: balanceService.convert,
            transfer: balanceService.transfer,
            getBiddingBalance: balanceService.getBiddingBalance,
            depositBiddingBalance: balanceService.depositBiddingBalance,
            withdrawBiddingBalance: balanceService.withdrawBiddingBalance,
        },
        restriction: {
            canTransfer() {
                return Promise.resolve({ success: true });
            },
            getFutureOrderFees() {
                return sellService.getFutureOrderFees();
            },
        },
        ethereum: {
            wrapCryptoPunk: cryptopunkService.wrap,
            unwrapCryptoPunk: cryptopunkService.unwrap,
            getBatchBuyAmmInfo: fillService.getBuyAmmInfo,
            getBuyTxData: fillService.getBuyTxData,
        },
    };
}
exports.createEthereumSdk = createEthereumSdk;
