"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnsupportedBlockchainError = exports.UnsupportedCollectionError = exports.LazyMintIsNotSupportedError = exports.getCollection = exports.EthereumMint = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const EthereumSdk = tslib_1.__importStar(require("@rarible/protocol-ethereum-sdk"));
const protocol_ethereum_sdk_1 = require("@rarible/protocol-ethereum-sdk");
const mint_1 = require("@rarible/protocol-ethereum-sdk/build/nft/mint");
const Collection_1 = require("@rarible/api-client/build/models/Collection");
const NftCollection_1 = require("@rarible/ethereum-api-client/build/models/NftCollection");
const types_1 = require("@rarible/types");
const ethereum_api_client_1 = require("@rarible/ethereum-api-client");
const utils_1 = require("@rarible/utils");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const sdk_common_1 = require("@rarible/sdk-common");
const prepare_1 = require("../../types/nft/mint/prepare");
const get_collection_id_1 = require("../../common/get-collection-id");
const common_1 = require("./common");
const common_2 = require("./common");
class EthereumMint {
    constructor(sdk, wallet, apis) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.prepare = this.prepare.bind(this);
        this.mintBasic = this.mintBasic.bind(this);
    }
    handleSubmit(blockchain, request, nftCollection, nftTokenId) {
        var _a, _b;
        if (request.lazyMint && !this.isSupportsLazyMint(blockchain, nftCollection)) {
            throw new LazyMintIsNotSupportedError(nftCollection.type);
        }
        const isLazy = (_a = request.lazyMint) !== null && _a !== void 0 ? _a : false;
        const supply = (_b = request.supply) !== null && _b !== void 0 ? _b : 1;
        if (EthereumSdk.isErc721v3Collection(nftCollection)) {
            return this.sdk.nft.mint({
                collection: nftCollection,
                uri: request.uri,
                lazy: isLazy,
                royalties: this.toPart(request.royalties),
                creators: this.toPart(request.creators),
                nftTokenId,
            });
        }
        if (EthereumSdk.isErc721v2Collection(nftCollection)) {
            return this.sdk.nft.mint({
                collection: nftCollection,
                uri: request.uri,
                royalties: this.toPart(request.royalties),
                nftTokenId,
            });
        }
        if (EthereumSdk.isErc721v1Collection(nftCollection)) {
            return this.sdk.nft.mint({
                collection: nftCollection,
                uri: request.uri,
                nftTokenId,
            });
        }
        if (EthereumSdk.isErc1155v2Collection(nftCollection)) {
            return this.sdk.nft.mint({
                collection: nftCollection,
                uri: request.uri,
                supply,
                lazy: isLazy,
                royalties: this.toPart(request.royalties),
                creators: this.toPart(request.creators),
                nftTokenId,
            });
        }
        if (EthereumSdk.isErc1155v1Collection(nftCollection)) {
            return this.sdk.nft.mint({
                collection: nftCollection,
                uri: request.uri,
                supply,
                royalties: this.toPart(request.royalties),
                nftTokenId,
            });
        }
        throw new Error("Unsupported NFT Collection");
    }
    toPart(royalties = []) {
        return royalties.map(r => ({
            account: (0, common_2.convertToEthereumAddress)(r.account),
            value: (0, utils_1.toBn)(r.value).toNumber(),
        }));
    }
    isSupportsRoyalties(collection) {
        switch (collection.type) {
            case ethereum_api_client_1.NftCollectionType.ERC721:
                return (0, protocol_ethereum_sdk_1.isErc721v3Collection)(collection) || (0, protocol_ethereum_sdk_1.isErc721v2Collection)(collection);
            case ethereum_api_client_1.NftCollectionType.ERC1155:
                return true;
            default:
                throw new Error("Unrecognized collection type");
        }
    }
    isSupportsLazyMint(blockchain, collection) {
        switch (blockchain) {
            case api_client_1.Blockchain.ETHEREUM:
                return (0, protocol_ethereum_sdk_1.isErc721v3Collection)(collection) || (0, protocol_ethereum_sdk_1.isErc1155v2Collection)(collection);
            default:
                return false;
        }
    }
    prepare(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const collection = yield getCollection(this.apis.collection, request);
            const nftCollection = toNftCollection(collection);
            const blockchain = (0, sdk_common_1.extractBlockchain)((0, get_collection_id_1.getCollectionId)(request));
            yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
            return {
                multiple: collection.type === api_client_1.CollectionType.ERC1155,
                supportsRoyalties: this.isSupportsRoyalties(nftCollection),
                supportsLazyMint: this.isSupportsLazyMint(blockchain, nftCollection),
                submit: action_1.Action.create({
                    id: "mint",
                    run: (data) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                        const mintResponse = yield this.handleSubmit(blockchain, data, nftCollection, toNftTokenId(request.tokenId));
                        switch (mintResponse.type) {
                            case mint_1.MintResponseTypeEnum.ON_CHAIN:
                                return {
                                    type: prepare_1.MintType.ON_CHAIN,
                                    itemId: (0, common_2.convertEthereumItemId)(mintResponse.itemId, blockchain),
                                    transaction: new sdk_transaction_1.BlockchainEthereumTransaction(mintResponse.transaction, yield (0, common_1.getWalletNetwork)(this.wallet)),
                                };
                            case mint_1.MintResponseTypeEnum.OFF_CHAIN:
                                return {
                                    type: prepare_1.MintType.OFF_CHAIN,
                                    itemId: (0, common_2.convertEthereumItemId)(mintResponse.itemId, blockchain),
                                };
                            default:
                                throw new Error("Unrecognized mint response type");
                        }
                    }),
                }),
            };
        });
    }
    // eslint-disable-next-line no-dupe-class-members
    mintBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepareResponse = yield this.prepare(request);
            return prepareResponse.submit(request);
        });
    }
    preprocessMeta(meta) {
        var _a, _b;
        if (!isEvmMeta(meta)) {
            throw new UnsupportedBlockchainError(meta.blockchain);
        }
        return {
            name: meta.name,
            description: meta.description,
            image: (_a = meta.image) === null || _a === void 0 ? void 0 : _a.url,
            animation_url: (_b = meta.animation) === null || _b === void 0 ? void 0 : _b.url,
            external_url: meta.external,
            attributes: meta.attributes,
        };
    }
}
exports.EthereumMint = EthereumMint;
function getCollection(api, req) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ("collection" in req) {
            return req.collection;
        }
        return api.getCollectionById({ collection: req.collectionId });
    });
}
exports.getCollection = getCollection;
function isNftCollectionFeatures(feature) {
    return feature in ethereum_api_client_1.NftCollectionFeatures;
}
function toNftCollection(collection) {
    var _a, _b;
    if (!isSupportedCollection(collection.type)) {
        throw new UnsupportedCollectionError(collection.type);
    }
    return Object.assign(Object.assign({}, collection), { status: toCollectionStatus(collection.status), id: (0, types_1.toEVMAddress)((0, common_2.convertToEthereumAddress)(collection.id)), type: ethereum_api_client_1.NftCollectionType[collection.type], owner: collection.owner ? (0, common_2.convertToEthereumAddress)(collection.owner) : undefined, features: (_a = collection.features) === null || _a === void 0 ? void 0 : _a.reduce((acc, x) => {
            if (isNftCollectionFeatures(x)) {
                acc.push(ethereum_api_client_1.NftCollectionFeatures[x]);
            }
            return acc;
        }, []), minters: (_b = collection.minters) === null || _b === void 0 ? void 0 : _b.map(x => (0, common_2.convertToEthereumAddress)(x)) });
}
function toCollectionStatus(status) {
    switch (status) {
        case undefined:
            return undefined;
        case Collection_1.CollectionStatus.ERROR:
            return NftCollection_1.NftCollectionStatus.ERROR;
        case Collection_1.CollectionStatus.PENDING:
            return NftCollection_1.NftCollectionStatus.PENDING;
        case Collection_1.CollectionStatus.CONFIRMED:
            return NftCollection_1.NftCollectionStatus.CONFIRMED;
        default:
            throw new Error(`Unknown Collection Status (${status})`);
    }
}
const supportedCollectionTypes = [api_client_1.CollectionType.ERC721, api_client_1.CollectionType.ERC1155];
function isSupportedCollection(type) {
    return supportedCollectionTypes.includes(type);
}
function toNftTokenId(tokenId) {
    if (tokenId) {
        return {
            tokenId: (0, types_1.toBigNumber)(tokenId.tokenId),
            signature: tokenId.signature,
        };
    }
    return undefined;
}
class LazyMintIsNotSupportedError extends Error {
    constructor(collectionType) {
        super(`Lazy minting is not supported for ${collectionType}`);
        this.name = "LazyMintIsNotSupportedError";
        Object.setPrototypeOf(this, LazyMintIsNotSupportedError.prototype);
    }
}
exports.LazyMintIsNotSupportedError = LazyMintIsNotSupportedError;
class UnsupportedCollectionError extends Error {
    constructor(collectionType) {
        super(`Collection with type "${collectionType}" not supported`);
        this.name = "UnsupportedCollectionError";
        Object.setPrototypeOf(this, UnsupportedCollectionError.prototype);
    }
}
exports.UnsupportedCollectionError = UnsupportedCollectionError;
class UnsupportedBlockchainError extends Error {
    constructor(blockchain) {
        super(`${blockchain} is not supported`);
        this.name = "UnsupportedBlockchainError";
        Object.setPrototypeOf(this, UnsupportedBlockchainError.prototype);
    }
}
exports.UnsupportedBlockchainError = UnsupportedBlockchainError;
function isEvmMeta(x) {
    return (0, common_1.isEVMBlockchain)(x.blockchain);
}
