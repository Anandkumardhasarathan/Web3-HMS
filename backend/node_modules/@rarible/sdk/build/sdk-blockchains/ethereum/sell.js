"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumSell = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const sdk_common_1 = require("@rarible/sdk-common");
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const get_expiration_date_1 = require("../../common/get-expiration-date");
const check_payouts_1 = require("../../common/check-payouts");
const common = tslib_1.__importStar(require("./common"));
const common_1 = require("./common");
class EthereumSell {
    constructor(sdk, wallet, apis) {
        this.sdk = sdk;
        this.wallet = wallet;
        this.apis = apis;
        this.sell = this.sell.bind(this);
        this.update = this.update.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
        this.sellUpdateBasic = this.sellUpdateBasic.bind(this);
    }
    sell(req) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.sellDataV2(req);
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const blockchain = (0, sdk_common_1.extractBlockchain)(request.itemId);
            const totalFees = (request.originFees || []).reduce((sum, it) => sum + it.value, 0);
            const prepare = yield this.sell({ blockchain, withOriginFees: totalFees > 0 });
            return prepare.submit(request);
        });
    }
    sellUpdateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.update(request);
            return prepare.submit(request);
        });
    }
    getFutureOrderFees() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                baseFee: yield this.sdk.order.getBaseOrderFee(),
            };
        });
    }
    sellDataV2(req) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const defaultBaseFee = yield this.sdk.order.getBaseOrderFee();
            const shouldUseV3 = defaultBaseFee > 0 && req.withOriginFees !== false;
            const sellAction = this.sdk.order.sell.around((sellFormRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                yield (0, common_1.checkWalletBlockchain)(this.wallet, (0, sdk_common_1.extractBlockchain)(sellFormRequest.itemId));
                (0, check_payouts_1.checkPayouts)(sellFormRequest.payouts);
                const { tokenId, contract } = (0, common_1.getEthereumItemId)(sellFormRequest.itemId);
                const expirationDate = sellFormRequest.expirationDate
                    ? (0, get_expiration_date_1.convertDateToTimestamp)(sellFormRequest.expirationDate)
                    : (0, get_expiration_date_1.getDefaultExpirationDateTimestamp)();
                const currencyAssetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(sellFormRequest.currency);
                return {
                    type: shouldUseV3 ? "DATA_V3" : "DATA_V2",
                    makeAssetType: {
                        tokenId: tokenId,
                        contract: (0, types_1.toEVMAddress)(contract),
                    },
                    amount: (_a = sellFormRequest.amount) !== null && _a !== void 0 ? _a : 1,
                    takeAssetType: common.getEthTakeAssetType(currencyAssetType),
                    priceDecimal: sellFormRequest.price,
                    payouts: common.toEthereumParts(sellFormRequest.payouts),
                    originFees: common.toEthereumParts(sellFormRequest.originFees),
                    end: expirationDate,
                };
            }), (order) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                //todo replace with returned chainId/blockchain
                const blockchain = yield (0, common_1.getWalletBlockchain)(this.wallet);
                return common.convertEthereumOrderHash(order.hash, blockchain);
            }));
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: common.getSupportedCurrencies(),
                baseFee: shouldUseV3 ? defaultBaseFee : 0,
                supportsExpirationDate: true,
                shouldTransferNft: false,
                submit: sellAction,
            };
        });
    }
    update(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!prepareRequest.orderId) {
                throw new Error("OrderId has not been specified");
            }
            const [blockchain, hash] = prepareRequest.orderId.split(":");
            if (!(0, common_1.isEVMBlockchain)(blockchain)) {
                throw new Error("Not an ethereum order");
            }
            const order = yield this.apis.order.getValidatedOrderById({
                id: prepareRequest.orderId,
            });
            if (!(0, common_1.isRaribleV1Data)(order.data) && !(0, common_1.isRaribleV2Data)(order.data)) {
                throw new Error(`You can't update non-Rarible orders. Unable to update sell ${JSON.stringify(order)}`);
            }
            const sellUpdateAction = this.sdk.order.sellUpdate.around((request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield (0, common_1.checkWalletBlockchain)(this.wallet, blockchain);
                return {
                    orderHash: (0, types_1.toWord)(hash),
                    priceDecimal: request.price,
                };
            }), order => common.convertEthereumOrderHash(order.hash, blockchain));
            const { ethereum } = common.assertWallet(this.wallet);
            const ethOrder = yield (0, common_1.getEthOrder)(ethereum, order);
            return {
                originFeeSupport: (0, common_1.getOriginFeeSupport)(order.data),
                payoutsSupport: (0, common_1.getPayoutsSupport)(order.data),
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: common.getSupportedCurrencies(),
                baseFee: yield this.sdk.order.getBaseOrderFee(ethOrder.type),
                submit: sellUpdateAction,
                orderData: {
                    nftCollection: "contract" in order.make.type ? order.make.type.contract : undefined,
                },
            };
        });
    }
}
exports.EthereumSell = EthereumSell;
