"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowBalance = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const build_1 = require("@rarible/logger/build");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const retry_1 = require("../../common/retry");
const converters_1 = require("./common/converters");
const get_flow_currency_from_asset_type_1 = require("./common/get-flow-currency-from-asset-type");
const balance_simple_1 = require("./balance-simple");
class FlowBalance {
    constructor(sdk, env, network, wallet) {
        this.sdk = sdk;
        this.env = env;
        this.network = network;
        this.wallet = wallet;
        this.getBalance = this.getBalance.bind(this);
        this.transfer = this.transfer.bind(this);
    }
    getBalance(address, currency) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const assetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(currency);
            if (this.wallet) {
                const flowAddress = (0, converters_1.parseFlowAddressFromUnionAddress)(address);
                const flowAsset = (0, get_flow_currency_from_asset_type_1.getFlowCurrencyFromAssetType)(assetType);
                const balance = yield (0, retry_1.retry)(10, 1000, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return yield this.sdk.wallet.getFungibleBalance(flowAddress, flowAsset);
                }));
                return (0, utils_1.toBn)(balance);
            }
            return yield (0, retry_1.retry)(10, 1000, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return yield (0, balance_simple_1.getSimpleFlowFungibleBalance)(this.env, address, assetType);
            }));
        });
    }
    transfer(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.wallet) {
                throw new build_1.Warning("Wallet is undefined");
            }
            const assetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
            const flowAddress = (0, converters_1.parseFlowAddressFromUnionAddress)(request.recipient);
            const flowAsset = (0, get_flow_currency_from_asset_type_1.getFlowCurrencyFromAssetType)(assetType);
            const tx = yield this.sdk.wallet.transferFunds({
                recipient: flowAddress,
                currency: flowAsset,
                amount: request.amount,
            });
            return new sdk_transaction_1.BlockchainFlowTransaction(tx, this.network);
        });
    }
}
exports.FlowBalance = FlowBalance;
