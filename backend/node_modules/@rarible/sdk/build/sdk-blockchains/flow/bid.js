"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowBid = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const action_1 = require("@rarible/action");
const flow_sdk_1 = require("@rarible/flow-sdk");
const types_2 = require("@rarible/types");
const api_client_1 = require("@rarible/api-client");
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const converters_1 = require("./common/converters");
const get_flow_base_fee_1 = require("./common/get-flow-base-fee");
class FlowBid {
    constructor(sdk) {
        this.sdk = sdk;
        this.bid = this.bid.bind(this);
        this.update = this.update.bind(this);
        this.bidBasic = this.bidBasic.bind(this);
        this.bidUpdateBasic = this.bidUpdateBasic.bind(this);
    }
    getConvertableValue() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    getBidObjectData(prepare) {
        if ("collectionId" in prepare) {
            throw new Error("Bid collection is not supported");
        }
        if (!prepare.itemId) {
            throw new Error("ItemId has not been specified");
        }
        const [domain, contract, tokenId] = prepare.itemId.split(":");
        if (domain !== api_client_1.Blockchain.FLOW) {
            throw new Error(`Not an flow item: ${prepare.itemId}`);
        }
        const itemId = (0, flow_sdk_1.toFlowItemId)(`${contract}:${tokenId}`);
        return { contract, tokenId, itemId };
    }
    bid(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            console.log("FLOW BID", prepare);
            const bidObjectData = this.getBidObjectData(prepare);
            const bidAction = action_1.Action.create({
                id: "send-tx",
                run: (bidRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.bidCommon(bidRequest, bidObjectData);
                }),
            }).after(tx => (0, converters_1.convertFlowOrderId)(tx.orderId));
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: FlowBid.supportedCurrencies,
                multiple: false,
                maxAmount: (0, types_2.toBigNumber)("1"),
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
                getConvertableValue: this.getConvertableValue,
                supportsExpirationDate: false,
                shouldTransferFunds: false,
                submit: bidAction,
                nftData: {
                    nftCollection: (0, converters_1.convertFlowContractAddress)(bidObjectData.contract),
                },
            };
        });
    }
    bidCommon(bidRequest, bidObjectData) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const requestCurrency = (0, get_currency_asset_type_1.getCurrencyAssetType)(bidRequest.currency);
            if (requestCurrency["@type"] === "FLOW_FT") {
                const currency = (0, converters_1.getFungibleTokenName)(requestCurrency.contract);
                return this.sdk.order.bid((0, types_1.toFlowContractAddress)(bidObjectData.contract), currency, bidObjectData.itemId, (0, types_2.toBigNumber)(bidRequest.price.toString()), (0, converters_1.toFlowParts)(bidRequest.originFees));
            }
            throw new Error(`Unsupported currency type: ${requestCurrency["@type"]}`);
        });
    }
    update(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!prepareRequest.orderId) {
                throw new Error("OrderId has not been specified");
            }
            const [blockchain, orderId] = prepareRequest.orderId.split(":");
            if (blockchain !== api_client_1.Blockchain.FLOW) {
                throw new Error("Not an flow order");
            }
            const order = yield this.sdk.apis.order.getOrderByOrderId({ orderId });
            const bidUpdateAction = action_1.Action.create({
                id: "send-tx",
                run: (bidRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (order.make["@type"] === "fungible") {
                        const currency = (0, converters_1.getFungibleTokenName)((0, converters_1.convertFlowContractAddress)(order.make.contract));
                        return this.sdk.order.bidUpdate((0, types_1.toFlowContractAddress)(order.take.contract), currency, order, (0, types_2.toBigNumber)(bidRequest.price.toString()));
                    }
                    throw new Error(`Unsupported currency type: ${order.make["@type"]}`);
                }),
            }).after(tx => (0, converters_1.convertFlowOrderId)(tx.orderId));
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: FlowBid.supportedCurrencies,
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
                getConvertableValue: this.getConvertableValue,
                submit: bidUpdateAction,
                orderData: {
                    nftCollection: "contract" in order.take ? (0, converters_1.convertFlowContractAddress)(order.take.contract) : undefined,
                },
            };
        });
    }
    bidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const bidObjectData = this.getBidObjectData(request);
            const bidTx = yield this.bidCommon(request, bidObjectData);
            return (0, converters_1.convertFlowOrderId)(bidTx.orderId);
        });
    }
    bidUpdateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const updateResponse = yield this.update(request);
            return updateResponse.submit(request);
        });
    }
}
exports.FlowBid = FlowBid;
FlowBid.supportedCurrencies = [
    {
        blockchain: api_client_1.Blockchain.FLOW,
        type: "NATIVE",
    },
];
