"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowBurn = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const types_1 = require("@rarible/types");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const converters_1 = require("./common/converters");
class FlowBurn {
    constructor(sdk, network) {
        this.sdk = sdk;
        this.network = network;
        this.burn = this.burn.bind(this);
        this.burnBasic = this.burnBasic.bind(this);
    }
    burn(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!prepare.itemId) {
                throw new Error("ItemId has not been specified");
            }
            const { itemId, contract } = (0, converters_1.parseFlowItemIdFromUnionItemId)(prepare.itemId);
            return {
                multiple: false,
                maxAmount: (0, types_1.toBigNumber)("1"),
                nftData: {
                    nftCollection: (0, converters_1.convertFlowContractAddress)(contract),
                },
                submit: action_1.Action.create({
                    id: "burn",
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        // @todo itemId number must be string
                        const tx = yield this.sdk.nft.burn(contract, parseInt(itemId));
                        return new sdk_transaction_1.BlockchainFlowTransaction(tx, this.network);
                    }),
                }),
            };
        });
    }
    burnBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.burn(request);
            return response.submit(request);
        });
    }
}
exports.FlowBurn = FlowBurn;
