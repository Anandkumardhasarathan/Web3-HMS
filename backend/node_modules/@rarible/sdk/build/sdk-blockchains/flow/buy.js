"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowBuy = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const action_1 = require("@rarible/action");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const domain_1 = require("../../types/order/fill/domain");
const utils_1 = require("../../common/utils");
const converters = tslib_1.__importStar(require("./common/converters"));
const converters_1 = require("./common/converters");
const get_flow_base_fee_1 = require("./common/get-flow-base-fee");
class FlowBuy {
    constructor(sdk, apis, network) {
        this.sdk = sdk;
        this.apis = apis;
        this.network = network;
        this.buy = this.buy.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
    }
    getPreparedOrder(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("order" in request) {
                return request.order;
            }
            if ("orderId" in request) {
                // @todo replace this api call for call from flow-sdk when it supported
                return this.apis.order.getOrderById({ id: request.orderId });
            }
            throw new Error("Incorrect request");
        });
    }
    getFlowNftContract(order) {
        if (order.make.type["@type"] === "FLOW_NFT") {
            return order.make.type.contract;
        }
        else if (order.take.type["@type"] === "FLOW_NFT") {
            return order.take.type.contract;
        }
        else {
            throw new Error("This is not FLOW order");
        }
    }
    getFlowCurrency(order) {
        if (order.take.type["@type"] === "FLOW_FT") {
            return converters.getFungibleTokenName(order.take.type.contract);
        }
        else if (order.make.type["@type"] === "FLOW_FT") {
            return converters.getFungibleTokenName(order.make.type.contract);
        }
        else {
            throw new Error("No Flow fungible token found in order take and make values");
        }
    }
    fillCommon(request_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (request, isBid = false) {
            const order = yield this.getPreparedOrder(request);
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (buyRequest) => {
                    return this.buyCommon(Object.assign(Object.assign(Object.assign({}, buyRequest), request), { order }));
                },
            });
            return {
                multiple: false,
                maxAmount: (0, types_1.toBigNumber)("1"),
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
                supportsPartialFill: false,
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                submit,
                orderData: {
                    platform: order.platform,
                    nftCollection: (0, utils_1.getNftContractAddress)(isBid ? order.take.type : order.make.type),
                },
            };
        });
    }
    buy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fillCommon(request);
        });
    }
    acceptBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.fillCommon(request, true);
        });
    }
    buyCommon(buyRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currency = this.getFlowCurrency(buyRequest.order);
            const owner = converters.parseFlowAddressFromUnionAddress(buyRequest.order.maker);
            const collectionId = converters.getFlowCollection(this.getFlowNftContract(buyRequest.order));
            const orderId = converters.parseOrderId(buyRequest.order.id);
            const tx = yield this.sdk.order.fill(collectionId, currency, orderId, owner, (0, converters_1.toFlowParts)(buyRequest.originFees));
            return new sdk_transaction_1.BlockchainFlowTransaction(tx, this.network);
        });
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.getPreparedOrder(request);
            return this.buyCommon(Object.assign(Object.assign({}, request), { order }));
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.getPreparedOrder(request);
            return this.buyCommon(Object.assign(Object.assign({}, request), { order }));
        });
    }
}
exports.FlowBuy = FlowBuy;
