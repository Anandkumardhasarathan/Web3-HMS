"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowCancel = void 0;
const tslib_1 = require("tslib");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const converters_1 = require("./common/converters");
class FlowCancel {
    constructor(sdk, apis, network) {
        this.sdk = sdk;
        this.apis = apis;
        this.network = network;
        this.cancel = this.cancel.bind(this);
    }
    cancel(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!request.orderId) {
                throw new Error("OrderId has not been specified");
            }
            const parsed = (0, converters_1.parseOrderId)(request.orderId);
            const order = yield this.apis.order.getOrderById({
                id: request.orderId,
            });
            switch (order.make.type["@type"]) {
                case "FLOW_NFT": {
                    if (order.take.type["@type"] !== "FLOW_FT") {
                        throw new Error("Invalid Flow order, make asset is not a Flow asset");
                    }
                    const tx = yield this.sdk.order.cancelOrder((0, converters_1.getFlowCollection)(order.make.type.contract), parsed);
                    return new sdk_transaction_1.BlockchainFlowTransaction(tx, this.network);
                }
                case "FLOW_FT": {
                    if (order.take.type["@type"] !== "FLOW_NFT") {
                        throw new Error("Invalid Flow bid order, take asset is not a Flow asset");
                    }
                    const tx = yield this.sdk.order.cancelBid((0, converters_1.getFlowCollection)(order.take.type.contract), parsed);
                    return new sdk_transaction_1.BlockchainFlowTransaction(tx, this.network);
                }
                default:
                    throw new Error("Not an Flow order");
            }
        });
    }
}
exports.FlowCancel = FlowCancel;
