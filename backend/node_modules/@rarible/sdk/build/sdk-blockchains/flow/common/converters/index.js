"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertFlowUnionAddress = exports.convertFlowCollectionId = exports.convertFlowContractAddress = exports.convertFlowItemId = exports.convertFlowOrderId = exports.toFlowParts = exports.convertToFlowAddress = exports.getFungibleTokenName = exports.parseOrderId = exports.parseFlowAddressFromUnionAddress = exports.parseFlowItemIdFromUnionItemId = exports.getFlowCollection = void 0;
const flow_sdk_1 = require("@rarible/flow-sdk");
const api_client_1 = require("@rarible/api-client");
const types_1 = require("@rarible/types");
const FLOW_COLLECTION_REGEXP = /^FLOW:A\.0*x*[0-9a-f]{16}\.[A-Za-z_]{3,}/;
/**
 * Get flow collection from union collection
 * @param collection - e.g. "FLOW:A.0xabcdef0123456789.ContractName", contract address can be unprefixed
 */
function getFlowCollection(collection) {
    if (FLOW_COLLECTION_REGEXP.test(collection)) {
        const raw = collection.split(":")[1];
        return (0, flow_sdk_1.toFlowContractAddress)(raw);
    }
    throw new Error("Invalid collection");
}
exports.getFlowCollection = getFlowCollection;
const FLOW_ITEM_ID_REGEXP = /^FLOW:A\.0*x*[0-9a-f]{16}\.[A-Za-z0-9]{3,}:[0-9]{1,}/;
/**
 * Parse union item id
 * @param unionItemId - e.g. "FLOW:A.0xabcdef0123456789.ContractName:123", contract address can be unprefixed
 * @returns blockchain, collectionId, itemId
 */
function parseFlowItemIdFromUnionItemId(unionItemId) {
    if (FLOW_ITEM_ID_REGEXP.test(unionItemId)) {
        const [blockchain, collectionId, itemId] = unionItemId.split(":");
        if (!collectionId) {
            throw new Error("Invalid collection id, identifier is empty");
        }
        if (!itemId) {
            throw new Error("Invalid item id, identifier is empty");
        }
        if (blockchain === api_client_1.Blockchain.FLOW) {
            return {
                blockchain: api_client_1.Blockchain.FLOW,
                contract: (0, flow_sdk_1.toFlowContractAddress)(collectionId),
                itemId,
            };
        }
        throw new Error(`Invalid item id, "${blockchain}" is not FLOW item`);
    }
    throw new Error("Invalid item ID");
}
exports.parseFlowItemIdFromUnionItemId = parseFlowItemIdFromUnionItemId;
const FLOW_MAKER_ID_REGEXP = /^FLOW:0*x*[0-9a-f]{16}/;
/**
 * Get maker account address
 * @param maker - "FLOW:0xabcdef0123456789", address can be unprefixed
 */
function parseFlowAddressFromUnionAddress(maker) {
    if (FLOW_MAKER_ID_REGEXP.test(maker)) {
        const rawAddress = maker.split(":")[1];
        if (!rawAddress.startsWith("0x"))
            return (0, types_1.toFlowAddress)(`0x${rawAddress}`);
        return (0, types_1.toFlowAddress)(rawAddress);
    }
    throw new Error("Invalid maker");
}
exports.parseFlowAddressFromUnionAddress = parseFlowAddressFromUnionAddress;
const FLOW_ORDER_ID_REGEXP = /^FLOW:[0-9]{1,}/;
/**
 *
 * @param id - "FLOW:{any count of digits}"
 */
function parseOrderId(id) {
    if (FLOW_ORDER_ID_REGEXP.test(id)) {
        return id.split(":")[1];
    }
    throw new Error("Invalid order ID");
}
exports.parseOrderId = parseOrderId;
const FLOW_FT_CONTRACT_REGEXP = /^FLOW:A\.0*x*[0-9a-f]{16}\.[A-Za-z]{3,}/;
/**
 * Get fungible token name
 * @param contract - e.g. "FLOW:A.0xabcdef0123456789.ContractName", contract address can be unprefixed
 */
function getFungibleTokenName(contract) {
    if (FLOW_FT_CONTRACT_REGEXP.test(contract)) {
        const [, , name] = contract.split(".");
        switch (name) {
            case "FlowToken":
                return "FLOW";
            case "FUSD":
                return "FUSD";
            case "FiatToken":
                return "USDC";
            default:
                throw new Error(`Unsupported contract ID: ${contract}`);
        }
    }
    throw new Error(`Unsupported contract ID: ${contract}`);
}
exports.getFungibleTokenName = getFungibleTokenName;
function convertToFlowAddress(contractAddress) {
    if (!(0, types_1.isBlockchainSpecified)(contractAddress)) {
        throw new Error("Not a union or contract address: " + contractAddress);
    }
    const [blockchain, address] = contractAddress.split(":");
    if (blockchain !== api_client_1.Blockchain.FLOW) {
        throw new Error("Not an Flow address");
    }
    return (0, types_1.toFlowAddress)(address);
}
exports.convertToFlowAddress = convertToFlowAddress;
function toFlowParts(parts) {
    return ((parts === null || parts === void 0 ? void 0 : parts.map(p => {
        return {
            account: convertToFlowAddress(p.account),
            value: (0, types_1.toBigNumber)(p.value.toString()),
        };
    })) || []);
}
exports.toFlowParts = toFlowParts;
function convertFlowOrderId(orderId) {
    return (0, types_1.toOrderId)(`${api_client_1.Blockchain.FLOW}:${orderId}`);
}
exports.convertFlowOrderId = convertFlowOrderId;
function convertFlowItemId(itemId) {
    return (0, types_1.toItemId)(`${api_client_1.Blockchain.FLOW}:${itemId}`);
}
exports.convertFlowItemId = convertFlowItemId;
function convertFlowContractAddress(contractAddress) {
    return (0, types_1.toUnionContractAddress)(`${api_client_1.Blockchain.FLOW}:${contractAddress}`);
}
exports.convertFlowContractAddress = convertFlowContractAddress;
function convertFlowCollectionId(contractAddress) {
    return (0, types_1.toCollectionId)(`${api_client_1.Blockchain.FLOW}:${contractAddress}`);
}
exports.convertFlowCollectionId = convertFlowCollectionId;
function convertFlowUnionAddress(address) {
    return (0, types_1.toUnionAddress)(`${api_client_1.Blockchain.FLOW}:${address}`);
}
exports.convertFlowUnionAddress = convertFlowUnionAddress;
