"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowMint = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const prepare_1 = require("../../types/nft/mint/prepare");
const mint_1 = require("../ethereum/mint");
const converters_1 = require("./common/converters");
const prepare_flow_royalties_1 = require("./common/prepare-flow-royalties");
class FlowMint {
    constructor(sdk, apis, network) {
        this.sdk = sdk;
        this.apis = apis;
        this.network = network;
        this.prepare = this.prepare.bind(this);
        this.mintBasic = this.mintBasic.bind(this);
    }
    prepare(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const collection = yield (0, mint_1.getCollection)(this.apis.collection, prepareRequest);
            if (collection.type === "FLOW") {
                const flowCollection = (0, converters_1.getFlowCollection)(collection.id);
                return {
                    multiple: false,
                    supportsRoyalties: true,
                    supportsLazyMint: false,
                    submit: action_1.Action.create({
                        id: "mint",
                        run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            const mintResponse = yield this.sdk.nft.mint(flowCollection, request.uri, (0, prepare_flow_royalties_1.prepareFlowRoyalties)(request.royalties));
                            return {
                                type: prepare_1.MintType.ON_CHAIN,
                                itemId: (0, converters_1.convertFlowItemId)(mintResponse.tokenId),
                                transaction: new sdk_transaction_1.BlockchainFlowTransaction(mintResponse, this.network),
                            };
                        }),
                    }),
                };
            }
            throw new Error("Unsupported collection type");
        });
    }
    // eslint-disable-next-line no-dupe-class-members
    mintBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.prepare(request);
            return response.submit(request);
        });
    }
    preprocessMeta(meta) {
        var _a, _b;
        if (meta.blockchain !== api_client_1.Blockchain.FLOW) {
            throw new Error("Wrong blockchain");
        }
        return {
            name: meta.name,
            description: meta.description,
            image: (_a = meta.image) === null || _a === void 0 ? void 0 : _a.url,
            animation_url: (_b = meta.animation) === null || _b === void 0 ? void 0 : _b.url,
            external_url: meta.external,
            attributes: meta.attributes,
        };
    }
}
exports.FlowMint = FlowMint;
