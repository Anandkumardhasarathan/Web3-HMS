"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowSell = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const flow_sdk_1 = require("@rarible/flow-sdk");
const action_1 = require("@rarible/action");
const utils_1 = require("@rarible/utils");
const api_client_1 = require("@rarible/api-client");
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const utils_2 = require("../../common/utils");
const converters_1 = require("./common/converters");
const get_flow_base_fee_1 = require("./common/get-flow-base-fee");
class FlowSell {
    constructor(sdk, apis) {
        this.sdk = sdk;
        this.apis = apis;
        this.sell = this.sell.bind(this);
        this.update = this.update.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
        this.sellUpdateBasic = this.sellUpdateBasic.bind(this);
    }
    getPreparedOrder(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.apis.order.getOrderById({ id: request });
        });
    }
    getFutureOrderFees() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
            };
        });
    }
    sell() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sellAction = action_1.Action.create({
                id: "send-tx",
                run: (sellRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.sellCommon(sellRequest);
                }),
            }).after(tx => (0, converters_1.convertFlowOrderId)(tx.orderId));
            return {
                supportedCurrencies: FlowSell.supportedCurrencies,
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportsExpirationDate: false,
                shouldTransferNft: false,
                submit: sellAction,
            };
        });
    }
    sellCommon(sellRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const requestCurrency = (0, get_currency_asset_type_1.getCurrencyAssetType)(sellRequest.currency);
            if (requestCurrency["@type"] === "FLOW_FT") {
                const currency = (0, converters_1.getFungibleTokenName)(requestCurrency.contract);
                const { itemId, contract } = (0, converters_1.parseFlowItemIdFromUnionItemId)(sellRequest.itemId);
                return this.sdk.order.sell({
                    collection: contract,
                    currency,
                    itemId: (0, flow_sdk_1.toFlowItemId)(`${contract}:${itemId}`),
                    sellItemPrice: (0, utils_1.toBn)(sellRequest.price).decimalPlaces(8).toString(),
                    originFees: (0, converters_1.toFlowParts)(sellRequest.originFees),
                    end: sellRequest.expirationDate,
                });
            }
            throw new Error(`Unsupported currency type: ${requestCurrency["@type"]}`);
        });
    }
    update(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [blockchain, orderId] = request.orderId.split(":");
            if (blockchain !== api_client_1.Blockchain.FLOW) {
                throw new Error("Not an flow order");
            }
            const order = yield this.getPreparedOrder(request.orderId);
            const sellAction = action_1.Action.create({
                id: "send-tx",
                run: (sellRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (order.take.type["@type"] === "FLOW_FT") {
                        const currency = (0, converters_1.getFungibleTokenName)(order.take.type.contract);
                        if (order.make.type["@type"] === "FLOW_NFT") {
                            return yield this.sdk.order.updateOrder({
                                collection: (0, converters_1.getFlowCollection)(order.make.type.contract),
                                currency,
                                order: orderId,
                                sellItemPrice: (0, types_1.toBigNumber)((0, utils_1.toBn)(sellRequest.price).decimalPlaces(8).toString()),
                            });
                        }
                        throw new Error(`Unsupported make asset: ${order.make.type["@type"]}`);
                    }
                    throw new Error(`Unsupported take asset: ${order.take.type["@type"]}`);
                }),
            }).after(tx => (0, converters_1.convertFlowOrderId)(tx.orderId));
            return {
                supportedCurrencies: FlowSell.supportedCurrencies,
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                baseFee: (0, get_flow_base_fee_1.getFlowBaseFee)(this.sdk),
                submit: sellAction,
                orderData: {
                    nftCollection: (0, utils_2.getNftContractAddress)(order.make.type),
                },
            };
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sellResponse = yield this.sellCommon(request);
            return (0, converters_1.convertFlowOrderId)(sellResponse.orderId);
        });
    }
    sellUpdateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [blockchain, orderId] = request.orderId.split(":");
            if (blockchain !== api_client_1.Blockchain.FLOW) {
                throw new Error("Not an flow order");
            }
            const order = yield this.getPreparedOrder(request.orderId);
            if (order.take.type["@type"] === "FLOW_FT") {
                const currency = (0, converters_1.getFungibleTokenName)(order.take.type.contract);
                if (order.make.type["@type"] === "FLOW_NFT") {
                    const updateOrderTx = yield this.sdk.order.updateOrder({
                        collection: (0, converters_1.getFlowCollection)(order.make.type.contract),
                        currency,
                        order: orderId,
                        sellItemPrice: (0, types_1.toBigNumber)((0, utils_1.toBn)(request.price).decimalPlaces(8).toString()),
                    });
                    return (0, converters_1.convertFlowOrderId)(updateOrderTx.orderId);
                }
                throw new Error(`Unsupported make asset: ${order.make.type["@type"]}`);
            }
            throw new Error(`Unsupported take asset: ${order.take.type["@type"]}`);
        });
    }
}
exports.FlowSell = FlowSell;
FlowSell.supportedCurrencies = [
    {
        blockchain: api_client_1.Blockchain.FLOW,
        type: "NATIVE",
    },
];
