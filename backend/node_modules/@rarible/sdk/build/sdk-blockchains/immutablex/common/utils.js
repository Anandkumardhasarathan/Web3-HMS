"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcBuyerBaseFee = exports.getTakeAssetType = exports.unionPartsToParts = exports.convertToEthereumAddress = exports.getPreparedOrder = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const types_1 = require("@rarible/types");
const get_currency_asset_type_1 = require("../../../common/get-currency-asset-type");
function getPreparedOrder(request, apis) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ("order" in request) {
            return request.order;
        }
        if ("orderId" in request) {
            return apis.order.getOrderById({ id: request.orderId });
        }
        throw new Error("Incorrect request");
    });
}
exports.getPreparedOrder = getPreparedOrder;
function convertToEthereumAddress(contractAddress) {
    if (!(0, types_1.isRealBlockchainSpecified)(contractAddress)) {
        throw new Error("Not a union or contract address: " + contractAddress);
    }
    const [blockchain, address] = contractAddress.split(":");
    if (blockchain !== api_client_1.Blockchain.ETHEREUM && blockchain !== api_client_1.Blockchain.IMMUTABLEX) {
        throw new Error("Not an Ethereum/Immutablex address");
    }
    return (0, types_1.toEVMAddress)(address);
}
exports.convertToEthereumAddress = convertToEthereumAddress;
function unionPartsToParts(parts) {
    return ((parts === null || parts === void 0 ? void 0 : parts.map(part => ({
        account: convertToEthereumAddress(part.account),
        value: part.value,
    }))) || []);
}
exports.unionPartsToParts = unionPartsToParts;
function getTakeAssetType(currency) {
    const assetType = (0, get_currency_asset_type_1.getCurrencyAssetType)(currency);
    switch (assetType["@type"]) {
        case "ERC20":
            return {
                assetClass: assetType["@type"],
                contract: convertToEthereumAddress(assetType.contract),
            };
        case "ETH":
            return {
                assetClass: assetType["@type"],
            };
        default:
            throw new Error("Invalid take asset type");
    }
}
exports.getTakeAssetType = getTakeAssetType;
function calcBuyerBaseFee(order) {
    if (order.data["@type"] !== "IMMUTABLEX_RARIBLE_V1") {
        throw new Error(`Unsupported order type "${order.data["@type"]}", expected "IMMUTABLEX_RARIBLE_V1"`);
    }
    return (order.data.originFees || []).reduce((acc, val) => {
        return acc + val.value;
    }, 0);
}
exports.calcBuyerBaseFee = calcBuyerBaseFee;
