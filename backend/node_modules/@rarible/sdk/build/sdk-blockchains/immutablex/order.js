"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImxOrderService = void 0;
const tslib_1 = require("tslib");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const types_1 = require("@rarible/types");
const api_client_1 = require("@rarible/api-client");
const action_1 = require("@rarible/action");
const domain_1 = require("../../types/order/fill/domain");
const check_payouts_1 = require("../../common/check-payouts");
const utils_1 = require("../../common/utils");
const utils_2 = require("./common/utils");
const currencies_1 = require("./common/currencies");
class ImxOrderService {
    constructor(sdk, apis) {
        this.sdk = sdk;
        this.apis = apis;
        this.sell = this.sell.bind(this);
        this.buy = this.buy.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
        this.cancelBasic = this.cancelBasic.bind(this);
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.buy(request);
            return prepare.submit(request);
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.buy(request);
            return prepare.submit(request);
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepare = yield this.sell();
            return prepare.submit(request);
        });
    }
    sell() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    (0, check_payouts_1.checkPayouts)(request.payouts);
                    const [, contract, tokenId] = request.itemId.split(":");
                    const res = yield this.sdk.order.sell({
                        amount: (0, types_1.toBigNumber)(request.price.toString()),
                        originFees: (0, utils_2.unionPartsToParts)(request.originFees),
                        payouts: (0, utils_2.unionPartsToParts)(request.payouts),
                        makeAssetType: {
                            assetClass: "ERC721",
                            contract: (0, types_1.toEVMAddress)(contract),
                            tokenId: (0, types_1.toBigNumber)(tokenId),
                        },
                        takeAssetType: (0, utils_2.getTakeAssetType)(request.currency),
                    });
                    return (0, types_1.toOrderId)(`${api_client_1.Blockchain.IMMUTABLEX}:${res.orderId}`);
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, currencies_1.getCurrencies)(),
                baseFee: 200, // in reality is not taken from the seller, but it needs to display fees correctly
                supportsExpirationDate: false,
                shouldTransferNft: false,
                submit: submit,
            };
        });
    }
    getFutureOrderFees() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                baseFee: 200,
            };
        });
    }
    buy(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield (0, utils_2.getPreparedOrder)(prepare, this.apis);
            if (order.status !== api_client_1.OrderStatus.ACTIVE) {
                throw new Error("Order is not active");
            }
            const getERC721Asset = () => {
                if (order.make.type["@type"] !== "ERC721") {
                    throw new Error("Order make type should be ERC721");
                }
                const [, address] = order.make.type.contract.split(":");
                return {
                    assetClass: "ERC721",
                    contract: address,
                    tokenId: order.make.type.tokenId,
                };
            };
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    (0, check_payouts_1.checkPayouts)(request.payouts);
                    const [, orderId] = order.id.split(":");
                    const res = yield this.sdk.order.buy({
                        orderId: orderId,
                        fee: (0, utils_2.unionPartsToParts)(request.originFees),
                    }, getERC721Asset());
                    console.log(res);
                    return res;
                }),
            }).after(res => new sdk_transaction_1.BlockchainImmutableXTransaction(res.txId));
            return {
                multiple: false,
                maxAmount: order.makeStock,
                baseFee: (0, utils_2.calcBuyerBaseFee)(order),
                supportsPartialFill: false,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.NONE,
                submit,
                orderData: {
                    platform: order.platform,
                    nftCollection: (0, utils_1.getOrderNftContractAddress)(order),
                },
            };
        });
    }
    cancelBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [, orderId] = request.orderId.split(":");
            yield this.sdk.order.cancel({
                orderId: orderId,
            });
            return new sdk_transaction_1.BlockchainImmutableXTransaction(undefined);
        });
    }
}
exports.ImxOrderService = ImxOrderService;
