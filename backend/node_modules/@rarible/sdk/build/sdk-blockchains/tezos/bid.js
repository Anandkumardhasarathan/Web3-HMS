"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosBid = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
// eslint-disable-next-line camelcase
const bids_1 = require("@rarible/tezos-sdk/dist/bids");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const types_1 = require("@rarible/types");
// eslint-disable-next-line camelcase
const main_1 = require("@rarible/tezos-sdk/dist/main");
const tezos_common_1 = require("@rarible/tezos-common");
const build_1 = require("@rarible/logger/build");
const sdk_common_1 = require("@rarible/sdk-common");
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const get_expiration_date_1 = require("../../common/get-expiration-date");
const utils_1 = require("../../common/utils");
const common_1 = require("./common");
class TezosBid {
    constructor(provider, apis, network) {
        this.provider = provider;
        this.apis = apis;
        this.network = network;
        this.bid = this.bid.bind(this);
        this.bidBasic = this.bidBasic.bind(this);
        this.update = this.update.bind(this);
        this.updateBasic = this.updateBasic.bind(this);
    }
    parseTakeAssetType(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (type["@type"]) {
                case "XTZ":
                    return {
                        asset_class: type["@type"],
                    };
                case "TEZOS_FT": {
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    const contract = (0, common_1.convertFromContractAddress)(type.contract);
                    const ftType = yield (0, main_1.get_ft_type)(provider.config, contract);
                    return {
                        asset_class: "FT",
                        contract: contract,
                        token_id: ftType === tezos_common_1.AssetTypeV2.FA2 ? new bignumber_js_1.default(type.tokenId || 0) : undefined,
                    };
                }
                default: {
                    throw new Error("Unsupported take asset type");
                }
            }
        });
    }
    bid(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const requestInfo = yield this.getBidRequestInfo(prepare);
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    const commonBidData = Object.assign(Object.assign({}, (yield this.getCommonBidData(request))), { asset_contract: requestInfo.contract });
                    let orderId;
                    if ("itemId" in prepare) {
                        if (requestInfo.tokenId === undefined) {
                            throw new build_1.Warning("Check tokenId in your itemId parameter");
                        }
                        const bidRequest = Object.assign(Object.assign({}, commonBidData), { asset_token_id: new bignumber_js_1.default(requestInfo.tokenId) });
                        orderId = yield (0, bids_1.put_bid)(provider, bidRequest);
                    }
                    else if ("collectionId" in prepare) {
                        throw new build_1.Warning("Floor bids are not available yet");
                        // const bidRequest: FloorBid = commonBidData
                        // orderId = await put_floor_bid(provider, bidRequest)
                    }
                    else {
                        throw new build_1.Warning("ItemId or CollectionId must be assigned");
                    }
                    if (!orderId) {
                        throw new Error("OrderID cannot be requested");
                    }
                    return (0, types_1.toOrderId)(orderId);
                }),
            });
            return {
                multiple: requestInfo.collection.type === "TEZOS_MT",
                maxAmount: "item" in requestInfo && requestInfo.item ? (0, types_1.toBigNumber)(requestInfo.item.supply) : null,
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                baseFee: parseInt(this.provider.config.fees.toString()),
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                getConvertableValue: sdk_common_1.notImplemented,
                supportsExpirationDate: false,
                shouldTransferFunds: false,
                submit,
                nftData: {
                    nftCollection: (0, types_1.toUnionContractAddress)(requestInfo.collection.id),
                },
            };
        });
    }
    bidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.bid(request);
            return response.submit(request);
        });
    }
    getCommonBidData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const requestCurrency = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
            const asset = yield (0, common_1.getTezosAssetTypeV2)(provider.config, requestCurrency);
            const nftAmount = new bignumber_js_1.default(request.amount || 1);
            const assetTotalAmount = nftAmount.multipliedBy(request.price);
            // const assetTotalAmount = new BigNumber(request.price)
            return {
                bid_type: asset.type,
                bid_asset_contract: asset.asset_contract,
                bid_asset_token_id: asset.asset_token_id,
                bid: {
                    bid_origin_fees: (0, common_1.convertUnionParts)(request.originFees),
                    bid_payouts: yield (0, common_1.getPayouts)(provider, request.payouts),
                    bid_amount: assetTotalAmount,
                    bid_asset_qty: nftAmount,
                    bid_expiry_date: request.expirationDate
                        ? (0, get_expiration_date_1.convertDateToTimestamp)(request.expirationDate)
                        : (0, get_expiration_date_1.getDefaultExpirationDateTimestamp)(),
                    bid_data_type: undefined,
                    bid_data: undefined,
                },
            };
        });
    }
    updateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.update(request);
            return response.submit(request);
        });
    }
    update(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = yield this.apis.order.getOrderById({ id: request.orderId });
            if (!order) {
                throw new Error("Order has not been found");
            }
            const updateAction = action_1.Action.create({
                id: "send-tx",
                run: (updateRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    if (!(0, common_1.isNftOrMTAssetType)(order.take.type)) {
                        throw new build_1.Warning("Non-bid order specified");
                    }
                    if (order.data["@type"] !== "TEZOS_RARIBLE_V3") {
                        throw new Error("It's not TEZOS_RARIBLE_V3 order");
                    }
                    const asset = yield (0, common_1.getTezosAssetTypeV2)(provider.config, order.make.type);
                    const totalAssetAmount = new bignumber_js_1.default(order.take.value).multipliedBy(updateRequest.price);
                    const updateBidData = {
                        asset_contract: (0, common_1.convertFromContractAddress)(order.take.type.contract),
                        asset_token_id: new bignumber_js_1.default(order.take.type.tokenId),
                        bid_type: asset.type,
                        bid_asset_contract: asset.asset_contract,
                        bid_asset_token_id: asset.asset_token_id,
                        bid: {
                            bid_origin_fees: (0, common_1.convertUnionParts)(order.data.originFees),
                            bid_payouts: yield (0, common_1.getPayouts)(provider, order.data.payouts),
                            bid_amount: totalAssetAmount,
                            bid_asset_qty: new bignumber_js_1.default(order.take.value),
                            bid_expiry_date: order.endedAt !== undefined ? (0, get_expiration_date_1.convertDateToTimestamp)(new Date(order.endedAt)) : undefined,
                            bid_data_type: undefined,
                            bid_data: undefined,
                        },
                    };
                    const orderId = yield (0, bids_1.put_bid)(provider, updateBidData);
                    if (!orderId) {
                        throw new Error("OrderID cannot be requested");
                    }
                    return (0, types_1.toOrderId)(orderId);
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                baseFee: parseInt(this.provider.config.fees.toString()),
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                getConvertableValue: sdk_common_1.notImplemented,
                submit: updateAction,
                orderData: {
                    nftCollection: (0, utils_1.getNftContractAddress)(order.take.type),
                },
            };
        });
    }
    getBidRequestInfo(prepare) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("itemId" in prepare) {
                const { contract, tokenId } = (0, common_1.getTezosItemData)(prepare.itemId);
                const [collection, item] = yield Promise.all([
                    this.apis.collection.getCollectionById({
                        collection: (0, common_1.convertTezostoUnionContractAddress)(contract),
                    }),
                    this.apis.item.getItemById({ itemId: prepare.itemId }),
                ]);
                return { contract, tokenId, collection, item };
            }
            else if ("collectionId" in prepare) {
                const collection = yield this.apis.collection.getCollectionById({
                    collection: prepare.collectionId,
                });
                return { contract: (0, common_1.convertUnionAddress)(prepare.collectionId), collection };
            }
            else {
                throw new build_1.Warning("ItemId or CollectionId must be assigned");
            }
        });
    }
}
exports.TezosBid = TezosBid;
