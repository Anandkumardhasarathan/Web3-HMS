"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectionType = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const axios_1 = tslib_1.__importDefault(require("axios"));
const build_1 = require("@rarible/logger/build");
const apis_1 = require("../../../common/apis");
function getCollectionType(provider, collection) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let response;
        try {
            const { data } = yield axios_1.default.get(`${provider.config.tzkt}/v1/contracts/${collection}/storage/schema`);
            response = data;
        }
        catch (e) {
            console.error(e);
            (0, build_1.handleAxiosErrorResponse)(e, { code: apis_1.NetworkErrorCode.TEZOS_EXTERNAL_ERR });
            throw new Error("Getting tezos collection data error");
        }
        if (!response) {
            throw new build_1.Warning(`Collection ${collection} has not been found on that network`);
        }
        const mtTag = "ledger:big_map:object:nat";
        const nftTag = "ledger:big_map_flat:nat:address";
        const schema = response["schema:object"];
        if (!schema) {
            throw new Error(`Schema has not been found for collection ${collection}`);
        }
        if (mtTag in schema || (schema["assets:object"] && mtTag in schema["assets:object"])) {
            return api_client_1.CollectionType.TEZOS_MT;
        }
        else if (nftTag in schema || (schema["assets:object"] && nftTag in schema["assets:object"])) {
            return api_client_1.CollectionType.TEZOS_NFT;
        }
        else {
            throw new Error("Unrecognized tezos collection");
        }
    });
}
exports.getCollectionType = getCollectionType;
