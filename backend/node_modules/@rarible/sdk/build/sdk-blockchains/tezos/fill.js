"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosFill = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
// eslint-disable-next-line camelcase
const tezos_sdk_1 = require("@rarible/tezos-sdk");
const types_1 = require("@rarible/types");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const api_client_1 = require("@rarible/api-client");
const buy_1 = require("@rarible/tezos-sdk/dist/sales/buy");
// eslint-disable-next-line camelcase
const bids_1 = require("@rarible/tezos-sdk/dist/bids");
const build_1 = require("@rarible/logger/build");
const utils_1 = require("@rarible/utils");
const domain_1 = require("../../types/order/fill/domain");
const check_payouts_1 = require("../../common/check-payouts");
const utils_2 = require("../../common/utils");
const common_1 = require("./common");
class TezosFill {
    constructor(provider, unionAPI, network) {
        this.provider = provider;
        this.unionAPI = unionAPI;
        this.network = network;
        this.buy = this.buy.bind(this);
        this.batchBuy = this.batchBuy.bind(this);
        this.batchBuyBasic = this.batchBuyBasic.bind(this);
        this.buyBasic = this.buyBasic.bind(this);
        this.acceptBid = this.acceptBid.bind(this);
        this.acceptBidBasic = this.acceptBidBasic.bind(this);
        this.fillCommon = this.fillCommon.bind(this);
    }
    getPreparedOrder(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ("order" in request) {
                return request.order;
            }
            else if ("orderId" in request) {
                const [domain] = request.orderId.split(":");
                if (domain !== api_client_1.Blockchain.TEZOS) {
                    throw new Error("Not an tezos order");
                }
                return this.unionAPI.order.getOrderById({
                    id: request.orderId,
                });
            }
            else {
                throw new Error("Request error");
            }
        });
    }
    getMaxAmount(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            if (order.take.type["@type"] === "TEZOS_MT" || order.take.type["@type"] === "TEZOS_NFT") {
                const { contract, tokenId } = order.take.type;
                const ownershipId = `${contract}:${tokenId.toString()}:${yield (0, tezos_sdk_1.get_address)(provider)}`;
                const response = yield this.unionAPI.ownership.getOwnershipById({
                    ownershipId,
                });
                return (0, types_1.toBigNumber)(response.value);
            }
            else {
                return (0, types_1.toBigNumber)(order.makeStock);
            }
        });
    }
    isMultiple(order) {
        return order.take.type["@type"] === "TEZOS_MT" || order.make.type["@type"] === "TEZOS_MT";
    }
    buyV2(order, data, fillRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            (0, check_payouts_1.checkPayouts)(fillRequest.payouts);
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const amount = order.makePrice !== undefined ? new bignumber_js_1.default(order.makePrice) : new bignumber_js_1.default(0);
            const currency = yield (0, common_1.getTezosAssetTypeV2)(this.provider.config, order.take.type);
            if (!data.make_contract || !data.make_token_id) {
                throw new Error("Make data for buyV2 should exist");
            }
            const buyRequest = {
                asset_contract: data.make_contract,
                asset_token_id: new bignumber_js_1.default(data.make_token_id),
                asset_seller: (0, common_1.getTezosAddress)(order.maker),
                sale_type: currency.type,
                sale_asset_contract: currency.asset_contract,
                sale_asset_token_id: currency.asset_token_id,
                sale_amount: amount,
                sale_qty: new bignumber_js_1.default(fillRequest.amount),
                sale_payouts: (0, common_1.convertUnionParts)(fillRequest.payouts),
                sale_origin_fees: (0, common_1.convertUnionParts)(fillRequest.originFees),
                use_all: false,
            };
            const isOrderExists = yield (0, buy_1.isExistsSaleOrder)(provider, buyRequest);
            if (isOrderExists) {
                const op = yield (0, buy_1.buyV2)(provider, buyRequest);
                return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
            }
            else {
                throw new Error("Error order does not exist");
            }
        });
    }
    buy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let preparedOrder = yield this.getPreparedOrder(request);
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (fillRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.fillCommon(fillRequest, preparedOrder);
                }),
            });
            return {
                multiple: this.isMultiple(preparedOrder),
                maxAmount: yield this.getMaxAmount(preparedOrder),
                baseFee: parseInt(this.provider.config.fees.toString()),
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportsPartialFill: true,
                submit,
                orderData: {
                    platform: preparedOrder.platform,
                    nftCollection: (0, utils_2.getNftContractAddress)(preparedOrder.make.type),
                },
            };
        });
    }
    fillV1Order(fillRequest, order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const request = {
                amount: new bignumber_js_1.default(fillRequest.amount),
                payouts: (0, common_1.convertUnionParts)(fillRequest.payouts),
                origin_fees: (0, common_1.convertUnionParts)(fillRequest.originFees),
                infinite: fillRequest.infiniteApproval,
                use_all: true,
            };
            const preparedOrder = (0, common_1.getTezosOrderLegacyForm)(order);
            const fillResponse = yield (0, tezos_sdk_1.fill_order)(provider, preparedOrder, request);
            return new sdk_transaction_1.BlockchainTezosTransaction(fillResponse, this.network);
        });
    }
    buyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let preparedOrder = yield this.getPreparedOrder(request);
            return this.fillCommon(request, preparedOrder);
        });
    }
    acceptBidBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.acceptBid(request);
            return response.submit(request);
        });
    }
    acceptBid(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let preparedOrder = yield this.getPreparedOrder(request);
            const { make, take, data } = preparedOrder;
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (fillRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield (0, common_1.checkChainId)(this.provider);
                    (0, check_payouts_1.checkPayouts)(fillRequest.payouts);
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    if (!(0, common_1.isNftOrMTAssetType)(take.type)) {
                        throw new build_1.Warning("Non-bid order has been passed");
                    }
                    if (data["@type"] !== "TEZOS_RARIBLE_V3") {
                        throw new Error("It's not TEZOS_RARIBLE_V3 order");
                    }
                    if (!(0, utils_1.toBn)(fillRequest.amount).isEqualTo(take.value)) {
                        throw new build_1.Warning("Partial fill is unavailable for tezos orders");
                    }
                    const asset = yield (0, common_1.getTezosAssetTypeV2)(provider.config, make.type);
                    const acceptBidRequest = {
                        asset_contract: (0, common_1.convertFromContractAddress)(take.type.contract),
                        asset_token_id: new bignumber_js_1.default(take.type.tokenId),
                        bidder: (0, common_1.convertUnionAddress)(preparedOrder.maker),
                        bid_type: asset.type,
                        bid_asset_contract: asset.asset_contract,
                        bid_asset_token_id: asset.asset_token_id,
                        bid_origin_fees: (0, common_1.convertUnionParts)(data.originFees),
                        bid_payouts: yield (0, common_1.getPayouts)(provider, data.payouts),
                    };
                    const tx = yield (0, bids_1.accept_bid)(provider, acceptBidRequest);
                    return new sdk_transaction_1.BlockchainTezosTransaction(tx, this.network);
                }),
            });
            return {
                multiple: this.isMultiple(preparedOrder),
                maxAmount: yield this.getMaxAmount(preparedOrder),
                baseFee: parseInt(this.provider.config.fees.toString()),
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportsPartialFill: false,
                submit,
                orderData: {
                    platform: preparedOrder.platform,
                    nftCollection: (0, utils_2.getNftContractAddress)(preparedOrder.take.type),
                },
            };
        });
    }
    fillCommon(fillRequest, preparedOrder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            (0, check_payouts_1.checkPayouts)(fillRequest.payouts);
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const { make, take } = preparedOrder;
            if ((0, common_1.isNftOrMTAssetType)(make.type)) {
                const request = {
                    make_contract: (0, common_1.convertFromContractAddress)(make.type.contract),
                    make_token_id: new bignumber_js_1.default(make.type.tokenId),
                    maker: (0, common_1.getTezosAddress)(preparedOrder.maker),
                    take_contract: "contract" in take.type ? (0, common_1.convertFromContractAddress)(take.type.contract) : undefined,
                };
                if (take.type["@type"] === "TEZOS_FT" && take.type.tokenId) {
                    request.take_token_id = new bignumber_js_1.default(take.type.tokenId.toString());
                }
                if (preparedOrder.data["@type"] === "TEZOS_RARIBLE_V3") {
                    return this.buyV2(preparedOrder, request, fillRequest);
                }
                if (preparedOrder.data["@type"] === "TEZOS_HEN") {
                    const op = yield (0, tezos_sdk_1.hen_collect)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_HEN operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_VERSUM_V1") {
                    const op = yield (0, tezos_sdk_1.versum_collect)(provider, preparedOrder.id, new bignumber_js_1.default(fillRequest.amount));
                    if (!op) {
                        throw new Error("TEZOS_VERSUM_V1 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_TEIA_V1") {
                    const op = yield (0, tezos_sdk_1.teia_collect)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_TEIA_V1 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_OBJKT_V1") {
                    const op = yield (0, tezos_sdk_1.objkt_fulfill_ask_v1)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_OBJKT_V1 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_OBJKT_V2") {
                    const op = yield (0, tezos_sdk_1.objkt_fulfill_ask_v2)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_OBJKT_V2 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_FXHASH_V1") {
                    const op = yield (0, tezos_sdk_1.fxhash_v1_collect)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_FXHASH_V1 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
                if (preparedOrder.data["@type"] === "TEZOS_FXHASH_V2") {
                    const op = yield (0, tezos_sdk_1.fxhash_v2_listing_accept)(provider, preparedOrder.id);
                    if (!op) {
                        throw new Error("TEZOS_FXHASH_V2 operation result is empty");
                    }
                    return new sdk_transaction_1.BlockchainTezosTransaction(op, this.network);
                }
            }
            return this.fillV1Order(fillRequest, preparedOrder);
        });
    }
    batchBuyCommon(fillRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const orders = fillRequest.map(req => {
                (0, check_payouts_1.checkPayouts)(req.payouts);
                return {
                    order_id: (0, common_1.getTezosOrderId)(req.orderId),
                    amount: new bignumber_js_1.default(req.amount),
                    payouts: (0, common_1.convertUnionParts)(req.payouts),
                    origin_fees: (0, common_1.convertUnionParts)(req.originFees),
                };
            });
            const fillResponse = yield (0, tezos_sdk_1.cart_purchase)(provider, orders);
            return new sdk_transaction_1.BlockchainTezosTransaction(fillResponse, this.network);
        });
    }
    batchBuyBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.batchBuyCommon(request);
        });
    }
    batchBuy(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (fillRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.batchBuyCommon(fillRequest);
                }),
            });
            const prepared = yield Promise.all(prepareRequest.map((req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let preparedOrder = yield this.getPreparedOrder(req);
                return {
                    orderId: preparedOrder.id,
                    multiple: this.isMultiple(preparedOrder),
                    maxAmount: yield this.getMaxAmount(preparedOrder),
                    baseFee: parseInt(this.provider.config.fees.toString()),
                    originFeeSupport: domain_1.OriginFeeSupport.FULL,
                    payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                    maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                    supportsPartialFill: true,
                    orderData: {
                        platform: preparedOrder.platform,
                        nftCollection: (0, utils_2.getNftContractAddress)(preparedOrder.make.type),
                    },
                };
            })));
            return {
                submit,
                prepared,
            };
        });
    }
}
exports.TezosFill = TezosFill;
