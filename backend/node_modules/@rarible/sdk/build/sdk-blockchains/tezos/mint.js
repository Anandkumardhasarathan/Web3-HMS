"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCollectionData = exports.TezosMint = void 0;
const tslib_1 = require("tslib");
const action_1 = require("@rarible/action");
// eslint-disable-next-line camelcase
const tezos_sdk_1 = require("@rarible/tezos-sdk");
const utils_1 = require("@rarible/utils");
const sdk_transaction_1 = require("@rarible/sdk-transaction");
const api_client_1 = require("@rarible/api-client");
const prepare_1 = require("../../types/nft/mint/prepare");
const utils_2 = require("../../common/utils");
const common_1 = require("./common");
const get_collection_type_1 = require("./common/get-collection-type");
class TezosMint {
    constructor(provider, unionAPI, network) {
        this.provider = provider;
        this.unionAPI = unionAPI;
        this.network = network;
        this.mint = this.mint.bind(this);
        this.mintBasic = this.mintBasic.bind(this);
        this.preprocessMeta = this.preprocessMeta.bind(this);
    }
    getFormatsMeta(meta) {
        return [meta.image, meta.animation].reduce((acc, item) => {
            if (item) {
                const { url } = item, rest = tslib_1.__rest(item, ["url"]);
                return acc.concat(Object.assign(Object.assign({}, rest), { uri: fixIpfs(url) }));
            }
            return acc;
        }, []);
    }
    preprocessMeta(meta) {
        var _a;
        if (meta.blockchain !== api_client_1.Blockchain.TEZOS) {
            throw new Error("Wrong blockchain");
        }
        const artifact = meta.animation || meta.image;
        return {
            name: meta.name,
            decimals: 0,
            description: meta.description,
            artifactUri: artifact ? fixIpfs(artifact.url) : undefined,
            displayUri: meta.image ? fixIpfs(meta.image.url) : undefined,
            attributes: (_a = meta.attributes) === null || _a === void 0 ? void 0 : _a.map(attr => ({
                name: attr.key,
                value: attr.value,
                type: attr.type,
            })),
            formats: this.getFormatsMeta(meta),
        };
    }
    getOwner(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if ((_a = request.creators) === null || _a === void 0 ? void 0 : _a.length) {
                return (0, common_1.getTezosAddress)(request.creators[0].account);
            }
            return (0, tezos_sdk_1.get_address)((0, common_1.getRequiredProvider)(this.provider));
        });
    }
    mint(prepareRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            const { contract, type } = yield getCollectionData(this.unionAPI, prepareRequest);
            return {
                multiple: type === api_client_1.CollectionType.TEZOS_MT,
                supportsRoyalties: true,
                supportsLazyMint: false,
                submit: action_1.Action.create({
                    id: "mint",
                    run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        const royalties = (0, common_1.getRoyalties)(request.royalties);
                        const collectionType = yield (0, get_collection_type_1.getCollectionType)(this.provider, contract);
                        const isNftCollection = collectionType === api_client_1.CollectionType.TEZOS_NFT;
                        const provider = (0, common_1.getRequiredProvider)(this.provider);
                        const supply = isNftCollection ? undefined : (0, utils_1.toBn)(request.supply || 1);
                        if (isNftCollection && request.supply && request.supply > 1) {
                            throw new Error(`Invalid supply=${request.supply} for NFT collection, expected supply=1`);
                        }
                        const result = yield (0, tezos_sdk_1.mint)(provider, contract, royalties, supply, undefined, {
                            "": fixIpfs(request.uri),
                        }, yield this.getOwner(request));
                        return {
                            type: prepare_1.MintType.ON_CHAIN,
                            transaction: new sdk_transaction_1.BlockchainTezosTransaction(result, this.network),
                            itemId: (0, common_1.convertTezosItemId)(`${contract}:${result.token_id}`),
                        };
                    }),
                }),
            };
        });
    }
    // eslint-disable-next-line no-dupe-class-members
    mintBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.mint(request);
            return response.submit(request);
        });
    }
}
exports.TezosMint = TezosMint;
function getCollectionData(unionAPI, prepareRequest) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const contractAddress = (0, utils_2.getContractFromMintRequest)(prepareRequest);
        const [blockchain, contract] = contractAddress.split(":");
        if (blockchain !== api_client_1.Blockchain.TEZOS) {
            throw new Error(`Unsupported blockchain of collection: ${blockchain}`);
        }
        const collection = yield unionAPI.collection.getCollectionById({
            collection: contractAddress,
        });
        if (!collection) {
            throw new Error(`Tezos collection with address=${contract} has not been found`);
        }
        return {
            contract,
            owner: collection.owner,
            type: collection.type,
        };
    });
}
exports.getCollectionData = getCollectionData;
function fixIpfs(link) {
    return link.replace("ipfs://ipfs/", "ipfs://");
}
