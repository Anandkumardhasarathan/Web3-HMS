"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TezosSell = void 0;
const tslib_1 = require("tslib");
// eslint-disable-next-line camelcase
const tezos_sdk_1 = require("@rarible/tezos-sdk");
const action_1 = require("@rarible/action");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const sell_1 = require("@rarible/tezos-sdk/dist/sales/sell");
const build_1 = require("@rarible/logger/build");
const types_1 = require("@rarible/types");
const domain_1 = require("../../types/order/fill/domain");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const get_expiration_date_1 = require("../../common/get-expiration-date");
const check_payouts_1 = require("../../common/check-payouts");
const utils_1 = require("../../common/utils");
const common_1 = require("./common");
const get_collection_type_1 = require("./common/get-collection-type");
class TezosSell {
    constructor(provider, unionAPI) {
        this.provider = provider;
        this.unionAPI = unionAPI;
        this.sell = this.sell.bind(this);
        this.update = this.update.bind(this);
        this.sellUpdateBasic = this.sellUpdateBasic.bind(this);
        this.sellBasic = this.sellBasic.bind(this);
    }
    parseTakeAssetType(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (type["@type"]) {
                case "XTZ":
                    return {
                        asset_class: type["@type"],
                    };
                case "TEZOS_FT": {
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    const contract = (0, common_1.convertFromContractAddress)(type.contract);
                    const ftType = yield (0, tezos_sdk_1.get_ft_type)(provider.config, contract);
                    return {
                        asset_class: "FT",
                        contract: contract,
                        token_id: ftType === tezos_sdk_1.AssetTypeV2.FA2 ? new bignumber_js_1.default(type.tokenId || 0) : undefined,
                    };
                }
                default: {
                    throw new Error("Unsupported take asset type");
                }
            }
        });
    }
    getFutureOrderFees() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                baseFee: parseInt(this.provider.config.fees.toString()),
            };
        });
    }
    sell() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            const submit = action_1.Action.create({
                id: "send-tx",
                run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.sellV2(request);
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                baseFee: parseInt(this.provider.config.fees.toString()),
                supportsExpirationDate: false,
                shouldTransferNft: false,
                submit,
            };
        });
    }
    sellBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.sellV2(request);
        });
    }
    sellUpdateBasic(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const prepareResponse = yield this.update({ orderId: request.orderId });
            return prepareResponse.submit({ price: request.price });
        });
    }
    sellV2(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            (0, check_payouts_1.checkPayouts)(request.payouts);
            const provider = (0, common_1.getRequiredProvider)(this.provider);
            const { contract, tokenId } = (0, common_1.getTezosItemData)(request.itemId);
            const requestCurrency = (0, get_currency_asset_type_1.getCurrencyAssetType)(request.currency);
            const expirationDate = request.expirationDate
                ? (0, get_expiration_date_1.convertDateToTimestamp)(request.expirationDate)
                : (0, get_expiration_date_1.getDefaultExpirationDateTimestamp)();
            const collectionType = yield (0, get_collection_type_1.getCollectionType)(this.provider, contract);
            const asset = yield (0, common_1.getTezosAssetTypeV2)(provider.config, requestCurrency);
            const tezosRequest = {
                s_asset_contract: contract,
                s_asset_token_id: new bignumber_js_1.default(tokenId),
                s_sale_type: asset.type,
                s_sale_asset_contract: asset.asset_contract,
                s_sale_asset_token_id: asset.asset_token_id,
                s_sale: {
                    sale_amount: new bignumber_js_1.default(request.price),
                    sale_asset_qty: (0, common_1.getRequestAmount)(request.amount, collectionType) || new bignumber_js_1.default(1),
                    sale_max_fees_base_boint: 10000,
                    sale_end: expirationDate,
                    sale_start: undefined,
                    sale_origin_fees: (0, common_1.convertUnionParts)(request.originFees),
                    sale_payouts: (0, common_1.convertUnionParts)(request.payouts),
                    sale_data: undefined,
                    sale_data_type: undefined,
                },
            };
            const sellOrderId = yield (0, sell_1.sellV2)(provider, tezosRequest);
            if (!sellOrderId) {
                throw new Error("OrderID cannot be requested");
            }
            return (0, types_1.toOrderId)(sellOrderId);
        });
    }
    update(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, common_1.checkChainId)(this.provider);
            const order = yield this.unionAPI.order.getOrderById({ id: request.orderId });
            if (!order) {
                throw new Error("Order has not been found");
            }
            if (order.data["@type"] === "TEZOS_RARIBLE_V2") {
                throw new build_1.Warning("You can't change v1 version of order. Cancel order and create a new one");
            }
            const { make, take } = order;
            const makeAssetType = make.type;
            if (makeAssetType["@type"] !== "TEZOS_NFT" && makeAssetType["@type"] !== "TEZOS_MT") {
                throw new Error(`Order is not a sell (id=${request.orderId})`);
            }
            const updateAction = action_1.Action.create({
                id: "send-tx",
                run: (updateRequest) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const provider = (0, common_1.getRequiredProvider)(this.provider);
                    const request = {
                        make_contract: (0, common_1.convertFromContractAddress)(makeAssetType.contract),
                        make_token_id: new bignumber_js_1.default(makeAssetType.tokenId),
                        maker: (0, common_1.getTezosAddress)(order.maker),
                        take_contract: "contract" in take.type ? (0, common_1.convertFromContractAddress)(take.type.contract) : undefined,
                    };
                    if (take.type["@type"] === "TEZOS_FT" && take.type.tokenId) {
                        request.take_token_id = new bignumber_js_1.default(take.type.tokenId.toString());
                    }
                    const asset = yield (0, common_1.getTezosAssetTypeV2)(provider.config, take.type);
                    const expirationDate = order.endedAt !== undefined ? Math.floor(new Date(order.endedAt).getTime()) : undefined;
                    const tezosRequest = {
                        s_asset_contract: (0, common_1.convertFromContractAddress)(makeAssetType.contract),
                        s_asset_token_id: new bignumber_js_1.default(makeAssetType.tokenId),
                        s_sale_type: asset.type,
                        s_sale_asset_contract: request.take_contract,
                        s_sale_asset_token_id: asset.asset_token_id,
                        s_sale: {
                            sale_amount: new bignumber_js_1.default(updateRequest.price),
                            sale_asset_qty: new bignumber_js_1.default(make.value),
                            sale_max_fees_base_boint: 10000,
                            sale_end: expirationDate,
                            sale_start: undefined,
                            sale_origin_fees: order.data["@type"] === "TEZOS_RARIBLE_V2" ? (0, common_1.convertUnionParts)(order.data.originFees) : [],
                            sale_payouts: order.data["@type"] === "TEZOS_RARIBLE_V2" ? (0, common_1.convertUnionParts)(order.data.payouts) : [],
                            sale_data: undefined,
                            sale_data_type: undefined,
                        },
                    };
                    const sellOrderId = yield (0, sell_1.sellV2)(provider, tezosRequest);
                    return (0, types_1.toOrderId)(sellOrderId);
                }),
            });
            return {
                originFeeSupport: domain_1.OriginFeeSupport.FULL,
                payoutsSupport: domain_1.PayoutsSupport.MULTIPLE,
                maxFeesBasePointSupport: domain_1.MaxFeesBasePointSupport.IGNORED,
                supportedCurrencies: (0, common_1.getSupportedCurrencies)(),
                baseFee: parseInt(this.provider.config.fees.toString()),
                submit: updateAction,
                orderData: {
                    nftCollection: (0, utils_1.getNftContractAddress)(order.make.type),
                },
            };
        });
    }
}
exports.TezosSell = TezosSell;
