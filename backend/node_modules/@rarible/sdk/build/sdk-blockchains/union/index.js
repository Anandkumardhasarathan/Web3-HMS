"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUnionSdk = void 0;
const tslib_1 = require("tslib");
const api_client_1 = require("@rarible/api-client");
const action_1 = require("@rarible/action");
const sdk_common_1 = require("@rarible/sdk-common");
const sdk_common_2 = require("@rarible/sdk-common");
const index_1 = require("../../index");
const middleware_1 = require("../../common/middleware/middleware");
const get_currency_asset_type_1 = require("../../common/get-currency-asset-type");
const common_1 = require("../../types/common");
const utils_1 = require("../../common/utils");
function createUnionSdk(evm, flow, tezos, solana, eclipse, immutablex, aptos) {
    return {
        balances: new UnionBalanceSdk({
            EVM: evm.balances,
            FLOW: flow.balances,
            TEZOS: tezos.balances,
            SOLANA: solana.balances,
            IMMUTABLEX: immutablex.balances,
            ECLIPSE: eclipse.balances,
            APTOS: aptos.balances,
        }),
        nft: new UnionNftSdk({
            EVM: evm.nft,
            FLOW: flow.nft,
            TEZOS: tezos.nft,
            SOLANA: solana.nft,
            IMMUTABLEX: immutablex.nft,
            ECLIPSE: eclipse.nft,
            APTOS: aptos.nft,
        }),
        order: new UnionOrderSdk({
            EVM: evm.order,
            FLOW: flow.order,
            TEZOS: tezos.order,
            SOLANA: solana.order,
            IMMUTABLEX: immutablex.order,
            ECLIPSE: eclipse.order,
            APTOS: aptos.order,
        }),
        restriction: new UnionRestrictionSdk({
            EVM: evm.restriction,
            FLOW: flow.restriction,
            TEZOS: tezos.restriction,
            SOLANA: solana.restriction,
            IMMUTABLEX: immutablex.restriction,
            ECLIPSE: eclipse.restriction,
            APTOS: aptos.restriction,
        }),
        ethereum: new UnionEthereumSpecificSdk(evm.ethereum),
        flow: new UnionFlowSpecificSdk(flow.flow),
    };
}
exports.createUnionSdk = createUnionSdk;
class UnionOrderSdk {
    constructor(instances) {
        this.instances = instances;
        this.cancel = this.cancel.bind(this);
        this.bid = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getBidEntity)(request))].bid(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getBidEntity)(request))].bid.prepare(request));
        this.bidUpdate = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.orderId)].bidUpdate(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.orderId)].bidUpdate.prepare(request));
        this.fill = {
            prepare: (request) => {
                return instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getOrderId)(request))].fill.prepare(request);
            },
        };
        this.buy = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getOrderId)(request))].buy(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getOrderId)(request))].buy.prepare(request));
        this.batchBuy = new common_1.MethodWithPrepare(requests => {
            return instances[getBatchRequestBlockchain(requests)].batchBuy(requests);
        }, requests => {
            return instances[getBatchRequestBlockchain(requests)].batchBuy.prepare(requests);
        });
        this.acceptBid = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getOrderId)(request))].acceptBid(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, utils_1.getOrderId)(request))].acceptBid.prepare(request));
        this.sell = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.itemId)].sell(request), request => instances[(0, utils_1.convertSupportedBlockchainToUnion)(request.blockchain)].sell.prepare(request));
        // this.sellUpdate = this.sellUpdate.bind(this)
        this.sellUpdate = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.orderId)].sellUpdate(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.orderId)].sellUpdate.prepare(request));
    }
    cancel(request) {
        return this.instances[(0, utils_1.extractUnionSupportedBlockchain)(request.orderId)].cancel(request);
    }
}
class UnionNftSdk {
    constructor(instances) {
        this.instances = instances;
        this.preprocessMeta = middleware_1.Middlewarer.skipMiddleware(this.preprocessMeta.bind(this));
        this.generateTokenId = this.generateTokenId.bind(this);
        this.uploadMeta = this.uploadMeta.bind(this);
        this.createCollection = this.createCollection.bind(this);
        this.transfer = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.itemId)].transfer(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.itemId)].transfer.prepare(request));
        // @ts-ignore
        this.mint = new common_1.MethodWithPrepare(request => 
        // @ts-ignore
        instances[(0, utils_1.extractUnionSupportedBlockchain)((0, index_1.getCollectionId)(request))].mint(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)((0, index_1.getCollectionId)(request))].mint.prepare(request));
        this.burn = new common_1.MethodWithPrepare(request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.itemId)].burn(request), request => instances[(0, utils_1.extractUnionSupportedBlockchain)(request.itemId)].burn.prepare(request));
    }
    createCollection(request) {
        return this.instances[(0, utils_1.convertSupportedBlockchainToUnion)(request.blockchain)].createCollection(request);
    }
    uploadMeta(request) {
        return this.instances[(0, utils_1.extractUnionSupportedBlockchain)(request.accountAddress)].uploadMeta(request);
    }
    generateTokenId(prepare) {
        return this.instances[(0, utils_1.extractUnionSupportedBlockchain)(prepare.collection)].generateTokenId(prepare);
    }
    preprocessMeta(request) {
        return this.instances[(0, utils_1.convertSupportedBlockchainToUnion)(request.blockchain)].preprocessMeta(request);
    }
}
class UnionBalanceSdk {
    constructor(instances) {
        this.instances = instances;
        this.depositBiddingBalance = action_1.Action.create({
            id: "send-tx",
            run: request => this.instances[getUnionBlockchainFromBidding(request)].depositBiddingBalance(request),
        });
        this.withdrawBiddingBalance = action_1.Action.create({
            id: "send-tx",
            run: request => this.instances[getUnionBlockchainFromBidding(request)].withdrawBiddingBalance(request),
        });
        this.getBalance = this.getBalance.bind(this);
        this.convert = this.convert.bind(this);
        this.getBiddingBalance = this.getBiddingBalance.bind(this);
        this.transfer = this.transfer.bind(this);
    }
    getBalance(address, currency) {
        const blockchain = getBalanceBlockchain(address, currency);
        return this.instances[(0, utils_1.convertSupportedBlockchainToUnion)(blockchain)].getBalance(address, currency);
    }
    convert(request) {
        return this.instances[(0, utils_1.convertSupportedBlockchainToUnion)((0, sdk_common_1.validateBlockchain)(request.blockchain))].convert(request);
    }
    transfer(request) {
        const blockchain = getBalanceBlockchain(request.recipient, request.currency);
        return this.instances[(0, utils_1.convertSupportedBlockchainToUnion)(blockchain)].transfer(request);
    }
    getBiddingBalance(request) {
        const blockchain = getUnionBlockchainFromBidding(request);
        return this.instances[blockchain].getBiddingBalance(request);
    }
}
class UnionRestrictionSdk {
    constructor(instances) {
        this.instances = instances;
        this.blockchainFeeData = new Map();
    }
    canTransfer(itemId, from, to) {
        return this.instances[(0, utils_1.extractUnionSupportedBlockchain)(itemId)].canTransfer(itemId, from, to);
    }
    getFutureOrderFees(itemId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const blockchain = (0, utils_1.extractUnionSupportedBlockchain)(itemId);
            if (!this.blockchainFeeData.has(blockchain)) {
                const data = yield this.instances[blockchain].getFutureOrderFees(itemId);
                this.blockchainFeeData.set(blockchain, data);
                return data;
            }
            return this.blockchainFeeData.get(blockchain);
        });
    }
}
class UnionEthereumSpecificSdk {
    constructor(ethereumSdk) {
        this.ethereumSdk = ethereumSdk;
        this.wrapCryptoPunk = this.ethereumSdk.wrapCryptoPunk;
        this.unwrapCryptoPunk = this.ethereumSdk.unwrapCryptoPunk;
        this.getBatchBuyAmmInfo = this.ethereumSdk.getBatchBuyAmmInfo;
        this.getBuyTxData = this.ethereumSdk.getBuyTxData;
    }
}
class UnionFlowSpecificSdk {
    constructor(flowSdk) {
        this.flowSdk = flowSdk;
        this.setupAccount = this.flowSdk.setupAccount;
        this.setupMattelCollections = this.flowSdk.setupMattelCollections;
        this.setupGamisodesCollections = this.flowSdk.setupGamisodesCollections;
        this.checkInitMattelCollections = this.flowSdk.checkInitMattelCollections;
        this.checkInitGamisodesCollections = this.flowSdk.checkInitGamisodesCollections;
    }
}
function getBalanceBlockchain(address, currency) {
    if ((0, get_currency_asset_type_1.isAssetType)(currency)) {
        return (0, sdk_common_1.extractBlockchainFromAssetType)(currency) || (0, sdk_common_2.extractBlockchain)(address);
    }
    else if ((0, get_currency_asset_type_1.isRequestCurrencyAssetType)(currency)) {
        const blockchain = (0, sdk_common_2.extractBlockchain)(currency);
        return (0, sdk_common_1.validateBlockchain)(blockchain);
    }
    else {
        throw new Error(`Unrecognized RequestCurrency ${JSON.stringify(currency)}`);
    }
}
function getBiddingBlockchain(currencyOrOrder) {
    if ("currency" in currencyOrOrder) {
        if ((0, get_currency_asset_type_1.isRequestCurrencyAssetType)(currencyOrOrder.currency)) {
            return (0, sdk_common_2.extractBlockchain)(currencyOrOrder.currency);
        }
        else {
            if ((0, get_currency_asset_type_1.isAssetType)(currencyOrOrder.currency)) {
                if ("blockchain" in currencyOrOrder.currency && currencyOrOrder.currency.blockchain) {
                    return (0, sdk_common_1.validateBlockchain)(currencyOrOrder.currency.blockchain);
                }
                if ("contract" in currencyOrOrder.currency && currencyOrOrder.currency.contract) {
                    return (0, sdk_common_2.extractBlockchain)(currencyOrOrder.currency.contract);
                }
                if ("itemId" in currencyOrOrder.currency && currencyOrOrder.currency.itemId) {
                    return (0, sdk_common_2.extractBlockchain)(currencyOrOrder.currency.itemId);
                }
                switch (currencyOrOrder.currency["@type"]) {
                    case "SOLANA_SOL":
                        return api_client_1.Blockchain.SOLANA;
                    case "ETH":
                        return api_client_1.Blockchain.ETHEREUM;
                    case "XTZ":
                        return api_client_1.Blockchain.TEZOS;
                    default:
                }
            }
        }
        throw new Error(`Unrecognized RequestCurrency ${JSON.stringify(currencyOrOrder.currency)}`);
    }
    else if ("order" in currencyOrOrder) {
        return (0, sdk_common_2.extractBlockchain)(currencyOrOrder.order.id);
    }
    else if ("orderId" in currencyOrOrder) {
        return (0, sdk_common_2.extractBlockchain)(currencyOrOrder.orderId);
    }
    else {
        return currencyOrOrder.blockchain;
    }
}
function getUnionBlockchainFromBidding(currencyOrOrder) {
    return (0, utils_1.convertSupportedBlockchainToUnion)(getBiddingBlockchain(currencyOrOrder));
}
function getBatchRequestBlockchain(requests) {
    const blockchain = (0, sdk_common_2.extractBlockchain)((0, utils_1.getOrderId)(requests[0]));
    for (let req of requests) {
        if ((0, sdk_common_2.extractBlockchain)((0, utils_1.getOrderId)(req)) !== blockchain) {
            throw new Error("All orders should be in same blockchain");
        }
    }
    return (0, utils_1.convertSupportedBlockchainToUnion)(blockchain);
}
