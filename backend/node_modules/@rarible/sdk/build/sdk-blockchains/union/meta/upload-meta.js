"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaUploader = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const mime_types_1 = tslib_1.__importDefault(require("mime-types"));
const uuid_1 = require("uuid");
const api_client_1 = require("@rarible/api-client");
const types_1 = require("@rarible/types");
const build_1 = require("@rarible/logger/build");
const config_1 = require("../../../config");
const apis_1 = require("../../../common/apis");
const FILE = "file";
const FOLDER_PREFIX = "/folder/";
const IPFS_GATEWAY_URL = "https://ipfs.rarible.com/ipfs";
class MetaUploader {
    constructor(blockchain, preprocessMeta) {
        this.blockchain = blockchain;
        this.preprocessMeta = preprocessMeta;
        this.preprocessMeta = preprocessMeta;
        this.uploadMeta = this.uploadMeta.bind(this);
        this.uploadFile = this.uploadFile.bind(this);
        this.uploadFolder = this.uploadFolder.bind(this);
    }
    getRoyalties(royalty, account) {
        const value = parseFloat(royalty);
        return !isNaN(value) ? { account, value } : undefined;
    }
    uploadMeta(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { nftStorageApiKey, properties, royalty, accountAddress } = request;
            const { files } = yield this.uploadFolder(nftStorageApiKey, {
                image: properties.image,
                animation: properties.animationUrl,
            });
            const blockchain = accountAddress.split(":")[0];
            if (!(blockchain in api_client_1.Blockchain)) {
                throw new Error(`Value: "${blockchain}" is not a supported blockchain type`);
            }
            const metadataRequest = {
                blockchain: this.blockchain,
                name: properties.name,
                description: properties.description,
                image: files.image && mapToCommonTokenContent(files.image),
                animation: files.animation && mapToCommonTokenContent(files.animation),
                external: undefined,
                attributes: properties.attributes.map(prop => ({
                    key: prop.key,
                    trait_type: prop.key,
                    value: prop.value,
                })),
            };
            if (metadataRequest.blockchain === "SOLANA") {
                if (royalty) {
                    metadataRequest.royalties = this.getRoyalties(royalty, (0, types_1.toUnionAddress)(accountAddress));
                }
            }
            const metadata = this.preprocessMeta(metadataRequest);
            const file = createJson("properties.json", metadata);
            return this.uploadFile(nftStorageApiKey, file);
        });
    }
    uploadFile(nftStorageApiKey, file) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            const name = createFilename(file);
            formData.append("file", file, name);
            const { ipfsHash } = yield uploadDataToProvider(nftStorageApiKey, formData);
            return {
                originalFile: file,
                URL: resolveRealUrl(ipfsHash),
                IPFSURL: toNodeAgnosticURL(ipfsHash),
            };
        });
    }
    uploadFolder(nftStorageApiKey, upload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            const keys = Object.keys(upload).filter(x => Boolean(upload[x]));
            keys.forEach(key => {
                const file = upload[key];
                const name = `/folder/${key}.${mime_types_1.default.extension(file.type)}`;
                formData.append("file", file, name);
            });
            const { ipfsHash } = yield uploadDataToProvider(nftStorageApiKey, formData);
            const files = keys.reduce((prev, key) => {
                const file = upload[key];
                const name = `${key}.${mime_types_1.default.extension(file.type)}`;
                const suffix = `${ipfsHash}/${name}`;
                const ipfsUrl = toNodeAgnosticURL(suffix);
                return Object.assign(Object.assign({}, prev), { [key]: {
                        URL: resolveRealUrl(ipfsUrl),
                        IPFSURL: ipfsUrl,
                        originalFile: file,
                    } });
            }, {});
            return { files, hash: ipfsHash };
        });
    }
}
exports.MetaUploader = MetaUploader;
function toNodeAgnosticURL(suffix) {
    return `ipfs://ipfs/${suffix}`;
}
function uploadDataToProvider(nftStorageApiKey, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (nftStorageApiKey === undefined) {
            throw new Error("Provide NFT_STORAGE_API_KEY as environment variables!");
        }
        const req = transformNftStorageFormData(data);
        try {
            const nftStorageResponse = (yield axios_1.default.create().post(config_1.NFT_STORAGE_URL, req, {
                headers: { Authorization: `Bearer ${nftStorageApiKey}` },
            })).data;
            return {
                ipfsHash: nftStorageResponse.value.cid,
                size: nftStorageResponse.value.size,
            };
        }
        catch (e) {
            (0, build_1.handleAxiosErrorResponse)(e, { code: apis_1.NetworkErrorCode.META_EXTERNAL_ERR });
            throw e;
        }
    });
}
function transformNftStorageFormData(data) {
    const files = data
        .getAll(FILE)
        .filter(f => f instanceof File)
        .map(f => f);
    const isFolder = files.some(f => f.name.startsWith(FOLDER_PREFIX));
    if (files.length === 1 && !isFolder)
        return files[0];
    const transformFiles = files.map(f => new File([f], f.name.replace(FOLDER_PREFIX, ""), { type: f.type }));
    const transformFormData = new FormData();
    transformFiles.forEach(file => transformFormData.append(FILE, file, file.name));
    return transformFormData;
}
function resolveRealUrl(urlOrSuffix) {
    if (["http", "blob", "data"].some(x => urlOrSuffix.startsWith(x))) {
        return urlOrSuffix;
    }
    try {
        const suffix = extractIpfsSuffix(urlOrSuffix);
        return `${IPFS_GATEWAY_URL}/${suffix}`;
    }
    catch (_) {
        return `${IPFS_GATEWAY_URL}/${urlOrSuffix}`;
    }
}
function extractIpfsSuffix(str) {
    if (str.startsWith("ipfs://ipfs/")) {
        return str.substring("ipfs://ipfs/".length);
    }
    if (str.startsWith("ipfs:///ipfs/")) {
        return str.substring("ipfs:///ipfs/".length);
    }
    if (str.indexOf("/ipfs/") !== -1) {
        const offset = str.indexOf("/ipfs/");
        return str.substring(offset + "/ipfs/".length);
    }
    if (str.startsWith("ipfs://")) {
        return str.substring("ipfs://".length);
    }
    throw new Error("Cannot extract IPFS hash");
}
const createFilename = (file) => {
    const extension = mime_types_1.default.extension(file.type);
    if (!extension) {
        throw new Error("Can't determine file type");
    }
    const hash = (0, uuid_1.v4)();
    return `${hash}.${extension}`;
};
function mapToCommonTokenContent(file) {
    if (!file.originalFile.type) {
        throw new Error("Unknown file type or your browser can't detect correct file type. Make sure your file have valid extension");
    }
    return {
        url: file.IPFSURL,
        mimeType: file.originalFile.type,
        fileSize: file.originalFile.size,
        fileName: file.originalFile.name,
    };
}
function createFile(blobs, mime, name) {
    return new File(blobs, name, {
        type: mime,
    });
}
function createJson(name, data) {
    return createFile([JSON.stringify(data)], "application/json", name);
}
