"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChainIdByNetwork = exports.getBlockchainBySDKNetwork = exports.getBlockchainFromChainId = exports.getNetworkFromChainId = exports.ETHER_IN_WEI = void 0;
const utils_1 = require("@rarible/utils");
const config_1 = require("../config");
exports.ETHER_IN_WEI = (0, utils_1.toBn)(10).pow(18);
function getNetworkFromChainId(chainId) {
    const network = Object.keys(config_1.configDictionary).find(network => {
        const config = config_1.configDictionary[network];
        return config.chainId === chainId;
    });
    if (!network) {
        throw new Error(`Config for chainID=${chainId} has not been found`);
    }
    return network;
}
exports.getNetworkFromChainId = getNetworkFromChainId;
function getBlockchainFromChainId(chainId) {
    const network = getNetworkFromChainId(chainId);
    return getBlockchainBySDKNetwork(network);
}
exports.getBlockchainFromChainId = getBlockchainFromChainId;
function getBlockchainBySDKNetwork(network) {
    var _a;
    if (!((_a = config_1.configDictionary[network]) === null || _a === void 0 ? void 0 : _a.blockchain)) {
        throw new Error(`Unrecognized ethereum network ${network}`);
    }
    return config_1.configDictionary[network].blockchain;
}
exports.getBlockchainBySDKNetwork = getBlockchainBySDKNetwork;
function getChainIdByNetwork(network) {
    const config = (0, config_1.getEthereumConfig)(network);
    if (!config)
        throw new Error(`Config for network=${network} has not been found`);
    return config.chainId;
}
exports.getChainIdByNetwork = getChainIdByNetwork;
