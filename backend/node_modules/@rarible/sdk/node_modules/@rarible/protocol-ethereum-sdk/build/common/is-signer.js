"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSigner = void 0;
const tslib_1 = require("tslib");
const ethereumjs_util_1 = require("ethereumjs-util");
function isSigner(ethereum, signer, hash, signature) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const sig = Buffer.from(skip0x(signature), "hex");
        try {
            if (sig.length >= 64 && recover(hash, sig) === signer) {
                return true;
            }
        }
        catch (e) { }
        return isErc1271Signer(ethereum, signer, hash, signature);
    });
}
exports.isSigner = isSigner;
function isErc1271Signer(ethereum, signer, hash, signature) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hashHex = `0x${hash.toString("hex")}`;
        console.log("checking signer using erc-1271", hashHex);
        const erc1271 = ethereum.createContract(ABI, signer);
        try {
            const result = yield erc1271.functionCall("isValidSignature", hashHex, signature).call();
            if (result !== "0x1626ba7e") {
                console.warn(`isValidSignature result is ${result}`);
                return false;
            }
            return true;
        }
        catch (ex) {
            console.error("unable to check signature", ex);
            return false;
        }
    });
}
const ABI = [
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_hash",
                type: "bytes32",
            },
            {
                internalType: "bytes",
                name: "_signature",
                type: "bytes",
            },
        ],
        name: "isValidSignature",
        outputs: [
            {
                internalType: "bytes4",
                name: "",
                type: "bytes4",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
];
function recover(initialHash, signature) {
    const sig = fromRpcSig(signature);
    const [hash, v] = fixHashAndV(sig.v, initialHash);
    return (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)((0, ethereumjs_util_1.ecrecover)(hash, v, sig.r, sig.s)));
}
function fixHashAndV(v, hash) {
    if (v === 0 || v === 1) {
        return [hash, 27 + v];
    }
    else if (v === 27 || v === 28) {
        return [hash, v];
    }
    else if (v === 32 || v === 31) {
        return [getEthSignedMessageHash(hash), v - 4];
    }
    else {
        throw new Error(`Value of 'v' is not recognised: ${v}`);
    }
}
const START = "\u0019Ethereum Signed Message:\n";
function getEthSignedMessageHash(hash) {
    return (0, ethereumjs_util_1.keccak256)(Buffer.concat([Buffer.from(`${START}32`, "ascii"), hash]));
}
function fromRpcSig(buf) {
    let r;
    let s;
    let v;
    if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, ethereumjs_util_1.bufferToInt)(buf.slice(64));
    }
    else if (buf.length === 64) {
        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, ethereumjs_util_1.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 0x7f;
    }
    else {
        throw new Error("Invalid signature length");
    }
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v,
        r,
        s,
    };
}
function skip0x(hex) {
    if (hex.startsWith("0x")) {
        return hex.substring(2);
    }
    else {
        return hex;
    }
}
