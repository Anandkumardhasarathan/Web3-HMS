"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSimpleSendWithInjects = exports.getSendWithInjects = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const logger_1 = require("./logger/logger");
const estimate_gas_1 = require("./estimate-gas");
function getSendWithInjects(injects = {}) {
    const logger = injects.logger;
    return function send(functionCall, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const callInfo = yield functionCall.getCallInfo();
            yield (0, estimate_gas_1.estimateGas)(functionCall, { from: callInfo.from, value: options === null || options === void 0 ? void 0 : options.value }, logger);
            try {
                const tx = yield functionCall.send(options);
                try {
                    if ((logger === null || logger === void 0 ? void 0 : logger.level) && logger.level >= types_1.LogsLevel.TRACE) {
                        logger.instance.raw({
                            level: "TRACE",
                            method: callInfo.method,
                            message: JSON.stringify(getTxData(tx)),
                            args: JSON.stringify(callInfo.args),
                            provider: callInfo.provider,
                            to: callInfo.contract,
                            value: options === null || options === void 0 ? void 0 : options.value,
                        });
                    }
                }
                catch (e) {
                    console.error("Error while sending logs", e);
                }
                return tx;
            }
            catch (err) {
                try {
                    if ((logger === null || logger === void 0 ? void 0 : logger.level) && logger.level >= types_1.LogsLevel.ERROR) {
                        let data = undefined;
                        try {
                            data = yield functionCall.getData();
                        }
                        catch (e) {
                            console.error("Unable to get tx data for log", e);
                        }
                        logger.instance.raw({
                            level: "ERROR",
                            method: callInfo.method,
                            message: (0, logger_1.getErrorMessageString)(err),
                            from: callInfo.from,
                            provider: callInfo.provider,
                            args: JSON.stringify(callInfo.args),
                            to: callInfo.contract,
                            value: options === null || options === void 0 ? void 0 : options.value,
                            data,
                        });
                    }
                }
                catch (e) {
                    console.error("Error while sending logs", e, err);
                }
                throw err;
            }
        });
    };
}
exports.getSendWithInjects = getSendWithInjects;
function getSimpleSendWithInjects(injects = {}) {
    const logger = injects.logger;
    return function simpleSend(functionCall, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const callInfo = yield functionCall.getCallInfo();
            try {
                yield (0, estimate_gas_1.estimateGas)(functionCall, { from: callInfo.from, value: options === null || options === void 0 ? void 0 : options.value }, logger);
            }
            catch (err) { }
            try {
                const tx = yield functionCall.send(options);
                try {
                    if ((logger === null || logger === void 0 ? void 0 : logger.level) && logger.level >= types_1.LogsLevel.TRACE) {
                        logger.instance.raw({
                            level: "TRACE",
                            method: callInfo.method,
                            from: callInfo.from,
                            provider: callInfo.provider,
                            args: JSON.stringify(callInfo.args),
                            message: JSON.stringify(getTxData(tx)),
                            to: callInfo.contract,
                            value: options === null || options === void 0 ? void 0 : options.value,
                        });
                    }
                }
                catch (e) {
                    console.error("Error while sending logs", e);
                }
                return tx;
            }
            catch (err) {
                try {
                    if ((logger === null || logger === void 0 ? void 0 : logger.level) && logger.level >= types_1.LogsLevel.ERROR && callInfo) {
                        logger.instance.raw({
                            level: "ERROR",
                            method: callInfo.method,
                            from: callInfo.from,
                            provider: callInfo.provider,
                            args: JSON.stringify(callInfo.args),
                            error: (0, logger_1.getErrorMessageString)(err),
                            to: callInfo.contract,
                            value: options === null || options === void 0 ? void 0 : options.value,
                        });
                    }
                }
                catch (e) {
                    console.error("Error while sending logs", e, err);
                }
                throw err;
            }
        });
    };
}
exports.getSimpleSendWithInjects = getSimpleSendWithInjects;
function getTxData(tx) {
    return {
        hash: tx.hash,
        data: tx.data,
        from: tx.from,
        to: tx.to,
    };
}
