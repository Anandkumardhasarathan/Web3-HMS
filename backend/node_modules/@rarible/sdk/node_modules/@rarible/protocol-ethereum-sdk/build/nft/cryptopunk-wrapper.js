"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapPunk = exports.wrapPunk = exports.approveForWrapper = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const cryptopunk_wrapper_1 = require("./contracts/cryptoPunks/cryptopunk-wrapper");
const cryptoPunks_1 = require("./contracts/cryptoPunks");
function approveForWrapper(ethereum, send, getConfig, punkIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const config = yield getConfig();
        if (config.cryptoPunks.wrapperContract === types_1.EVM_ZERO_ADDRESS) {
            throw new Error("Wrapper contract address is not defined");
        }
        const marketContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, config.cryptoPunks.marketContract);
        const saleState = yield marketContract.functionCall("punksOfferedForSale", punkIndex).call();
        if (!saleState.isForSale ||
            ((_a = saleState.onlySellTo) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== config.cryptoPunks.wrapperContract.toLowerCase() ||
            saleState.minValue !== "0") {
            return send(marketContract.functionCall("offerPunkForSaleToAddress", punkIndex, 0, config.cryptoPunks.wrapperContract));
        }
        return null;
    });
}
exports.approveForWrapper = approveForWrapper;
function wrapPunk(ethereum, send, getConfig, punkIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const config = yield getConfig();
        const wrapperContract = (0, cryptopunk_wrapper_1.createCryptoPunksWrapperContract)(ethereum, config.cryptoPunks.wrapperContract);
        return send(wrapperContract.functionCall("wrap", punkIndex));
    });
}
exports.wrapPunk = wrapPunk;
function unwrapPunk(ethereum, send, getConfig, punkIndex) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const config = yield getConfig();
        const wrapperContract = (0, cryptopunk_wrapper_1.createCryptoPunksWrapperContract)(ethereum, config.cryptoPunks.wrapperContract);
        return send(wrapperContract.functionCall("unwrap", punkIndex));
    });
}
exports.unwrapPunk = unwrapPunk;
