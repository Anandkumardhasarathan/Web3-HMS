"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isErc1155v1Collection = exports.isErc1155v2Collection = exports.isErc721v1Collection = exports.isErc721v2Collection = exports.isErc721v3Collection = exports.mint = exports.MintResponseTypeEnum = void 0;
const tslib_1 = require("tslib");
const ethereum_api_client_1 = require("@rarible/ethereum-api-client");
const build_1 = require("@rarible/logger/build");
const mint_off_chain_1 = require("./mint-off-chain");
const mint_on_chain_1 = require("./mint-on-chain");
var MintResponseTypeEnum;
(function (MintResponseTypeEnum) {
    MintResponseTypeEnum["OFF_CHAIN"] = "off-chain";
    MintResponseTypeEnum["ON_CHAIN"] = "on-chain";
})(MintResponseTypeEnum || (exports.MintResponseTypeEnum = MintResponseTypeEnum = {}));
function mint(ethereum, send, signNft, getApis, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        if (data.uri === undefined) {
            throw new build_1.Warning("URI should be not undefined");
        }
        const apis = yield getApis();
        if (isERC1155Request(data)) {
            if (isERC1155v2Request(data)) {
                if (data.lazy)
                    return (0, mint_off_chain_1.mintOffChain)(ethereum, signNft, apis.nftCollection, apis.nftLazyMint, data);
                return (0, mint_on_chain_1.mintErc1155v2)(ethereum, send, apis.nftCollection, data);
            }
            return (0, mint_on_chain_1.mintErc1155v1)(ethereum, send, apis.nftCollection, data);
        }
        if (isERC721Request(data)) {
            if (isERC721v3Request(data)) {
                if (data.lazy)
                    return (0, mint_off_chain_1.mintOffChain)(ethereum, signNft, apis.nftCollection, apis.nftLazyMint, data);
                return (0, mint_on_chain_1.mintErc721v3)(ethereum, send, apis.nftCollection, data);
            }
            if (isERC721v2Request(data)) {
                return (0, mint_on_chain_1.mintErc721v2)(ethereum, send, apis.nftCollection, data);
            }
            return (0, mint_on_chain_1.mintErc721v1)(ethereum, send, apis.nftCollection, data);
        }
        throw new Error("Unsupported collection");
    });
}
exports.mint = mint;
const isERC721v2Request = (data) => (0, exports.isErc721v2Collection)(data.collection);
const isERC721v3Request = (data) => (0, exports.isErc721v3Collection)(data.collection);
const isERC1155v2Request = (data) => (0, exports.isErc1155v2Collection)(data.collection);
const isERC1155Request = (data) => data.collection.type === "ERC1155";
const isERC721Request = (data) => data.collection.type === "ERC721";
const isErc721v3Collection = (x) => x.features.indexOf(ethereum_api_client_1.NftCollectionFeatures.MINT_AND_TRANSFER) !== -1 && x.type === "ERC721";
exports.isErc721v3Collection = isErc721v3Collection;
const isErc721v2Collection = (x) => x.features.indexOf(ethereum_api_client_1.NftCollectionFeatures.SECONDARY_SALE_FEES) !== -1 && x.type === "ERC721";
exports.isErc721v2Collection = isErc721v2Collection;
const isErc721v1Collection = (x) => !(0, exports.isErc721v3Collection)(x) && !(0, exports.isErc721v2Collection)(x) && x.type === "ERC721";
exports.isErc721v1Collection = isErc721v1Collection;
const isErc1155v2Collection = (x) => x.features.indexOf(ethereum_api_client_1.NftCollectionFeatures.MINT_AND_TRANSFER) !== -1 && x.type === "ERC1155";
exports.isErc1155v2Collection = isErc1155v2Collection;
const isErc1155v1Collection = (x) => !(0, exports.isErc1155v2Collection)(x) && x.type === "ERC1155";
exports.isErc1155v1Collection = isErc1155v1Collection;
