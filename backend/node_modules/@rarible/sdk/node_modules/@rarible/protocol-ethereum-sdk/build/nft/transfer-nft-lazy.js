"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferNftLazy = void 0;
const tslib_1 = require("tslib");
const erc721_1 = require("./contracts/erc721");
const domain_1 = require("./contracts/domain");
const erc1155_1 = require("./contracts/erc1155");
function transferNftLazy(ethereum, send, nftItemApi, asset, from, to, amount) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const lazyNft = yield nftItemApi.getNftLazyItemById({
            itemId: `${asset.contract}:${asset.tokenId}`,
        });
        const params = {
            tokenId: lazyNft.tokenId,
            tokenURI: lazyNft.uri,
            creators: lazyNft.creators,
            royalties: lazyNft.royalties,
            signatures: lazyNft.signatures,
        };
        if (lazyNft["@type"] === "ERC1155") {
            ;
            params.supply = lazyNft.supply;
        }
        switch (lazyNft["@type"]) {
            case "ERC721": {
                const erc721Lazy = yield (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V3, lazyNft.contract);
                return send(erc721Lazy.functionCall("transferFromOrMint", params, from, to));
            }
            case "ERC1155": {
                const erc1155Lazy = yield (0, erc1155_1.getErc1155Contract)(ethereum, domain_1.ERC1155VersionEnum.ERC1155V2, lazyNft.contract);
                return send(erc1155Lazy.functionCall("transferFromOrMint", params, from, to, amount));
            }
            default:
                return Promise.reject(new Error("Unsupported nft standard"));
        }
    });
}
exports.transferNftLazy = transferNftLazy;
