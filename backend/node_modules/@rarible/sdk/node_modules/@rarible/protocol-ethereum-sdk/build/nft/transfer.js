"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transfer = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const get_ownership_id_1 = require("../common/get-ownership-id");
const transfer_erc721_1 = require("./transfer-erc721");
const transfer_erc1155_1 = require("./transfer-erc1155");
const transfer_nft_lazy_1 = require("./transfer-nft-lazy");
const transfer_crypto_punk_1 = require("./transfer-crypto-punk");
function transfer(ethereum, send, checkAssetType, getApis, initialAsset, to, amount) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const from = (0, types_1.toEVMAddress)(yield ethereum.getFrom());
        const apis = yield getApis();
        const ownership = yield apis.nftOwnership.getNftOwnershipByIdRaw({
            ownershipId: (0, get_ownership_id_1.getOwnershipId)(initialAsset.contract, (0, types_1.toBigNumber)(`${initialAsset.tokenId}`), from),
        });
        if (ownership.status === 200) {
            const asset = yield checkAssetType(initialAsset);
            if ((0, utils_1.toBn)(ownership.value.lazyValue).gt(0)) {
                if (asset.assetClass === "CRYPTO_PUNKS") {
                    throw new Error("CRYPTO_PUNKS can't be lazy");
                }
                if (asset.assetClass === "COLLECTION") {
                    throw new Error("Transfer asset class cannot be as collection");
                }
                return (0, transfer_nft_lazy_1.transferNftLazy)(ethereum, send, apis.nftItem, asset, (0, types_1.toEVMAddress)(from), to, amount);
            }
            switch (asset.assetClass) {
                case "ERC721":
                    return (0, transfer_erc721_1.transferErc721)(ethereum, send, asset.contract, from, to, asset.tokenId);
                case "ERC1155":
                    return (0, transfer_erc1155_1.transferErc1155)(ethereum, send, asset.contract, from, to, asset.tokenId, amount || "1");
                case "CRYPTO_PUNKS":
                    return (0, transfer_crypto_punk_1.transferCryptoPunk)(ethereum, send, asset.contract, to, asset.tokenId);
                default:
                    throw new Error(`Not supported asset: ${JSON.stringify(asset)}`);
            }
        }
        else {
            throw new Error(`Address ${from} has not any ownerships of token with Id ${initialAsset.tokenId}`);
        }
    });
}
exports.transfer = transfer;
