"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderBid = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const action_1 = require("@rarible/action");
const types_1 = require("@rarible/types");
class OrderBid {
    constructor(upserter, checkAssetType) {
        this.upserter = upserter;
        this.checkAssetType = checkAssetType;
        this.bid = action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (request.makeAssetType.assetClass !== "ERC20") {
                    throw new Error(`Make asset type should be ERC-20, received=${request.makeAssetType.assetClass}`);
                }
                const form = yield this.getBidForm(request);
                const checked = (yield this.upserter.checkLazyOrder(form));
                const approveTx = yield this.upserter.approve(checked, true);
                return { checked, approveTx };
            }),
        }).thenStep({
            id: "sign",
            run: (req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return {
                    approveTx: req.approveTx,
                    order: yield this.upserter.upsertRequest(req.checked),
                };
            }),
        });
        this.update = action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const order = yield this.upserter.getOrder(request);
                if (order.type === "CRYPTO_PUNK") {
                    return { form: request, approveTx: undefined };
                }
                if (order.make.assetType.assetClass !== "ERC20") {
                    throw new Error(`Make asset type should be ERC-20, received=${order.make.assetType.assetClass}`);
                }
                const price = yield this.upserter.getPrice(request, order.make.assetType);
                const form = yield this.prepareOrderUpdateForm(order, request, price);
                const checked = (yield this.upserter.checkLazyOrder(form));
                const approveTx = yield this.upserter.approve(checked, true);
                return { form: checked, approveTx };
            }),
        }).thenStep({
            id: "sign",
            run: (req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if ("type" in req.form && (req.form.type === "RARIBLE_V1" || req.form.type === "RARIBLE_V2")) {
                    return {
                        approveTx: req.approveTx,
                        order: yield this.upserter.upsertRequest(req.form),
                    };
                }
                return {
                    approveTx: req.approveTx,
                    order: yield this.upserter.updateCryptoPunkOrder(req.form),
                };
            }),
        });
    }
    getBidForm(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const form = yield this.upserter.prepareOrderForm(request, false);
            const price = yield this.upserter.getPrice(request, request.makeAssetType);
            return Object.assign(Object.assign({}, form), { make: {
                    assetType: request.makeAssetType,
                    value: (0, types_1.toBigNumber)((0, utils_1.toBn)(price).multipliedBy(request.amount).toString()),
                }, take: {
                    assetType: yield this.checkAssetType(request.takeAssetType),
                    value: (0, types_1.toBigNumber)(request.amount.toString()),
                } });
        });
    }
    prepareOrderUpdateForm(order, request, price) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (order.type === "RARIBLE_V1" || order.type === "RARIBLE_V2") {
                if (!request.end && !order.end) {
                    throw new Error("Order should contains 'end' field");
                }
                return Object.assign(Object.assign({}, order), { make: {
                        assetType: order.make.assetType,
                        value: (0, types_1.toBigNumber)((0, utils_1.toBn)(price).multipliedBy(order.take.value).toString()),
                    }, salt: (0, types_1.toBigNumber)((0, utils_1.toBn)(order.salt, 16).toString(10)), signature: order.signature || (0, types_1.toBinary)("0x"), end: (request.end || order.end) });
            }
            throw new Error(`Unsupported order type: ${order.type}`);
        });
    }
}
exports.OrderBid = OrderBid;
