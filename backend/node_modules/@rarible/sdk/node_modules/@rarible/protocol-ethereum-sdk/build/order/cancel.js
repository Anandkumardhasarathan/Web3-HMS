"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancelLooksRareV2Order = exports.cancelLooksRareOrder = exports.cancelSeaportOrder = exports.cancelCryptoPunkOrderByAsset = exports.cancelCryptoPunksOrder = exports.cancelX2Y2Order = exports.cancelOpenseaOrderV1 = exports.cancel = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const to_vrs_1 = require("../common/to-vrs");
const cryptoPunks_1 = require("../nft/contracts/cryptoPunks");
const get_required_wallet_1 = require("../common/get-required-wallet");
const exchange_v1_1 = require("./contracts/exchange-v1");
const exchange_v2_1 = require("./contracts/exchange-v2");
const exchange_opensea_v1_1 = require("./contracts/exchange-opensea-v1");
const rarible_v1_1 = require("./fill-order/rarible-v1");
const open_sea_1 = require("./fill-order/open-sea");
const sign_order_1 = require("./sign-order");
const open_sea_converter_1 = require("./fill-order/open-sea-converter");
const convert_to_seaport_order_1 = require("./fill-order/seaport-utils/convert-to-seaport-order");
const looksrare_exchange_1 = require("./contracts/looksrare-exchange");
const exchange_x2y2_v1_1 = require("./contracts/exchange-x2y2-v1");
const seaport_utils_1 = require("./fill-order/seaport-utils/seaport-utils");
const looksrare_v2_1 = require("./contracts/looksrare-v2");
function cancel(checkLazyOrder, ethereum, send, getConfig, getApis, orderToCheck) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = yield getConfig();
        const apis = yield getApis();
        if (ethereum) {
            const order = (yield checkLazyOrder(orderToCheck));
            switch (order.type) {
                case "RARIBLE_V1":
                    return cancelLegacyOrder(ethereum, send, config.exchange.v1, order);
                case "RARIBLE_V2":
                    return cancelV2Order(ethereum, send, config.exchange.v2, order);
                case "OPEN_SEA_V1":
                    return cancelOpenseaOrderV1(ethereum, send, order);
                case "SEAPORT_V1":
                    return cancelSeaportOrder(ethereum, send, apis, order);
                case "LOOKSRARE":
                    return cancelLooksRareOrder(ethereum, send, config.exchange, order);
                case "LOOKSRARE_V2":
                    return cancelLooksRareV2Order(ethereum, send, config.exchange, order);
                case "CRYPTO_PUNK":
                    return cancelCryptoPunksOrder(ethereum, send, order);
                case "X2Y2":
                    return cancelX2Y2Order(ethereum, send, apis, config.exchange.x2y2, order);
                default:
                    throw new Error(`Unsupported order: ${JSON.stringify(order)}`);
            }
        }
        throw new Error("Wallet undefined");
    });
}
exports.cancel = cancel;
function cancelLegacyOrder(ethereum, send, contract, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const v1 = (0, exchange_v1_1.createExchangeV1Contract)(ethereum, contract);
        return send(v1.functionCall("cancel", (0, rarible_v1_1.toStructLegacyOrderKey)(order)));
    });
}
function cancelV2Order(ethereum, send, contract, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const v2 = (0, exchange_v2_1.createExchangeV2Contract)(ethereum, contract);
        return send(v2.functionCall("cancel", (0, sign_order_1.orderToStruct)(ethereum, order)));
    });
}
function cancelOpenseaOrderV1(ethereum, send, order) {
    const exchangeContract = (0, exchange_opensea_v1_1.createOpenseaContract)(ethereum, order.data.exchange);
    const dto = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(ethereum, order);
    const makerVRS = (0, to_vrs_1.toVrs)(order.signature || "0x");
    return send(exchangeContract.functionCall("cancelOrder_", (0, open_sea_1.getAtomicMatchArgAddresses)(dto), (0, open_sea_1.getAtomicMatchArgUints)(dto), dto.feeMethod, dto.side, dto.saleKind, dto.howToCall, dto.calldata, dto.replacementPattern, dto.staticExtradata, makerVRS.v, makerVRS.r, makerVRS.s));
}
exports.cancelOpenseaOrderV1 = cancelOpenseaOrderV1;
function cancelX2Y2Order(ethereum, send, apis, contract, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        function decodeCancelInput(input) {
            return ethereum.decodeParameter({
                components: [
                    {
                        name: "itemHashes",
                        type: "bytes32[]",
                    },
                    {
                        name: "deadline",
                        type: "uint256",
                    },
                    {
                        name: "v",
                        type: "uint8",
                    },
                    {
                        name: "r",
                        type: "bytes32",
                    },
                    {
                        name: "s",
                        type: "bytes32",
                    },
                ],
                name: "data",
                type: "tuple",
            }, input)[0];
        }
        const OP_CANCEL_OFFER = (0, types_1.toBigNumber)("3");
        const exchangeContract = (0, exchange_x2y2_v1_1.createX2Y2Contract)(ethereum, contract);
        const signMessage = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
        const cancelInput = decodeCancelInput((yield apis.orderSignature.cancelSignX2Y2({
            x2Y2GetCancelInputRequest: {
                orderId: order.data.orderId,
                op: OP_CANCEL_OFFER,
                caller: yield ethereum.getFrom(),
                sign: yield ethereum.personalSign(signMessage),
                signMessage: signMessage,
            },
        })).input);
        return send(exchangeContract.functionCall("cancel", cancelInput.itemHashes, cancelInput.deadline, cancelInput.v, cancelInput.r, cancelInput.s));
    });
}
exports.cancelX2Y2Order = cancelX2Y2Order;
function cancelCryptoPunksOrder(ethereum, send, order) {
    if (order.make.assetType.assetClass === "CRYPTO_PUNKS") {
        return cancelCryptoPunkOrderByAsset(ethereum, send, "punkNoLongerForSale", order.make.assetType);
    }
    else if (order.take.assetType.assetClass === "CRYPTO_PUNKS") {
        return cancelCryptoPunkOrderByAsset(ethereum, send, "withdrawBidForPunk", order.take.assetType);
    }
    else {
        throw new Error("Crypto punks asset has not been found");
    }
}
exports.cancelCryptoPunksOrder = cancelCryptoPunksOrder;
function cancelCryptoPunkOrderByAsset(ethereum, send, methodName, assetType) {
    const ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, assetType.contract);
    return send(ethContract.functionCall(methodName, assetType.tokenId));
}
exports.cancelCryptoPunkOrderByAsset = cancelCryptoPunkOrderByAsset;
function cancelSeaportOrder(ethereum, send, apis, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!order.signature || order.signature === "0x") {
            const { signature } = yield apis.orderSignature.getSeaportOrderSignature({
                hash: order.hash,
            });
            order.signature = signature;
        }
        const orderParams = (0, convert_to_seaport_order_1.convertAPIOrderToSeaport)(order).parameters;
        const seaport = (0, seaport_utils_1.getSeaportContract)(ethereum, (0, types_1.toEVMAddress)(order.data.protocol));
        return send(seaport.functionCall("cancel", [orderParams]));
    });
}
exports.cancelSeaportOrder = cancelSeaportOrder;
function cancelLooksRareOrder(ethereum, send, config, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const provider = (0, get_required_wallet_1.getRequiredWallet)(ethereum);
        if (!config.looksrare) {
            throw new Error("Looksrare contract did not specified");
        }
        const contract = (0, looksrare_exchange_1.createLooksrareExchange)(provider, config.looksrare);
        return send(contract.functionCall("cancelMultipleMakerOrders", [order.data.nonce]));
    });
}
exports.cancelLooksRareOrder = cancelLooksRareOrder;
function cancelLooksRareV2Order(ethereum, send, config, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const provider = (0, get_required_wallet_1.getRequiredWallet)(ethereum);
        if (!config.looksrareV2) {
            throw new Error("Looksrare contract did not specified");
        }
        const contract = (0, looksrare_v2_1.createLooksrareV2Exchange)(provider, config.looksrareV2);
        return send(contract.functionCall("cancelOrderNonces", [order.data.orderNonce]));
    });
}
exports.cancelLooksRareV2Order = cancelLooksRareV2Order;
