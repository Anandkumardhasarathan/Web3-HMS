"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeroValueIsPassedError = exports.UnsupportedConvertAssetTypeError = exports.UnsupportedCurrencyConvertError = exports.ConvertWeth = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const get_required_wallet_1 = require("../common/get-required-wallet");
const compare_case_insensitive_1 = require("../common/compare-case-insensitive");
const weth_1 = require("./contracts/weth");
class ConvertWeth {
    constructor(ethereum, send, getConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getWethContractAddress = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            return config.weth;
        });
        this.deposit = this.deposit.bind(this);
        this.depositWei = this.depositWei.bind(this);
        this.withdraw = this.withdraw.bind(this);
        this.withdrawWei = this.withdrawWei.bind(this);
        this.convert = this.convert.bind(this);
    }
    /**
     * Deposits user funds to wrapped balance
     *
     * @param value amount of balance to be wrapped
     * @returns `EthereumTransaction`
     */
    deposit(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const decimals = yield this.getContractDecimals();
            const power = (0, utils_1.toBn)(10).pow(Number(decimals));
            const valueWei = (0, utils_1.toBn)(value).multipliedBy(power).toString();
            return this.depositWei(valueWei);
        });
    }
    /**
     * Deposits user funds to wrapped balance
     *
     * @param valueInWei amount of balance to be wrapped in WEI
     * @returns `EthereumTransaction`
     */
    depositWeiFunctionCall() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const contract = yield this.getContract();
            return contract.functionCall("deposit");
        });
    }
    depositWei(valueInWei) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const valueBn = (0, utils_1.toBn)(valueInWei);
            if (valueBn.isZero()) {
                throw new ZeroValueIsPassedError();
            }
            return this.send(yield this.depositWeiFunctionCall(), {
                value: valueBn.toString(),
            });
        });
    }
    /**
     * Withdraws user funds from wrapped balance to native currency balance
     *
     * @param value amount of balance to unwrapped
     * @returns `EthereumTransaction`
     */
    withdraw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const decimals = yield this.getContractDecimals();
            const valueWei = (0, utils_1.toBn)(value)
                .multipliedBy((0, utils_1.toBn)(10).pow(Number(decimals)))
                .toString();
            return this.withdrawWei(valueWei);
        });
    }
    /**
     * Withdraws user funds from wrapped balance to native currency balance
     *
     * @param valueInWei amount of balance to unwrapped in wei
     * @returns `EthereumTransaction`
     */
    withdrawWei(valueInWei) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const valueBn = (0, utils_1.toBn)(valueInWei);
            if (valueBn.isZero()) {
                throw new ZeroValueIsPassedError();
            }
            const contract = yield this.getContract();
            return this.send(contract.functionCall("withdraw", valueInWei));
        });
    }
    getContract() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            const provider = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            return (0, weth_1.createWethContract)(provider, config.weth);
        });
    }
    getContractDecimals() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const contract = yield this.getContract();
            return contract.functionCall("decimals").call();
        });
    }
    /**
     * @deprecated please use `deposit` or `withdraw` functions
     */
    convert(from, to, value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            if (from.assetClass === "ETH" && to.assetClass === "ERC20") {
                if (!(0, compare_case_insensitive_1.compareCaseInsensitive)(to.contract, config.weth)) {
                    throw new UnsupportedCurrencyConvertError(to.contract);
                }
                return this.deposit(value);
            }
            if (from.assetClass === "ERC20" && to.assetClass === "ETH") {
                if (!(0, compare_case_insensitive_1.compareCaseInsensitive)(from.contract, config.weth)) {
                    throw new UnsupportedCurrencyConvertError(from.contract);
                }
                return this.withdraw(value);
            }
            throw new UnsupportedConvertAssetTypeError();
        });
    }
}
exports.ConvertWeth = ConvertWeth;
class UnsupportedCurrencyConvertError extends Error {
    constructor(contract) {
        super(`Contract is not supported - ${contract}`);
        this.name = "UnsupportedCurrencyConvertError";
        Object.setPrototypeOf(this, UnsupportedCurrencyConvertError.prototype);
    }
}
exports.UnsupportedCurrencyConvertError = UnsupportedCurrencyConvertError;
class UnsupportedConvertAssetTypeError extends Error {
    constructor() {
        super("Unsupported convert asset types");
        this.name = "UnsupportedConvertAssetTypeError";
        Object.setPrototypeOf(this, UnsupportedConvertAssetTypeError.prototype);
    }
}
exports.UnsupportedConvertAssetTypeError = UnsupportedConvertAssetTypeError;
class ZeroValueIsPassedError extends Error {
    constructor() {
        super("Zero value is passed");
        this.name = "ZeroValueIsPassedError";
        Object.setPrototypeOf(this, ZeroValueIsPassedError.prototype);
    }
}
exports.ZeroValueIsPassedError = ZeroValueIsPassedError;
