"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmOrderHandler = void 0;
const tslib_1 = require("tslib");
const get_required_wallet_1 = require("../../common/get-required-wallet");
const exchange_wrapper_1 = require("../contracts/exchange-wrapper");
const types_1 = require("./types");
const sudoswap_fill_1 = require("./amm/sudoswap-fill");
const get_market_data_1 = require("./common/get-market-data");
class AmmOrderHandler {
    constructor(ethereum, send, getConfig, getBaseOrderFeeConfig, getApis, env, sdkConfig, options = { directBuy: false }) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.getApis = getApis;
        this.env = env;
        this.sdkConfig = sdkConfig;
        this.options = options;
    }
    getTransactionData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const fillData = yield this.getTransactionDataDirectBuy(request);
            const config = yield this.getConfig();
            if (this.options.directBuy) {
                // direct buy with sudoswap contract
                if ((_a = request.originFees) === null || _a === void 0 ? void 0 : _a.length) {
                    throw new Error("Origin fees not supported for sudoswap direct buy");
                }
                return {
                    functionCall: fillData.functionCall,
                    options: fillData.options,
                };
            }
            else {
                // buy with rarible wrapper
                const wrapperContract = (0, exchange_wrapper_1.createExchangeWrapperContract)(ethereum, config.exchange.wrapper);
                const apis = yield this.getApis();
                const { data, options, originFees: { feeAddresses }, } = yield (0, get_market_data_1.getMarketData)(this.ethereum, apis, {
                    marketId: types_1.ExchangeWrapperOrderType.AAM,
                    request,
                    fillData: {
                        data: yield fillData.functionCall.getData(),
                        options: fillData.options,
                    },
                });
                // const {data, options, originFees: {feeAddresses}} = await this.getMarketData(request, fillData)
                const functionCall = wrapperContract.functionCall("singlePurchase", data, feeAddresses[0], feeAddresses[1]);
                return {
                    functionCall: functionCall,
                    options,
                };
            }
        });
    }
    getTransactionDataDirectBuy(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            const config = yield this.getConfig();
            let fillData;
            switch (request.order.data.dataType) {
                case "SUDOSWAP_AMM_DATA_V1":
                    fillData = yield sudoswap_fill_1.SudoswapFill.getDirectFillData(ethereum, request, config);
                    break;
                default:
                    throw new Error("Unsupported order data type " + request.order.data.dataType);
            }
            return {
                functionCall: fillData.functionCall,
                options: fillData.options,
            };
        });
    }
    getTransactionDataForExchangeWrapper(request, feeValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (request.order.take.assetType.assetClass !== "ETH") {
                throw new Error("Unsupported asset type for take asset " + request.order.take.assetType.assetClass);
            }
            const apis = yield this.getApis();
            const fillData = yield this.getTransactionDataDirectBuy(request);
            // const {data, options} = await this.getMarketData(request, fillData, feeValue)
            const { data, options } = yield (0, get_market_data_1.getMarketData)(this.ethereum, apis, {
                marketId: types_1.ExchangeWrapperOrderType.AAM,
                request,
                fillData: {
                    data: yield fillData.functionCall.getData(),
                    options: fillData.options,
                },
                feeValue,
            });
            return {
                data,
                options,
            };
        });
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("AMM");
    }
    getOrderFee() {
        return 0;
    }
}
exports.AmmOrderHandler = AmmOrderHandler;
