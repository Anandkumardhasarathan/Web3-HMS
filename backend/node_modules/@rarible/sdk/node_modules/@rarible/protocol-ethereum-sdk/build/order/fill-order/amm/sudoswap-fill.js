"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SudoswapFill = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const build_1 = require("@rarible/logger/build");
const utils_1 = require("@rarible/utils");
const utils_2 = require("@rarible/utils");
const sudoswap_router_v1_1 = require("../../contracts/sudoswap-router-v1");
const sudoswap_pair_1 = require("../../contracts/sudoswap-pair");
class SudoswapFill {
    static getDirectFillData(ethereum, request, config) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const order = this.getOrder(request);
            let fillData;
            switch (order.make.assetType.assetClass) {
                case "ERC721":
                    if (request.assetType) {
                        throw new build_1.Warning("Remove assetType from request, because it must be captured from order");
                    }
                    fillData = yield this.buySpecificNFTs(ethereum, request, config, [order.make.assetType.tokenId]);
                    break;
                case "AMM_NFT":
                    if (request.assetType) {
                        const tokenIds = Array.isArray(request.assetType)
                            ? request.assetType.map(type => (0, types_1.toBigNumber)(type.tokenId.toString()))
                            : [(0, types_1.toBigNumber)(request.assetType.tokenId.toString())];
                        fillData = yield this.buySpecificNFTs(ethereum, request, config, tokenIds);
                    }
                    else {
                        fillData = yield this.buyAnyNFTs(ethereum, request, config, request.amount);
                    }
                    break;
                default:
                    throw new Error("Unsupported asset type " + order.take.assetType.assetClass);
            }
            return {
                functionCall: fillData.functionCall,
                options: fillData.options,
            };
        });
    }
    static getDeadline(duration = 4 * 60 * 60 /* 4 hours */) {
        const deadlineTimestamp = ~~(Date.now() / 1000) + duration;
        return (0, types_1.toBigNumber)("0x" + deadlineTimestamp.toString(16).padStart(64, "0"));
    }
    static getRouterContract(ethereum, config) {
        const { pairRouter } = config.sudoswap;
        if (!pairRouter || pairRouter === types_1.EVM_ZERO_ADDRESS) {
            throw new Error("Sudoswap router contract address has not been set. Change address in config");
        }
        return (0, sudoswap_router_v1_1.createSudoswapRouterV1Contract)(ethereum, pairRouter);
    }
    static getOrder(request) {
        const order = request.order;
        if (order.data.dataType !== "SUDOSWAP_AMM_DATA_V1") {
            throw new Error("Wrong order data type " + order.data.dataType);
        }
        if (order.take.assetType.assetClass !== "ETH") {
            throw new Error("Sudoswap supports swaps only for ETH");
        }
        return order;
    }
    static getNftRecipient(ethereum) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield ethereum.getFrom();
        });
    }
    static getETHRecipient(ethereum) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield ethereum.getFrom();
        });
    }
    static buySpecificNFTs(ethereum, request, config, tokenIds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const routerContract = this.getRouterContract(ethereum, config);
            const order = this.getOrder(request);
            const poolContract = (0, sudoswap_pair_1.createSudoswapPairContract)(ethereum, order.data.poolAddress);
            const price = yield poolContract.functionCall("getBuyNFTQuote", tokenIds.length).call();
            return {
                functionCall: routerContract.functionCall("swapETHForSpecificNFTs", [
                    {
                        pair: order.data.poolAddress,
                        nftIds: tokenIds,
                    },
                ], yield this.getETHRecipient(ethereum), yield this.getNftRecipient(ethereum), SudoswapFill.getDeadline()),
                options: {
                    value: price.inputAmount.toString(),
                },
            };
        });
    }
    static buyAnyNFTs(ethereum, request, config, amount) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const routerContract = this.getRouterContract(ethereum, config);
            const order = this.getOrder(request);
            const poolContract = (0, sudoswap_pair_1.createSudoswapPairContract)(ethereum, order.data.poolAddress);
            const price = yield poolContract.functionCall("getBuyNFTQuote", amount).call();
            return {
                functionCall: routerContract.functionCall("swapETHForAnyNFTs", [
                    {
                        pair: order.data.poolAddress,
                        numItems: amount,
                    },
                ], yield this.getETHRecipient(ethereum), yield this.getNftRecipient(ethereum), SudoswapFill.getDeadline()),
                options: {
                    value: price.inputAmount.toString(),
                },
            };
        });
    }
    static getRoyaltiesAmount(royalty, value) {
        const royaltiesBasisPoints = royalty.reduce((acc, item) => {
            return (acc += item.value);
        }, 0);
        return (0, utils_1.toBn)(royaltiesBasisPoints).dividedBy(10000).multipliedBy(value).integerValue(utils_2.BigNumber.ROUND_FLOOR);
    }
}
exports.SudoswapFill = SudoswapFill;
