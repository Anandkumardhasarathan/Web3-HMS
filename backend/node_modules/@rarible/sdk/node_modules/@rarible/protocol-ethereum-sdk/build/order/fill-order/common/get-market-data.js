"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAmmItemsRoyalties = exports.encodeDataWithRoyalties = exports.addFeeDependsOnExternalFee = exports.getRoyaltiesAmount = exports.getMarketData = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const utils_2 = require("@rarible/utils");
const get_required_wallet_1 = require("../../../common/get-required-wallet");
const exchange_wrapper_1 = require("../../contracts/exchange-wrapper");
const origin_fees_utils_1 = require("./origin-fees-utils");
function getMarketData(ethereum_1, apis_1, _a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, apis, { request, fillData, marketId, feeValue }) {
        var _b, _c, _d, _e, _f;
        const provider = (0, get_required_wallet_1.getRequiredWallet)(ethereum);
        const { totalFeeBasisPoints, encodedFeesValue, feeAddresses } = (0, origin_fees_utils_1.originFeeValueConvert)(request.originFees);
        let valueWithOriginFees = (0, origin_fees_utils_1.calcValueWithFees)((0, types_1.toBigNumber)((_c = (_b = fillData.options.value) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : "0"), totalFeeBasisPoints);
        const data = {
            // marketId: ExchangeWrapperOrderType.AAM,
            marketId,
            amount: (_d = fillData.options.value) !== null && _d !== void 0 ? _d : "0",
            fees: feeValue !== null && feeValue !== void 0 ? feeValue : encodedFeesValue,
            data: fillData.data,
        };
        if (request.addRoyalty && request.assetType) {
            let royalties = yield getAmmItemsRoyalties(apis, request);
            if (royalties === null || royalties === void 0 ? void 0 : royalties.length) {
                data.data = encodeDataWithRoyalties({
                    royalties,
                    data: fillData.data,
                    provider,
                });
                const royaltiesAmount = getRoyaltiesAmount(royalties, (_f = (_e = fillData.options.value) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : 0);
                valueWithOriginFees = (0, utils_1.toBn)(valueWithOriginFees.plus(royaltiesAmount).toString());
                data.fees = addFeeDependsOnExternalFee(request.originFees, feeValue);
            }
        }
        console.log("getMarket data", data, valueWithOriginFees.toString());
        return {
            originFees: {
                totalFeeBasisPoints,
                encodedFeesValue,
                feeAddresses,
            },
            data,
            options: Object.assign(Object.assign({}, fillData.options), { value: valueWithOriginFees.toString() }),
        };
    });
}
exports.getMarketData = getMarketData;
function getRoyaltiesAmount(royalty, value) {
    const royaltiesBasisPoints = royalty.reduce((acc, item) => {
        return (acc += item.value);
    }, 0);
    return (0, utils_1.toBn)(royaltiesBasisPoints).dividedBy(10000).multipliedBy(value).integerValue(utils_2.BigNumber.ROUND_FLOOR);
}
exports.getRoyaltiesAmount = getRoyaltiesAmount;
function addFeeDependsOnExternalFee(originFees, externalFee) {
    var _a, _b;
    if (externalFee) {
        //get first and second value with length=4 of each one
        return (0, types_1.toBigNumber)("0x1" + externalFee.toString().slice(-8).padStart(8, "0"));
    }
    else {
        const firstFee = (0, origin_fees_utils_1.getPackedFeeValue)((_a = originFees === null || originFees === void 0 ? void 0 : originFees[0]) === null || _a === void 0 ? void 0 : _a.value);
        const secondFee = (0, origin_fees_utils_1.getPackedFeeValue)((_b = originFees === null || originFees === void 0 ? void 0 : originFees[1]) === null || _b === void 0 ? void 0 : _b.value);
        if (firstFee.length > 4 || secondFee.length > 4) {
            throw new Error(`Decrease origin fees values: fee_1 = ${firstFee}, fee_2=${secondFee}`);
        }
        return (0, types_1.toBigNumber)("0x1" + firstFee + secondFee);
    }
}
exports.addFeeDependsOnExternalFee = addFeeDependsOnExternalFee;
function encodeDataWithRoyalties({ royalties, data, provider, }) {
    const dataForEncoding = {
        data,
        additionalRoyalties: royalties.map(royalty => (0, origin_fees_utils_1.encodeBasisPointsPlusAccount)(royalty.value, royalty.account)),
    };
    console.log("dataForEncoding", JSON.stringify(dataForEncoding, null, "  "));
    return provider.encodeParameter(exchange_wrapper_1.ADDITIONAL_DATA_STRUCT, dataForEncoding);
}
exports.encodeDataWithRoyalties = encodeDataWithRoyalties;
function getAmmItemsRoyalties(apis, request) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!request.assetType) {
            return [];
        }
        if (Array.isArray(request.assetType)) {
            //bulk getting royalties
            const itemsRoyalties = yield Promise.all(request.assetType.map((asset) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const royaltyList = yield apis.nftItem.getNftItemRoyaltyById({
                    itemId: `${asset.contract}:${asset.tokenId}`,
                });
                return royaltyList.royalty || [];
            })));
            return itemsRoyalties.flat();
        }
        else {
            return ((yield apis.nftItem.getNftItemRoyaltyById({
                itemId: `${request.assetType.contract}:${request.assetType.tokenId}`,
            })).royalty || []);
        }
    });
}
exports.getAmmItemsRoyalties = getAmmItemsRoyalties;
