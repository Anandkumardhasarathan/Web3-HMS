"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBasisPointsPlusAccount = exports.calcValueWithFees = exports.originFeeValueConvert = exports.getPackedFeeValue = exports.setFeesCurrency = exports.packFeesToUint = exports.ZERO_FEE_VALUE = void 0;
const utils_1 = require("@rarible/utils");
const utils_2 = require("@rarible/utils");
const types_1 = require("@rarible/types");
exports.ZERO_FEE_VALUE = (0, types_1.toBigNumber)("0x" + "0".repeat(64));
/**
 * Pack 2 number value to single uint256 (BigNumber)
 * @param fees
 */
function packFeesToUint(fees) {
    const firstFee = getPackedFeeValue(fees[0]);
    const secondFee = getPackedFeeValue(fees[1]);
    return (0, types_1.toBigNumber)("0x" + "0".repeat(64 - 8) + firstFee + secondFee);
}
exports.packFeesToUint = packFeesToUint;
function setFeesCurrency(value, isWeth) {
    const wethCurrencyPosition = 13;
    const rawHex = value.startsWith("0x") ? value.slice(2) : value;
    const normalizedPackedFees = rawHex.padStart(wethCurrencyPosition, "0");
    const arrFees = normalizedPackedFees.split("");
    arrFees[arrFees.length - wethCurrencyPosition] = Number(isWeth).toString();
    return (0, types_1.toBigNumber)("0x" + arrFees.join(""));
}
exports.setFeesCurrency = setFeesCurrency;
function getPackedFeeValue(fee) {
    var _a;
    return (_a = fee === null || fee === void 0 ? void 0 : fee.toString(16).padStart(4, "0")) !== null && _a !== void 0 ? _a : "0000";
}
exports.getPackedFeeValue = getPackedFeeValue;
/**
 * Check requirements for origin fees, converting them to single uint value for fee and list of fee receiver addresses
 * @param originFees
 */
function originFeeValueConvert(originFees) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (originFees && originFees.length > 2) {
        throw new Error("This method supports max up to 2 origin fee values");
    }
    const encodedFeesValue = packFeesToUint([(_a = originFees === null || originFees === void 0 ? void 0 : originFees[0]) === null || _a === void 0 ? void 0 : _a.value, (_b = originFees === null || originFees === void 0 ? void 0 : originFees[1]) === null || _b === void 0 ? void 0 : _b.value]);
    const addresses = [
        (_d = (_c = originFees === null || originFees === void 0 ? void 0 : originFees[0]) === null || _c === void 0 ? void 0 : _c.account) !== null && _d !== void 0 ? _d : types_1.EVM_ZERO_ADDRESS,
        (_f = (_e = originFees === null || originFees === void 0 ? void 0 : originFees[1]) === null || _e === void 0 ? void 0 : _e.account) !== null && _f !== void 0 ? _f : types_1.EVM_ZERO_ADDRESS,
    ];
    const totalFeeBasisPoints = ((_h = (_g = originFees === null || originFees === void 0 ? void 0 : originFees[0]) === null || _g === void 0 ? void 0 : _g.value) !== null && _h !== void 0 ? _h : 0) + ((_k = (_j = originFees === null || originFees === void 0 ? void 0 : originFees[1]) === null || _j === void 0 ? void 0 : _j.value) !== null && _k !== void 0 ? _k : 0);
    return {
        encodedFeesValue,
        totalFeeBasisPoints,
        feeAddresses: addresses,
    };
}
exports.originFeeValueConvert = originFeeValueConvert;
/**
 * Add fee to value
 * @param value
 * @param feesBasisPoints
 */
function calcValueWithFees(value, feesBasisPoints) {
    const feesValue = (0, utils_1.toBn)(feesBasisPoints).dividedBy(10000).multipliedBy(value).integerValue(utils_2.BigNumber.ROUND_FLOOR);
    return feesValue.plus(value);
}
exports.calcValueWithFees = calcValueWithFees;
function encodeBasisPointsPlusAccount(bp, account) {
    const bpConverted = (0, utils_1.toBn)("0x" + bp.toString(16) + "0".repeat(40));
    return (0, types_1.toBigNumber)("0x" + bpConverted.plus(account).toString(16));
}
exports.encodeBasisPointsPlusAccount = encodeBasisPointsPlusAccount;
