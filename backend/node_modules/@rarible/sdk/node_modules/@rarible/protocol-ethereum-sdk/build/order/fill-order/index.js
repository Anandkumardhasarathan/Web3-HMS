"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderFiller = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const action_1 = require("@rarible/action");
const check_asset_type_1 = require("../check-asset-type");
const check_lazy_asset_type_1 = require("../check-lazy-asset-type");
const rarible_v1_1 = require("./rarible-v1");
const rarible_v2_1 = require("./rarible-v2");
const open_sea_1 = require("./open-sea");
const crypto_punks_1 = require("./crypto-punks");
const seaport_1 = require("./seaport");
const x2y2_1 = require("./x2y2");
const looksrare_1 = require("./looksrare");
const amm_1 = require("./amm");
const get_updated_call_1 = require("./common/get-updated-call");
const looksrare_v2_1 = require("./looksrare-v2");
class OrderFiller {
    constructor(ethereum, send, getConfig, getApis, getBaseOrderFee, env, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getApis = getApis;
        this.sdkConfig = sdkConfig;
        /**
         * @deprecated Use {@link buy} or {@link acceptBid} instead
         */
        this.fill = this.getFillAction();
        /**
         * Buy order
         */
        this.buy = this.getFillAction();
        /**
         * Accept bid order
         */
        this.acceptBid = this.getFillAction();
        this.getFillOrderBaseFee = this.getFillOrderBaseFee.bind(this);
        this.getTransactionData = this.getTransactionData.bind(this);
        this.getBuyTx = this.getBuyTx.bind(this);
        this.v1Handler = new rarible_v1_1.RaribleV1OrderHandler(ethereum, getApis, send, getConfig, getBaseOrderFee, sdkConfig);
        this.v2Handler = new rarible_v2_1.RaribleV2OrderHandler(ethereum, send, getConfig, getBaseOrderFee);
        this.openSeaHandler = new open_sea_1.OpenSeaOrderHandler(ethereum, send, getConfig, getApis, getBaseOrderFee, sdkConfig);
        this.punkHandler = new crypto_punks_1.CryptoPunksOrderHandler(ethereum, send, getConfig, getBaseOrderFee, sdkConfig);
        this.seaportHandler = new seaport_1.SeaportOrderHandler(ethereum, send, getConfig, getApis, getBaseOrderFee, env, sdkConfig);
        this.looksrareHandler = new looksrare_1.LooksrareOrderHandler(ethereum, send, getConfig, getBaseOrderFee, env, getApis, sdkConfig);
        this.looksrareV2Handler = new looksrare_v2_1.LooksrareV2OrderHandler(ethereum, send, getConfig, getBaseOrderFee, env, getApis);
        this.x2y2Handler = new x2y2_1.X2Y2OrderHandler(ethereum, send, getConfig, getBaseOrderFee, getApis);
        this.ammHandler = new amm_1.AmmOrderHandler(ethereum, send, getConfig, getBaseOrderFee, getApis, env, sdkConfig);
        this.checkAssetType = check_asset_type_1.checkAssetType.bind(this, getApis);
        this.checkLazyAssetType = check_lazy_asset_type_1.checkLazyAssetType.bind(this, getApis);
        this.getBuyAmmInfo = this.getBuyAmmInfo.bind(this);
    }
    getFillAction() {
        return action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.ethereum) {
                    throw new Error("Wallet undefined");
                }
                if (this.isNonInvertableOrder(request.order)) {
                    return { request, inverted: request.order };
                }
                const from = (0, types_1.toEVMAddress)(yield this.ethereum.getFrom());
                const inverted = yield this.invertOrder(request, from);
                if (request.assetType && inverted.make.assetType.assetClass === "COLLECTION") {
                    inverted.make.assetType = yield this.checkAssetType(request.assetType);
                    inverted.make.assetType = yield this.checkLazyAssetType(inverted.make.assetType);
                }
                yield this.approveOrder(inverted, Boolean(request.infinite));
                return { request, inverted };
            }),
        }).thenStep({
            id: "send-tx",
            run: (_a) => tslib_1.__awaiter(this, [_a], void 0, function* ({ inverted, request }) {
                this.checkStartEndDates(request.order);
                return this.sendTransaction(request, inverted);
            }),
        });
    }
    getBuyTx(_a) {
        return tslib_1.__awaiter(this, arguments, void 0, function* ({ request, from }) {
            var _b;
            if (!this.isNonInvertableOrder(request.order) && !from) {
                throw new Error("'From' field must be specified for this order type");
            }
            const inverted = this.isNonInvertableOrder(request.order)
                ? request.order
                : yield this.invertOrder(request, (0, types_1.toEVMAddress)(from));
            if (request.assetType && inverted.make.assetType.assetClass === "COLLECTION") {
                inverted.make.assetType = yield this.checkAssetType(request.assetType);
            }
            const { functionCall, options } = yield this.getTransactionRequestData(request, inverted, {
                disableCheckingBalances: true,
            });
            const callInfo = yield functionCall.getCallInfo();
            const value = ((_b = options.value) === null || _b === void 0 ? void 0 : _b.toString()) || "0";
            return {
                from,
                value,
                data: yield functionCall.getData(),
                to: callInfo.contract,
            };
        });
    }
    invertOrder(request, from) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (request.order.type) {
                case "RARIBLE_V1":
                    return this.v1Handler.invert(request, from);
                case "RARIBLE_V2":
                    return this.v2Handler.invert(request, from);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.invert(request, from);
                case "SEAPORT_V1":
                    throw new Error("Invert for Seaport orders is not implemented yet");
                case "X2Y2":
                    throw new Error("Invert for x2y2 orders is not implemented yet");
                case "AMM":
                    throw new Error("Invert for AMM orders is not implemented yet");
                case "CRYPTO_PUNK":
                    return this.punkHandler.invert(request, from);
                default:
                    throw new Error(`Unsupported order: ${JSON.stringify(request)}`);
            }
        });
    }
    approveOrder(inverted, isInfinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (inverted.type) {
                case "RARIBLE_V1":
                    return this.v1Handler.approve(inverted, isInfinite);
                case "RARIBLE_V2":
                    return this.v2Handler.approve(inverted, isInfinite);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.approve(inverted, isInfinite);
                case "SEAPORT_V1":
                    throw new Error("Approve for Seaport orders is not implemented yet");
                case "X2Y2":
                    throw new Error("Approve for x2y2 orders is not implemented yet");
                case "AMM":
                    throw new Error("Approve for AMM orders is not implemented yet");
                case "CRYPTO_PUNK":
                    return this.punkHandler.approve(inverted, isInfinite);
                default:
                    throw new Error(`Unsupported order: ${JSON.stringify(inverted)}`);
            }
        });
    }
    sendTransaction(request, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { functionCall, options } = yield this.getTransactionRequestData(request, inverted);
            return this.send(functionCall, Object.assign(Object.assign({}, options), { additionalData: (0, get_updated_call_1.getUpdatedCalldata)(this.sdkConfig) }));
        });
    }
    getTransactionRequestData(request, inverted, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (request.order.type) {
                case "RARIBLE_V1":
                    return this.v1Handler.getTransactionData(request.order, inverted, request);
                case "RARIBLE_V2":
                    return this.v2Handler.getTransactionData(request.order, inverted);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.getTransactionData(request.order, inverted, request);
                case "SEAPORT_V1":
                    return this.seaportHandler.getTransactionData(request, {
                        disableCheckingBalances: options === null || options === void 0 ? void 0 : options.disableCheckingBalances,
                    });
                case "LOOKSRARE":
                    return this.looksrareHandler.getTransactionData(request);
                case "LOOKSRARE_V2":
                    return this.looksrareV2Handler.getTransactionData(request);
                case "AMM":
                    return this.ammHandler.getTransactionData(request);
                case "X2Y2":
                    return this.x2y2Handler.getTransactionData(request);
                case "CRYPTO_PUNK":
                    return this.punkHandler.getTransactionData(request.order, inverted);
                default:
                    throw new Error(`Unsupported request: ${JSON.stringify(request)}`);
            }
        });
    }
    getTransactionData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const from = (0, types_1.toEVMAddress)(yield this.ethereum.getFrom());
            const inverted = this.isNonInvertableOrder(request.order) ? request.order : yield this.invertOrder(request, from);
            if (request.assetType && inverted.make.assetType.assetClass === "COLLECTION") {
                inverted.make.assetType = yield this.checkAssetType(request.assetType);
            }
            const { functionCall, options } = yield this.getTransactionRequestData(request, inverted);
            const { contract } = yield functionCall.getCallInfo();
            return {
                from,
                contract: (0, types_1.toEVMAddress)(contract),
                data: yield functionCall.getData(),
                options,
            };
        });
    }
    getOrderFee(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (order.type) {
                case "RARIBLE_V1":
                    return this.v1Handler.getOrderFee(order);
                case "RARIBLE_V2":
                    return this.v2Handler.getOrderFee(order);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.getOrderFee(order);
                case "SEAPORT_V1":
                    return this.seaportHandler.getOrderFee();
                case "LOOKSRARE":
                    return this.looksrareHandler.getOrderFee();
                case "CRYPTO_PUNK":
                    return this.punkHandler.getOrderFee();
                case "X2Y2":
                    return this.x2y2Handler.getOrderFee();
                case "AMM":
                    return this.ammHandler.getOrderFee();
                default:
                    throw new Error(`Unsupported order: ${JSON.stringify(order)}`);
            }
        });
    }
    getFillOrderBaseFee(order, withOriginFees) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (order.type) {
                case "RARIBLE_V1":
                    return this.v1Handler.getFillOrderBaseFee();
                case "RARIBLE_V2":
                    return this.v2Handler.getFillOrderBaseFee(order, withOriginFees);
                case "OPEN_SEA_V1":
                    return this.openSeaHandler.getFillOrderBaseFee();
                case "SEAPORT_V1":
                    return this.seaportHandler.getFillOrderBaseFee();
                case "LOOKSRARE":
                    return this.looksrareHandler.getFillOrderBaseFee();
                case "LOOKSRARE_V2":
                    return this.looksrareV2Handler.getFillOrderBaseFee();
                case "CRYPTO_PUNK":
                    return this.punkHandler.getFillOrderBaseFee();
                case "AMM":
                    return this.ammHandler.getFillOrderBaseFee();
                case "X2Y2":
                    return this.x2y2Handler.getFillOrderBaseFee();
                default:
                    throw new Error(`Unsupported order: ${JSON.stringify(order)}`);
            }
        });
    }
    checkStartEndDates(order) {
        const now = Date.now();
        if (order.start !== undefined && new Date(order.start * 1000).getTime() > now) {
            throw new Error(`Order will be actual since ${new Date(order.start * 1000)}, now ${new Date()}`);
        }
        if (order.end !== undefined && new Date(order.end * 1000).getTime() < now) {
            throw new Error(`Order was actual until ${new Date(order.end * 1000)}, now ${new Date()}`);
        }
    }
    getBuyAmmInfo(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const apis = yield this.getApis();
            return apis.order.getAmmBuyInfo(request);
        });
    }
    isNonInvertableOrder(order) {
        return (order.type === "SEAPORT_V1" ||
            order.type === "LOOKSRARE" ||
            order.type === "LOOKSRARE_V2" ||
            order.type === "X2Y2" ||
            order.type === "AMM");
    }
}
exports.OrderFiller = OrderFiller;
