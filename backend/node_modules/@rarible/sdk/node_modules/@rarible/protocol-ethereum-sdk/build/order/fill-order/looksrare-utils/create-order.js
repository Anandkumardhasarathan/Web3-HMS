"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRaribleSellOrder = exports.makeSellOrder = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const get_required_wallet_1 = require("../../../common/get-required-wallet");
const wait_tx_1 = require("../../../common/wait-tx");
const approve_erc721_1 = require("../../approve-erc721");
const eip712_1 = require("../../eip712");
const constants_1 = require("./constants");
function makeSellOrder(ethereum, assetType, send, exchangeAddress) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const provider = (0, get_required_wallet_1.getRequiredWallet)(ethereum);
        const signerAddress = (0, types_1.toEVMAddress)(yield provider.getFrom());
        const chainId = yield provider.getChainId();
        const addresses = constants_1.addressesByNetwork[chainId];
        const nonce = yield provider.config.web3.eth.getTransactionCount(yield provider.getFrom(), "pending");
        const now = Math.floor(Date.now() / 1000);
        const minNetPriceRatio = 7500;
        const makerOrder = {
            isOrderAsk: true,
            signer: signerAddress,
            collection: assetType.contract,
            price: "1000",
            tokenId: assetType.tokenId,
            amount: "1",
            strategy: addresses.STRATEGY_STANDARD_SALE,
            currency: addresses.WETH,
            nonce: nonce,
            startTime: now,
            endTime: now + 86400,
            minPercentageToAsk: minNetPriceRatio,
            params: [],
        };
        yield (0, wait_tx_1.waitTx)((0, approve_erc721_1.approveErc721)(provider, send, assetType.contract, signerAddress, (0, types_1.toEVMAddress)(addresses.TRANSFER_MANAGER_ERC721)));
        return Object.assign(Object.assign({}, makerOrder), { signature: yield getOrderSignature(makerOrder, ethereum, exchangeAddress) });
    });
}
exports.makeSellOrder = makeSellOrder;
function makeRaribleSellOrder(ethereum, assetType, send, exchangeAddress) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const order = yield makeSellOrder(ethereum, assetType, send, exchangeAddress);
        return {
            type: "LOOKSRARE",
            maker: (0, types_1.toEVMAddress)(order.signer),
            make: {
                assetType,
                value: (0, types_1.toBigNumber)(order.amount.toString()),
            },
            take: {
                assetType: { assetClass: "ETH" },
                value: (0, types_1.toBigNumber)(order.price.toString()),
            },
            salt: types_1.ZERO_WORD,
            start: parseInt(order.startTime.toString()),
            end: parseInt(order.endTime.toString()),
            data: {
                dataType: "LOOKSRARE_DATA_V1",
                minPercentageToAsk: parseInt(order.minPercentageToAsk.toString()),
                strategy: (0, types_1.toEVMAddress)(order.strategy),
                nonce: parseInt(order.nonce.toString()),
            },
            signature: (0, types_1.toBinary)(order.signature),
        };
    });
}
exports.makeRaribleSellOrder = makeRaribleSellOrder;
function getOrderSignature(order, ethereum, exchangeContract) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const provider = (0, get_required_wallet_1.getRequiredWallet)(ethereum);
        if (!exchangeContract) {
            throw new Error("Looksrare order cannot be signed without exchange address in config");
        }
        const domain = {
            name: "LooksRareExchange",
            version: "1",
            chainId: yield ethereum.getChainId(),
            verifyingContract: exchangeContract,
        };
        const type = {
            MakerOrder: [
                { name: "isOrderAsk", type: "bool" },
                { name: "signer", type: "address" },
                { name: "collection", type: "address" },
                { name: "price", type: "uint256" },
                { name: "tokenId", type: "uint256" },
                { name: "amount", type: "uint256" },
                { name: "strategy", type: "address" },
                { name: "currency", type: "address" },
                { name: "nonce", type: "uint256" },
                { name: "startTime", type: "uint256" },
                { name: "endTime", type: "uint256" },
                { name: "minPercentageToAsk", type: "uint256" },
                { name: "params", type: "bytes" },
            ],
        };
        const signature = yield provider.signTypedData({
            primaryType: "MakerOrder",
            domain,
            types: Object.assign(Object.assign({}, eip712_1.EIP712_ORDER_TYPES), type),
            message: {
                isOrderAsk: order.isOrderAsk,
                signer: order.signer,
                collection: order.collection,
                price: order.price,
                tokenId: order.tokenId,
                amount: order.amount,
                strategy: order.strategy,
                currency: order.currency,
                nonce: order.nonce,
                startTime: order.startTime,
                endTime: order.endTime,
                minPercentageToAsk: order.minPercentageToAsk,
                params: order.params,
            },
        });
        return signature;
    });
}
