import type { Asset, Binary, Erc1155AssetType, Erc721AssetType, Part } from "@rarible/ethereum-api-client";
import type { Ethereum, EthereumFunctionCall, EthereumSendOptions, EthereumTransaction } from "@rarible/ethereum-provider";
import type { BigNumber, EVMAddress, Address } from "@rarible/types";
import type { Maybe } from "@rarible/types";
import type { BigNumberValue } from "@rarible/utils";
import type { SendFunction } from "../../common/send-transaction";
import type { SimpleOpenSeaV1Order, SimpleOrder } from "../types";
import type { RaribleEthereumApis } from "../../common/apis";
import type { IRaribleEthereumSdkConfig } from "../../types";
import type { GetConfigByChainId } from "../../config";
import type { OpenSeaOrderDTO } from "./open-sea-types";
import type { OpenSeaV1OrderFillRequest, OrderFillSendData, OrderHandler, PreparedOrderRequestDataForExchangeWrapper } from "./types";
export type EncodedOrderCallData = {
    callData: Binary;
    replacementPattern: Binary;
    target: EVMAddress;
};
export declare class OpenSeaOrderHandler implements OrderHandler<OpenSeaV1OrderFillRequest> {
    private readonly ethereum;
    private readonly send;
    private readonly getConfig;
    private readonly getApis;
    private readonly getBaseOrderFeeConfig;
    private readonly sdkConfig?;
    constructor(ethereum: Maybe<Ethereum>, send: SendFunction, getConfig: GetConfigByChainId, getApis: () => Promise<RaribleEthereumApis>, getBaseOrderFeeConfig: (type: SimpleOrder["type"]) => Promise<number>, sdkConfig?: IRaribleEthereumSdkConfig | undefined);
    getOrderMetadata(): Promise<import("@rarible/ethereum-api-client").Word>;
    invert({ order, payouts }: OpenSeaV1OrderFillRequest, maker: EVMAddress): Promise<SimpleOpenSeaV1Order>;
    encodeOrder(order: SimpleOpenSeaV1Order): Promise<EncodedOrderCallData>;
    getErc721EncodedData(assetType: Erc721AssetType, maker: Address | EVMAddress, isSellSide: boolean, validatorAddress: EVMAddress | undefined, initialCalldata: Binary): Promise<EncodedOrderCallData>;
    getErc1155EncodedData(assetType: Erc1155AssetType, value: BigNumberValue, maker: Address | EVMAddress, isSellSide: boolean, validatorAddress: EVMAddress | undefined): Promise<EncodedOrderCallData>;
    getFillOrderBaseFee(): Promise<number>;
    getOrderFee(order: SimpleOpenSeaV1Order): number;
    approve(order: SimpleOpenSeaV1Order, infinite: boolean): Promise<void>;
    getTransactionData(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order, request: OpenSeaV1OrderFillRequest): Promise<OrderFillSendData>;
    getTransactionDataForExchangeWrapper(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order, originFees: Part[] | undefined, feeValue: BigNumber): Promise<PreparedOrderRequestDataForExchangeWrapper>;
    getAtomicMatchFunctionCall(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order): Promise<EthereumFunctionCall>;
    private ordersCanMatch;
    private getAddressesArrayForTransaction;
    approveSingle(maker: EVMAddress, asset: Asset, infinite?: undefined | boolean): Promise<EthereumTransaction | undefined>;
    private getRegisteredProxy;
}
export declare function getMatchOpenseaOptions(buy: SimpleOpenSeaV1Order, originFees?: Part[]): Promise<EthereumSendOptions>;
export declare function getBuySellOrders(left: SimpleOpenSeaV1Order, right: SimpleOpenSeaV1Order): {
    buy: SimpleOpenSeaV1Order;
    sell: SimpleOpenSeaV1Order;
};
export declare function getAtomicMatchArgAddresses(dto: OpenSeaOrderDTO): EVMAddress[];
export declare function getAtomicMatchArgAddressesForOpenseaWrapper(sellDto: OpenSeaOrderDTO, openseaWrapper: EVMAddress): EVMAddress[];
export declare function getAtomicMatchArgUints(dto: OpenSeaOrderDTO): import("@rarible/ethereum-api-client").BigNumberLike[];
export declare function getAtomicMatchArgCommonData(dto: OpenSeaOrderDTO): (import("./open-sea-types").OrderOpenSeaV1DataV1FeeMethod | import("./open-sea-types").OrderOpenSeaV1DataV1Side | import("./open-sea-types").OrderOpenSeaV1DataV1SaleKind | import("./open-sea-types").OrderOpenSeaV1DataV1HowToCall)[];
