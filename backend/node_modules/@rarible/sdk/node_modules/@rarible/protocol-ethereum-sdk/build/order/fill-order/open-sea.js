"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomicMatchArgCommonData = exports.getAtomicMatchArgUints = exports.getAtomicMatchArgAddressesForOpenseaWrapper = exports.getAtomicMatchArgAddresses = exports.getBuySellOrders = exports.getMatchOpenseaOptions = exports.OpenSeaOrderHandler = void 0;
const tslib_1 = require("tslib");
const ethereum_api_client_1 = require("@rarible/ethereum-api-client");
const types_1 = require("@rarible/types");
const exponential_backoff_1 = require("exponential-backoff");
const utils_1 = require("@rarible/utils");
const api_client_1 = require("@rarible/api-client");
const proxy_registry_opensea_1 = require("../contracts/proxy-registry-opensea");
const approve_erc20_1 = require("../approve-erc20");
const approve_erc721_1 = require("../approve-erc721");
const approve_erc1155_1 = require("../approve-erc1155");
const get_asset_with_fee_1 = require("../get-asset-with-fee");
const exchange_opensea_v1_1 = require("../contracts/exchange-opensea-v1");
const to_vrs_1 = require("../../common/to-vrs");
const wait_tx_1 = require("../../common/wait-tx");
const get_required_wallet_1 = require("../../common/get-required-wallet");
const erc721_1 = require("../../nft/contracts/erc721");
const domain_1 = require("../../nft/contracts/domain");
const merkle_validator_1 = require("../contracts/merkle-validator");
const erc1155_1 = require("../contracts/erc1155");
const id_1 = require("../../common/id");
const exchange_wrapper_1 = require("../contracts/exchange-wrapper");
const common_1 = require("../../common");
const types_2 = require("./types");
const open_sea_converter_1 = require("./open-sea-converter");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
class OpenSeaOrderHandler {
    constructor(ethereum, send, getConfig, getApis, getBaseOrderFeeConfig, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getApis = getApis;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.sdkConfig = sdkConfig;
    }
    getOrderMetadata() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            const blockchain = (0, common_1.getBlockchainFromChainId)(config.chainId);
            const ethereumNetworkConfig = getEthereumNetworkConfig(blockchain, this.sdkConfig);
            if (ethereumNetworkConfig && ethereumNetworkConfig.openseaOrdersMetadata) {
                return (0, types_1.toWord)(ethereumNetworkConfig.openseaOrdersMetadata);
            }
            return config.openSea.metadata || (0, id_1.id32)("RARIBLE");
        });
    }
    invert(_a, maker_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* ({ order, payouts }, maker) {
            var _b;
            if (order.data.side === "BUY") {
                throw new Error("Bid opensea orders is not supported yet");
            }
            if (order.data.feeRecipient === types_1.EVM_ZERO_ADDRESS) {
                throw new Error("feeRecipient should be specified");
            }
            const data = Object.assign(Object.assign({}, order.data), { feeRecipient: types_1.EVM_ZERO_ADDRESS, side: ethereum_api_client_1.OrderOpenSeaV1DataV1Side.BUY });
            const invertedOrder = Object.assign(Object.assign({}, order), { make: Object.assign({}, order.take), take: Object.assign({}, order.make), 
                /**
                 * if orders is not bid(for now opensea orders can be only regular sell type) - payouts(for nft asset)
                 * should have single recipient
                 */
                maker: payouts && ((_b = payouts[0]) === null || _b === void 0 ? void 0 : _b.account) ? payouts[0].account : maker, taker: order.maker, signature: undefined, data });
            invertedOrder.data = Object.assign(Object.assign({}, invertedOrder.data), (yield this.encodeOrder(invertedOrder)));
            return invertedOrder;
        });
    }
    encodeOrder(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const makeAssetType = order.make.assetType;
            const takeAssetType = order.take.assetType;
            const config = yield this.getConfig();
            const validatorAddress = order.data.target && order.data.target === config.openSea.merkleValidator ? order.data.target : undefined;
            if (makeAssetType.assetClass === "ERC721") {
                return this.getErc721EncodedData(makeAssetType, order.maker, true, validatorAddress, order.data.callData);
            }
            else if (makeAssetType.assetClass === "ERC1155") {
                return this.getErc1155EncodedData(makeAssetType, order.make.value, order.maker, true, validatorAddress);
            }
            else if (takeAssetType.assetClass === "ERC721") {
                return this.getErc721EncodedData(takeAssetType, order.maker, false, validatorAddress, order.data.callData);
            }
            else if (takeAssetType.assetClass === "ERC1155") {
                return this.getErc1155EncodedData(takeAssetType, order.take.value, order.maker, false, validatorAddress);
            }
            else {
                throw new Error("should never happen");
            }
        });
    }
    getErc721EncodedData(assetType, maker, isSellSide, validatorAddress, initialCalldata) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            let startArgs = [maker, types_1.EVM_ZERO_ADDRESS];
            if (!isSellSide) {
                startArgs = [types_1.EVM_ZERO_ADDRESS, maker];
            }
            if (validatorAddress) {
                const c = (0, merkle_validator_1.createMerkleValidatorContract)(ethereum, validatorAddress);
                const isSafeV3Method = initialCalldata.startsWith(MATCH_ERC721_SAFE_TRANSFER_SIGNATURE);
                const callMethod = isSafeV3Method ? "matchERC721WithSafeTransferUsingCriteria" : "matchERC721UsingCriteria";
                const methodArgs = [...startArgs, assetType.contract, assetType.tokenId, "0x", []];
                return {
                    replacementPattern: isSellSide ? open_sea_converter_1.ERC721_VALIDATOR_MAKE_REPLACEMENT : open_sea_converter_1.ERC721_VALIDATOR_TAKE_REPLACEMENT,
                    callData: (0, types_1.toBinary)(yield c.functionCall(callMethod, ...methodArgs).getData()),
                    target: validatorAddress,
                };
            }
            else {
                let callData;
                const transferArgs = [...startArgs, assetType.tokenId];
                const isSafeV3Method = initialCalldata.startsWith(SAFE_TRANSFER_SIGNATURE);
                if (isSafeV3Method) {
                    const c = yield (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V3, assetType.contract);
                    callData = (0, types_1.toBinary)(yield c.functionCall("safeTransferFrom", ...transferArgs).getData());
                }
                else {
                    const c = yield (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V2, assetType.contract);
                    callData = (0, types_1.toBinary)(yield c.functionCall("transferFrom", ...transferArgs).getData());
                }
                return {
                    replacementPattern: isSellSide ? open_sea_converter_1.ERC721_MAKE_REPLACEMENT : open_sea_converter_1.ERC721_TAKE_REPLACEMENT,
                    target: assetType.contract,
                    callData,
                };
            }
        });
    }
    getErc1155EncodedData(assetType, value, maker, isSellSide, validatorAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
            let startArgs = [maker, types_1.EVM_ZERO_ADDRESS];
            if (!isSellSide) {
                startArgs = [types_1.EVM_ZERO_ADDRESS, maker];
            }
            if (validatorAddress) {
                const c = (0, merkle_validator_1.createMerkleValidatorContract)(ethereum, validatorAddress);
                const methodArgs = [...startArgs, assetType.contract, assetType.tokenId, value, "0x", []];
                return {
                    replacementPattern: isSellSide ? open_sea_converter_1.ERC1155_VALIDATOR_MAKE_REPLACEMENT : open_sea_converter_1.ERC1155_VALIDATOR_TAKE_REPLACEMENT,
                    target: validatorAddress,
                    callData: (0, types_1.toBinary)(yield c.functionCall("matchERC1155UsingCriteria", ...methodArgs).getData()),
                };
            }
            else {
                const c = (0, erc1155_1.createErc1155Contract)(ethereum, assetType.contract);
                const methodArgs = [...startArgs, assetType.tokenId, value, "0x"];
                return {
                    replacementPattern: isSellSide ? open_sea_converter_1.ERC1155_MAKE_REPLACEMENT : open_sea_converter_1.ERC1155_TAKE_REPLACEMENT,
                    target: assetType.contract,
                    callData: (0, types_1.toBinary)(yield c.functionCall("safeTransferFrom", ...methodArgs).getData()),
                };
            }
        });
    }
    getFillOrderBaseFee() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.getBaseOrderFeeConfig("OPEN_SEA_V1");
        });
    }
    getOrderFee(order) {
        if (order.data.feeRecipient === types_1.EVM_ZERO_ADDRESS) {
            return (0, utils_1.toBn)(order.data.takerProtocolFee).plus(order.data.takerRelayerFee).toNumber();
        }
        else {
            return (0, utils_1.toBn)(order.data.makerProtocolFee).plus(order.data.makerRelayerFee).toNumber();
        }
    }
    approve(order, infinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const fee = this.getOrderFee(order);
            if (order.data.side === "BUY") {
                const assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, fee);
                yield (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, assetWithFee, infinite));
            }
            else {
                yield (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, order.make, infinite));
                const value = (0, utils_1.toBn)(order.take.value).multipliedBy(fee).dividedBy(10000).integerValue(utils_1.BigNumber.ROUND_FLOOR).toFixed();
                const feeOnly = Object.assign(Object.assign({}, order.take), { value: (0, types_1.toBigNumber)(value) });
                yield (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, feeOnly, infinite));
            }
        });
    }
    getTransactionData(initial, inverted, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const isTakeEth = initial.take.assetType.assetClass === "ETH";
            const atomicMatchFunctionCall = yield this.getAtomicMatchFunctionCall(initial, inverted);
            const { buy } = getBuySellOrders(initial, inverted);
            const config = yield this.getConfig();
            if (isTakeEth) {
                const openseaWrapperContract = (0, exchange_wrapper_1.createExchangeWrapperContract)(this.ethereum, config.exchange.wrapper);
                const { encodedFeesValue, feeAddresses } = (0, origin_fees_utils_1.originFeeValueConvert)(request.originFees);
                const { data, options } = yield this.getTransactionDataForExchangeWrapper(initial, inverted, request.originFees, encodedFeesValue);
                const functionCall = openseaWrapperContract.functionCall("singlePurchase", data, feeAddresses[0], feeAddresses[1]);
                return {
                    functionCall,
                    options,
                };
            }
            else {
                return {
                    functionCall: atomicMatchFunctionCall,
                    options: yield getMatchOpenseaOptions(buy),
                };
            }
        });
    }
    getTransactionDataForExchangeWrapper(initial, inverted, originFees, feeValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const atomicMatchFunctionCall = yield this.getAtomicMatchFunctionCall(initial, inverted);
            const { buy } = getBuySellOrders(initial, inverted);
            return {
                data: {
                    marketId: types_2.ExchangeWrapperOrderType.OPENSEA_V1,
                    amount: (yield getMatchOpenseaOptions(buy)).value,
                    fees: feeValue,
                    data: yield atomicMatchFunctionCall.getData(),
                },
                options: yield getMatchOpenseaOptions(buy, originFees),
            };
        });
    }
    getAtomicMatchFunctionCall(initial, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const isTakeEth = initial.take.assetType.assetClass === "ETH";
            const { buy, sell } = getBuySellOrders(initial, inverted);
            const sellOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, sell);
            const buyOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, buy);
            const exchangeContract = (0, exchange_opensea_v1_1.createOpenseaContract)(this.ethereum, initial.data.exchange);
            const buyVRS = (0, to_vrs_1.toVrs)(buy.signature || "");
            const sellVRS = (0, to_vrs_1.toVrs)(sell.signature || "");
            const ordersCanMatch = yield this.ordersCanMatch(exchangeContract, buyOrderToSignDTO, sellOrderToSignDTO, isTakeEth);
            if (!ordersCanMatch) {
                throw new Error("Orders cannot be matched");
            }
            return exchangeContract.functionCall("atomicMatch_", this.getAddressesArrayForTransaction(buyOrderToSignDTO, sellOrderToSignDTO, isTakeEth), [...getAtomicMatchArgUints(buyOrderToSignDTO), ...getAtomicMatchArgUints(sellOrderToSignDTO)], [...getAtomicMatchArgCommonData(buyOrderToSignDTO), ...getAtomicMatchArgCommonData(sellOrderToSignDTO)], buyOrderToSignDTO.calldata, sellOrderToSignDTO.calldata, buyOrderToSignDTO.replacementPattern, sellOrderToSignDTO.replacementPattern, buyOrderToSignDTO.staticExtradata, sellOrderToSignDTO.staticExtradata, [buyVRS.v, sellVRS.v], [buyVRS.r, buyVRS.s, sellVRS.r, sellVRS.s, this.getOrderMetadata()]);
        });
    }
    ordersCanMatch(exchangeContract, buyOrderToSignDTO, sellOrderToSignDTO, isTakeEth) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ordersCanMatch = yield exchangeContract
                .functionCall("ordersCanMatch_", this.getAddressesArrayForTransaction(buyOrderToSignDTO, sellOrderToSignDTO, isTakeEth), [...getAtomicMatchArgUints(buyOrderToSignDTO), ...getAtomicMatchArgUints(sellOrderToSignDTO)], [...getAtomicMatchArgCommonData(buyOrderToSignDTO), ...getAtomicMatchArgCommonData(sellOrderToSignDTO)], buyOrderToSignDTO.calldata, sellOrderToSignDTO.calldata, buyOrderToSignDTO.replacementPattern, sellOrderToSignDTO.replacementPattern, buyOrderToSignDTO.staticExtradata, sellOrderToSignDTO.staticExtradata)
                .call();
            return !!ordersCanMatch;
        });
    }
    getAddressesArrayForTransaction(buyOrderToSignDTO, sellOrderToSignDTO, isTakeEth) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            return isTakeEth
                ? [...getAtomicMatchArgAddressesForOpenseaWrapper(sellOrderToSignDTO, config.exchange.wrapper)]
                : [...getAtomicMatchArgAddresses(buyOrderToSignDTO), ...getAtomicMatchArgAddresses(sellOrderToSignDTO)];
        });
    }
    approveSingle(maker_1, asset_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (maker, asset, infinite = true) {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            switch (asset.assetType.assetClass) {
                case "ERC20": {
                    const contract = asset.assetType.contract;
                    const operator = config.transferProxies.openseaV1;
                    return (0, approve_erc20_1.approveErc20)(this.ethereum, this.send, contract, maker, operator, asset.value, infinite);
                }
                case "ERC721": {
                    const contract = asset.assetType.contract;
                    const proxyAddress = yield this.getRegisteredProxy(maker);
                    return (0, approve_erc721_1.approveErc721)(this.ethereum, this.send, contract, maker, proxyAddress);
                }
                case "ERC1155": {
                    const contract = asset.assetType.contract;
                    const proxyAddress = yield this.getRegisteredProxy(maker);
                    return (0, approve_erc1155_1.approveErc1155)(this.ethereum, this.send, contract, maker, proxyAddress);
                }
                default:
                    return undefined;
            }
        });
    }
    getRegisteredProxy(maker) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            const proxyRegistry = config.openSea.proxyRegistry;
            const proxyRegistryContract = (0, proxy_registry_opensea_1.createOpenseaProxyRegistryEthContract)(this.ethereum, proxyRegistry);
            const proxyAddress = yield getSenderProxy(proxyRegistryContract, maker);
            if (proxyAddress === types_1.EVM_ZERO_ADDRESS) {
                const registerTx = yield proxyRegistryContract.functionCall("registerProxy").send();
                yield registerTx.wait();
                return (0, exponential_backoff_1.backOff)(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const value = yield getSenderProxy(proxyRegistryContract, maker);
                    if (value === types_1.EVM_ZERO_ADDRESS) {
                        throw new Error("Expected non-zero proxy address");
                    }
                    return value;
                }), {
                    maxDelay: 500,
                    numOfAttempts: 10,
                    delayFirstAttempt: true,
                    startingDelay: 100,
                });
            }
            return proxyAddress;
        });
    }
}
exports.OpenSeaOrderHandler = OpenSeaOrderHandler;
function getMatchOpenseaOptions(buy, originFees) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (buy.make.assetType.assetClass === "ETH") {
            const origin = originFees === null || originFees === void 0 ? void 0 : originFees.map(f => f.value).reduce((v, acc) => v + acc, 0);
            const fee = (0, utils_1.toBn)(buy.data.takerProtocolFee)
                .plus(buy.data.takerRelayerFee)
                .plus(origin || 0)
                .toNumber();
            const assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(buy.make, fee);
            return { value: assetWithFee.value };
        }
        else {
            return {};
        }
    });
}
exports.getMatchOpenseaOptions = getMatchOpenseaOptions;
function getSenderProxy(registryContract, sender) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (0, types_1.toEVMAddress)(yield registryContract.functionCall("proxies", sender).call());
    });
}
function getBuySellOrders(left, right) {
    if (left.data.side === "SELL") {
        return {
            buy: right,
            sell: left,
        };
    }
    else {
        return {
            buy: left,
            sell: right,
        };
    }
}
exports.getBuySellOrders = getBuySellOrders;
function getAtomicMatchArgAddresses(dto) {
    return [dto.exchange, dto.maker, dto.taker, dto.feeRecipient, dto.target, dto.staticTarget, dto.paymentToken];
}
exports.getAtomicMatchArgAddresses = getAtomicMatchArgAddresses;
function getAtomicMatchArgAddressesForOpenseaWrapper(sellDto, openseaWrapper) {
    return [
        sellDto.exchange,
        openseaWrapper,
        sellDto.maker,
        types_1.EVM_ZERO_ADDRESS,
        sellDto.target,
        sellDto.staticTarget,
        sellDto.paymentToken,
        ...getAtomicMatchArgAddresses(sellDto),
    ];
}
exports.getAtomicMatchArgAddressesForOpenseaWrapper = getAtomicMatchArgAddressesForOpenseaWrapper;
function getAtomicMatchArgUints(dto) {
    return [
        dto.makerRelayerFee,
        dto.takerRelayerFee,
        dto.makerProtocolFee,
        dto.takerProtocolFee,
        dto.basePrice,
        dto.extra,
        dto.listingTime,
        dto.expirationTime,
        dto.salt,
    ];
}
exports.getAtomicMatchArgUints = getAtomicMatchArgUints;
function getAtomicMatchArgCommonData(dto) {
    return [dto.feeMethod, dto.side, dto.saleKind, dto.howToCall];
}
exports.getAtomicMatchArgCommonData = getAtomicMatchArgCommonData;
function getEthereumNetworkConfig(blockchain, sdkConfig) {
    if (!sdkConfig) {
        return;
    }
    switch (blockchain) {
        case api_client_1.Blockchain.ETHEREUM:
            return sdkConfig.ethereum;
        case api_client_1.Blockchain.POLYGON:
            return sdkConfig.polygon;
        case api_client_1.Blockchain.MANTLE:
            return sdkConfig.mantle;
        default:
            return;
    }
}
const MATCH_ERC721_SAFE_TRANSFER_SIGNATURE = "0xc5a0236e";
const SAFE_TRANSFER_SIGNATURE = "0x42842e0e";
