"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toStructLegacyOrderKey = exports.toStructLegacyOrder = exports.RaribleV1OrderHandler = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const approve_1 = require("../approve");
const get_asset_with_fee_1 = require("../get-asset-with-fee");
const exchange_v1_1 = require("../contracts/exchange-v1");
const to_legacy_asset_type_1 = require("../to-legacy-asset-type");
const to_vrs_1 = require("../../common/to-vrs");
const wait_tx_1 = require("../../common/wait-tx");
const invert_order_1 = require("./invert-order");
class RaribleV1OrderHandler {
    constructor(ethereum, getApis, send, getConfig, getBaseOrderFeeConfig, sdkConfig) {
        this.ethereum = ethereum;
        this.getApis = getApis;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.sdkConfig = sdkConfig;
    }
    invert(request, maker) {
        const inverted = (0, invert_order_1.invertOrder)(request.order, request.amount, maker);
        inverted.data = {
            dataType: "LEGACY",
            fee: request.originFee,
        };
        return inverted;
    }
    approve(order, infinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const withFee = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, this.getOrderFee(order));
            yield (0, wait_tx_1.waitTx)((0, approve_1.approve)(this.ethereum, this.send, () => this.getConfig(), order.maker, withFee, infinite));
        });
    }
    getFillOrderBaseFee() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.getBaseOrderFeeConfig("RARIBLE_V1");
        });
    }
    getOrderFee(order) {
        return order.data.fee;
    }
    getTransactionData(initial, inverted, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const apis = yield this.getApis();
            const buyerFeeSig = yield apis.order.buyerFeeSignature({
                fee: inverted.data.fee,
                orderForm: Object.assign(Object.assign({}, initial), { salt: (0, types_1.toBigNumber)((0, utils_1.toBn)(initial.salt).toString()), signature: initial.signature || (0, types_1.toBinary)("0x"), end: initial.end }),
            });
            const config = yield this.getConfig();
            const exchangeContract = (0, exchange_v1_1.createExchangeV1Contract)(this.ethereum, config.exchange.v1);
            const functionCall = exchangeContract.functionCall("exchange", toStructLegacyOrder(initial), (0, to_vrs_1.toVrs)(initial.signature), inverted.data.fee, (0, to_vrs_1.toVrs)(buyerFeeSig), inverted.take.value, (_a = request.payout) !== null && _a !== void 0 ? _a : types_1.EVM_ZERO_ADDRESS);
            const options = getMatchV1Options(inverted);
            return {
                functionCall,
                options,
            };
        });
    }
}
exports.RaribleV1OrderHandler = RaribleV1OrderHandler;
function getMatchV1Options(order) {
    if (order.make.assetType.assetClass === "ETH") {
        const makeAsset = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, order.data.fee);
        return { value: makeAsset.value };
    }
    else {
        return {};
    }
}
function toStructLegacyOrder(order) {
    if (order.type !== "RARIBLE_V1") {
        throw new Error(`Not supported type: ${order.type}`);
    }
    const data = order.data;
    if (data.dataType !== "LEGACY") {
        throw new Error(`Not supported data type: ${data.dataType}`);
    }
    return {
        key: toStructLegacyOrderKey(order),
        selling: order.make.value,
        buying: order.take.value,
        sellerFee: data.fee,
    };
}
exports.toStructLegacyOrder = toStructLegacyOrder;
function toStructLegacyOrderKey(order) {
    return {
        owner: order.maker,
        salt: order.salt,
        sellAsset: (0, to_legacy_asset_type_1.toLegacyAssetType)(order.make.assetType),
        buyAsset: (0, to_legacy_asset_type_1.toLegacyAssetType)(order.take.assetType),
    };
}
exports.toStructLegacyOrderKey = toStructLegacyOrderKey;
