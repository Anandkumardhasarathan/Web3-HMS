"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RaribleV2OrderHandler = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const sign_order_1 = require("../sign-order");
const get_asset_with_fee_1 = require("../get-asset-with-fee");
const approve_1 = require("../approve");
const exchange_v2_1 = require("../contracts/exchange-v2");
const wait_tx_1 = require("../../common/wait-tx");
const is_signer_1 = require("../../common/is-signer");
const fix_signature_1 = require("../../common/fix-signature");
const common_1 = require("../../nft/common");
const config_1 = require("../../config");
const order_1 = require("../../common/order");
const encode_rarible_v2_order_1 = require("./rarible-v2/encode-rarible-v2-order");
const invert_order_1 = require("./invert-order");
const types_2 = require("./types");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
class RaribleV2OrderHandler {
    constructor(ethereum, send, getConfig, getBaseFee) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseFee = getBaseFee;
    }
    invert(request, maker) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const inverted = (0, invert_order_1.invertOrder)(request.order, request.amount, maker);
            switch (request.order.data.dataType) {
                case "RARIBLE_V2_DATA_V1": {
                    const v3 = yield this.shouldUseV3(request.originFees);
                    inverted.data = {
                        dataType: v3 ? "RARIBLE_V2_DATA_V3" : "RARIBLE_V2_DATA_V2",
                        originFees: request.originFees || [],
                        payouts: request.payouts || [],
                        isMakeFill: true, // for V1 order isMakeFill is always false, so inverted = true
                    };
                    break;
                }
                case "RARIBLE_V2_DATA_V2": {
                    const v3 = yield this.shouldUseV3(request.originFees);
                    inverted.data = {
                        dataType: v3 ? "RARIBLE_V2_DATA_V3" : "RARIBLE_V2_DATA_V2",
                        originFees: request.originFees || [],
                        payouts: request.payouts || [],
                        isMakeFill: !request.order.data.isMakeFill,
                    };
                    break;
                }
                case "RARIBLE_V2_DATA_V3": {
                    const v3 = yield this.shouldUseV3(request.originFees);
                    inverted.data = {
                        dataType: v3 ? "RARIBLE_V2_DATA_V3" : "RARIBLE_V2_DATA_V2",
                        originFees: request.originFees || [],
                        payouts: request.payouts || [],
                        isMakeFill: !request.order.data.isMakeFill,
                    };
                    break;
                }
                default:
                    throw new Error("Unsupported order dataType");
            }
            return inverted;
        });
    }
    shouldUseV3(fees) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const originFees = (fees || []).reduce((sum, prev) => sum + prev.value, 0);
            //should not use v3 if order doesn't have fees, so protocol also should not take any fees
            return this.shouldUseV3Simplified(originFees !== 0);
        });
    }
    shouldUseV3Simplified(withOriginFees) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (withOriginFees) {
                const baseFee = yield this.getBaseFee(order_1.CURRENT_ORDER_TYPE_VERSION);
                //if base fee is non-zero, then use v3 (with protocol fees), otherwise use v2 (without fees)
                return baseFee !== 0;
            }
            return false;
        });
    }
    getAssetToApprove(inverted) {
        return this.getMakeAssetWithFee(inverted);
    }
    approve(order, infinite) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const withFee = yield this.getMakeAssetWithFee(order);
            yield (0, wait_tx_1.waitTx)((0, approve_1.approve)(this.ethereum, this.send, () => this.getConfig(), order.maker, withFee, infinite));
        });
    }
    getTransactionData(initial, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            const exchangeContract = (0, exchange_v2_1.createExchangeV2Contract)(this.ethereum, config.exchange.v2);
            const functionCall = exchangeContract.functionCall("matchOrders", yield this.fixForTx(initial), (0, fix_signature_1.fixSignature)(initial.signature) || "0x", (0, sign_order_1.orderToStruct)(this.ethereum, inverted), (0, fix_signature_1.fixSignature)(inverted.signature) || "0x");
            const options = yield this.getMatchV2Options(initial, inverted);
            return {
                functionCall,
                options,
            };
        });
    }
    getTransactionDataForExchangeWrapper(initial, inverted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            if (!initial.signature) {
                initial.signature = yield (0, sign_order_1.signOrder)(this.ethereum, () => this.getConfig(), initial);
            }
            // fix payouts to send bought item to buyer
            if (inverted.data.dataType === "RARIBLE_V2_DATA_V1" ||
                inverted.data.dataType === "RARIBLE_V2_DATA_V2" ||
                inverted.data.dataType === "RARIBLE_V2_DATA_V3") {
                if (!((_a = inverted.data.payouts) === null || _a === void 0 ? void 0 : _a.length)) {
                    inverted.data.payouts = [
                        {
                            account: inverted.maker,
                            value: 10000,
                        },
                    ];
                }
            }
            const signature = (0, fix_signature_1.fixSignature)(initial.signature) || "0x";
            const callData = (0, encode_rarible_v2_order_1.encodeRaribleV2OrderPurchaseStruct)(this.ethereum, initial, signature, inverted, true);
            const options = yield this.getMatchV2Options(initial, inverted);
            let fees = origin_fees_utils_1.ZERO_FEE_VALUE;
            // let amount
            const paymentAsset = yield this.getMakeAssetWithFee(inverted);
            if ((0, common_1.isWeth)(initial.take.assetType, config)) {
                fees = (0, origin_fees_utils_1.setFeesCurrency)(fees, true);
            }
            return {
                data: {
                    marketId: types_2.ExchangeWrapperOrderType.RARIBLE_V2,
                    amount: paymentAsset.value,
                    fees, // using zero fee because fees already included in callData
                    data: callData,
                },
                options,
            };
        });
    }
    fixForTx(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = (0, config_1.getNetworkConfigByChainId)(yield this.ethereum.getChainId());
            const hash = (0, sign_order_1.hashToSign)(config, this.ethereum, order);
            const isMakerSigner = yield (0, is_signer_1.isSigner)(this.ethereum, order.maker, hash, order.signature);
            return (0, sign_order_1.orderToStruct)(this.ethereum, order, !isMakerSigner);
        });
    }
    getMatchV2Options(left, right) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ((0, common_1.isETH)(left.make.assetType) && left.salt === types_1.ZERO_WORD) {
                const asset = yield this.getMakeAssetWithFee(left);
                return { value: asset.value };
            }
            else if ((0, common_1.isETH)(right.make.assetType) && right.salt === types_1.ZERO_WORD) {
                const asset = yield this.getMakeAssetWithFee(right);
                return { value: asset.value };
            }
            else {
                return { value: 0 };
            }
        });
    }
    getMakeAssetWithFee(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (0, get_asset_with_fee_1.getAssetWithFee)(order.make, yield this.getOrderFee(order));
        });
    }
    getOrderFee(order) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            switch (order.data.dataType) {
                case "RARIBLE_V2_DATA_V1":
                case "RARIBLE_V2_DATA_V2":
                case "RARIBLE_V2_DATA_V3":
                    return (order.data.originFees.map(f => f.value).reduce((v, acc) => v + acc, 0) +
                        (yield this.getBaseFeeByData(order.data)));
                default:
                    throw new Error("Unsupported order dataType");
            }
        });
    }
    /**
     * Returns which base fee should be used when filling the order
     * If originFees are equal to zero, then protocol fee is not used, so will return 0
     * If originFees not provided we are thinking that protocol fee will be taken
     */
    getFillOrderBaseFee(_order, withOriginFees) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const v3Required = yield this.shouldUseV3Simplified(withOriginFees !== false);
            if (v3Required) {
                return this.getBaseFee("RARIBLE_V2");
            }
            return 0;
        });
    }
    getBaseFeeByData(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (data.dataType === "RARIBLE_V2_DATA_V3") {
                return this.getBaseFee("RARIBLE_V2");
            }
            return 0;
        });
    }
}
exports.RaribleV2OrderHandler = RaribleV2OrderHandler;
