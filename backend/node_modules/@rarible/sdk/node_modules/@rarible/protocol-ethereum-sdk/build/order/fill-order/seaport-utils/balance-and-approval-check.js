"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateStandardFulfillBalancesAndApprovals = exports.validateBasicFulfillBalancesAndApprovals = exports.validateOfferBalancesAndApprovals = exports.getInsufficientBalanceAndApprovalAmounts = exports.getBalancesAndApprovals = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const build_1 = require("@rarible/logger/build");
const erc721_1 = require("../../contracts/erc721");
const erc20_1 = require("../../contracts/erc20");
const item_1 = require("./item");
const criteria_1 = require("./criteria");
const item_2 = require("./item");
const balance_1 = require("./balance");
const constants_1 = require("./constants");
const getBalancesAndApprovals = (_a) => tslib_1.__awaiter(void 0, [_a], void 0, function* ({ ethereum, owner, items, criterias, operator, }) {
    const itemToCriteria = (0, criteria_1.getItemToCriteriaMap)(items, criterias);
    return Promise.all(items.map((item) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        var _b, _c;
        let approvedAmountPromise = (0, utils_1.toBn)(0);
        if ((0, item_2.isErc721Item)(item.itemType) || (0, item_2.isErc1155Item)(item.itemType)) {
            const erc721 = (0, erc721_1.createErc721Contract)(ethereum, (0, types_1.toEVMAddress)(item.token));
            const allowance = yield erc721.functionCall("isApprovedForAll", owner, operator).call();
            approvedAmountPromise = allowance ? (0, utils_1.toBn)(constants_1.MAX_INT) : (0, utils_1.toBn)(0);
        }
        else if ((0, item_2.isErc20Item)(item.itemType)) {
            const erc20 = (0, erc20_1.createErc20Contract)(ethereum, (0, types_1.toEVMAddress)(item.token));
            approvedAmountPromise = (0, utils_1.toBn)(yield erc20.functionCall("allowance", owner, operator).call());
        }
        else {
            approvedAmountPromise = (0, utils_1.toBn)(constants_1.MAX_INT);
        }
        return {
            token: item.token,
            identifierOrCriteria: (_c = (_b = itemToCriteria.get(item)) === null || _b === void 0 ? void 0 : _b.identifier) !== null && _c !== void 0 ? _c : item.identifierOrCriteria,
            balance: yield (0, balance_1.balanceOf)(ethereum, owner, item, itemToCriteria.get(item)),
            approvedAmount: approvedAmountPromise,
            itemType: item.itemType,
        };
    })));
});
exports.getBalancesAndApprovals = getBalancesAndApprovals;
const getInsufficientBalanceAndApprovalAmounts = ({ balancesAndApprovals, tokenAndIdentifierAmounts, operator, }) => {
    const tokenAndIdentifierAndAmountNeeded = [
        ...Object.entries(tokenAndIdentifierAmounts).map(([token, identifierToAmount]) => Object.entries(identifierToAmount).map(([identifierOrCriteria, amountNeeded]) => [token, identifierOrCriteria, amountNeeded])),
    ].flat();
    const filterBalancesOrApprovals = (filterKey) => tokenAndIdentifierAndAmountNeeded
        .filter(([token, identifierOrCriteria, amountNeeded]) => findBalanceAndApproval(balancesAndApprovals, token, identifierOrCriteria)[filterKey].lt(amountNeeded))
        .map(([token, identifierOrCriteria, amount]) => {
        const balanceAndApproval = findBalanceAndApproval(balancesAndApprovals, token, identifierOrCriteria);
        return {
            token,
            identifierOrCriteria,
            requiredAmount: amount,
            amountHave: balanceAndApproval[filterKey],
            itemType: balanceAndApproval.itemType,
        };
    });
    const mapToApproval = (insufficientBalance) => ({
        token: insufficientBalance.token,
        identifierOrCriteria: insufficientBalance.identifierOrCriteria,
        approvedAmount: insufficientBalance.amountHave,
        requiredApprovedAmount: insufficientBalance.requiredAmount,
        itemType: insufficientBalance.itemType,
        operator,
    });
    const [insufficientBalances, insufficientApprovals] = [
        filterBalancesOrApprovals("balance"),
        filterBalancesOrApprovals("approvedAmount").map(mapToApproval),
    ];
    return {
        insufficientBalances,
        insufficientApprovals,
    };
};
exports.getInsufficientBalanceAndApprovalAmounts = getInsufficientBalanceAndApprovalAmounts;
/**
 * 1. The offerer should have sufficient balance of all offered items.
 * 2. If the order does not indicate proxy utilization, the offerer should have sufficient approvals set
 *    for the Seaport contract for all offered ERC20, ERC721, and ERC1155 items.
 * 3. If the order does indicate proxy utilization, the offerer should have sufficient approvals set
 *    for their respective proxy contract for all offered ERC20, ERC721, and ERC1155 items.
 */
const validateOfferBalancesAndApprovals = ({ offer, criterias, balancesAndApprovals, timeBasedItemParams, throwOnInsufficientBalances = true, throwOnInsufficientApprovals, operator, }) => {
    const { insufficientBalances, insufficientApprovals } = (0, exports.getInsufficientBalanceAndApprovalAmounts)({
        balancesAndApprovals,
        tokenAndIdentifierAmounts: (0, item_1.getSummedTokenAndIdentifierAmounts)({
            items: offer,
            criterias,
            timeBasedItemParams: timeBasedItemParams ? Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: false }) : undefined,
        }),
        operator,
    });
    if (throwOnInsufficientBalances && insufficientBalances.length > 0) {
        throw new Error("The offerer does not have the amount needed to create or fulfill.");
    }
    if (throwOnInsufficientApprovals && insufficientApprovals.length > 0) {
        throw new Error("The offerer does not have the sufficient approvals.");
    }
    return insufficientApprovals;
};
exports.validateOfferBalancesAndApprovals = validateOfferBalancesAndApprovals;
const validateBasicFulfillBalancesAndApprovals = ({ offer, consideration, offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, disableCheckingBalances, }) => {
    (0, exports.validateOfferBalancesAndApprovals)({
        offer,
        criterias: [],
        balancesAndApprovals: offererBalancesAndApprovals,
        timeBasedItemParams,
        throwOnInsufficientApprovals: true,
        operator: offererOperator,
    });
    const considerationWithoutOfferItemType = consideration.filter(item => item.itemType !== offer[0].itemType);
    const { insufficientBalances, insufficientApprovals } = (0, exports.getInsufficientBalanceAndApprovalAmounts)({
        balancesAndApprovals: fulfillerBalancesAndApprovals,
        tokenAndIdentifierAmounts: (0, item_1.getSummedTokenAndIdentifierAmounts)({
            items: considerationWithoutOfferItemType,
            criterias: [],
            timeBasedItemParams: Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: true }),
        }),
        operator: fulfillerOperator,
    });
    if (!disableCheckingBalances && insufficientBalances.length > 0) {
        throw new Error("The fulfiller does not have the balances needed to fulfill.");
    }
    return insufficientApprovals;
};
exports.validateBasicFulfillBalancesAndApprovals = validateBasicFulfillBalancesAndApprovals;
const validateStandardFulfillBalancesAndApprovals = ({ offer, consideration, offerCriteria, considerationCriteria, offererBalancesAndApprovals, fulfillerBalancesAndApprovals, timeBasedItemParams, offererOperator, fulfillerOperator, disableCheckingBalances, }) => {
    (0, exports.validateOfferBalancesAndApprovals)({
        offer,
        criterias: offerCriteria,
        balancesAndApprovals: offererBalancesAndApprovals,
        timeBasedItemParams,
        throwOnInsufficientApprovals: true,
        operator: offererOperator,
    });
    const fulfillerBalancesAndApprovalsAfterReceivingOfferedItems = addToExistingBalances({
        items: offer,
        criterias: offerCriteria,
        balancesAndApprovals: fulfillerBalancesAndApprovals,
        timeBasedItemParams,
    });
    const { insufficientBalances, insufficientApprovals } = (0, exports.getInsufficientBalanceAndApprovalAmounts)({
        balancesAndApprovals: fulfillerBalancesAndApprovalsAfterReceivingOfferedItems,
        tokenAndIdentifierAmounts: (0, item_1.getSummedTokenAndIdentifierAmounts)({
            items: consideration,
            criterias: considerationCriteria,
            timeBasedItemParams: Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: true }),
        }),
        operator: fulfillerOperator,
    });
    if (!disableCheckingBalances && insufficientBalances.length > 0) {
        throw new Error("The fulfiller does not have the balances needed to fulfill.");
    }
    return insufficientApprovals;
};
exports.validateStandardFulfillBalancesAndApprovals = validateStandardFulfillBalancesAndApprovals;
const addToExistingBalances = ({ items, criterias, timeBasedItemParams, balancesAndApprovals, }) => {
    const summedItemAmounts = (0, item_1.getSummedTokenAndIdentifierAmounts)({
        items,
        criterias,
        timeBasedItemParams: Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: false }),
    });
    // Deep clone existing balances
    const balancesAndApprovalsAfterReceivingItems = balancesAndApprovals.map(item => (Object.assign({}, item)));
    // Add each summed item amount to the existing balances as we may want tocheck balances after receiving all items
    Object.entries(summedItemAmounts).forEach(([token, identifierOrCriteriaToAmount]) => Object.entries(identifierOrCriteriaToAmount).forEach(([identifierOrCriteria, amount]) => {
        const balanceAndApproval = findBalanceAndApproval(balancesAndApprovalsAfterReceivingItems, token, identifierOrCriteria);
        const balanceAndApprovalIndex = balancesAndApprovalsAfterReceivingItems.indexOf(balanceAndApproval);
        balancesAndApprovalsAfterReceivingItems[balanceAndApprovalIndex].balance =
            balancesAndApprovalsAfterReceivingItems[balanceAndApprovalIndex].balance.plus(amount);
    }));
    return balancesAndApprovalsAfterReceivingItems;
};
function findBalanceAndApproval(balancesAndApprovals, token, identifierOrCriteria) {
    const balanceAndApproval = balancesAndApprovals.find(({ token: checkedToken, identifierOrCriteria: checkedIdentifierOrCriteria }) => token.toLowerCase() === checkedToken.toLowerCase() &&
        checkedIdentifierOrCriteria.toLowerCase() === identifierOrCriteria.toLowerCase());
    if (!balanceAndApproval) {
        throw new build_1.Warning("Balances and approvals didn't contain all tokens and identifiers");
    }
    return balanceAndApproval;
}
