"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signOrder = exports.getOrderTypeFromOrderOptions = exports.createOrder = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const seaport_v14_1 = require("../../contracts/seaport-v14");
const eip712_lazy_1 = require("../../../nft/eip712-lazy");
const to_vrs_1 = require("../../../common/to-vrs");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const order_1 = require("./order");
const item_1 = require("./item");
const balance_and_approval_check_1 = require("./balance-and-approval-check");
const approval_1 = require("./approval");
function createOrder(ethereum_1, _a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, { send, conduitKey = constants_1.OPENSEA_CONDUIT_KEY, zone = types_1.EVM_ZERO_ADDRESS, startTime = Math.floor(Date.now() / 1000).toString(), endTime = constants_2.MAX_INT.toString(), offer, consideration, counter, allowPartialFills, restrictedByZone, fees, salt = (0, types_1.randomWord)(), }) {
        var _b;
        const offerer = yield ethereum.getFrom();
        const offerItems = offer.map(order_1.mapInputItemToOfferItem);
        const considerationItems = [
            ...consideration.map(consideration => {
                var _a;
                return (Object.assign(Object.assign({}, (0, order_1.mapInputItemToOfferItem)(consideration)), { recipient: (_a = consideration.recipient) !== null && _a !== void 0 ? _a : offerer }));
            }),
        ];
        if (!(0, order_1.areAllCurrenciesSame)({
            offer: offerItems,
            consideration: considerationItems,
        })) {
            throw new Error("All currency tokens in the order must be the same token");
        }
        const currencies = [...offerItems, ...considerationItems].filter(item_1.isCurrencyItem);
        const totalCurrencyAmount = (0, order_1.totalItemsAmount)(currencies);
        const operator = constants_1.KNOWN_CONDUIT_KEYS_TO_CONDUIT[conduitKey];
        const seaportContract = (0, seaport_v14_1.createSeaportV14Contract)(ethereum, (0, types_1.toEVMAddress)(constants_1.CROSS_CHAIN_SEAPORT_V1_5_ADDRESS));
        const [resolvedCounter, balancesAndApprovals] = yield Promise.all([
            counter !== null && counter !== void 0 ? counter : seaportContract.functionCall("getCounter", offerer).call(),
            (0, balance_and_approval_check_1.getBalancesAndApprovals)({
                ethereum,
                owner: offerer,
                items: offerItems,
                criterias: [],
                operator,
            }),
        ]);
        const orderType = getOrderTypeFromOrderOptions({
            allowPartialFills,
            restrictedByZone,
        });
        const considerationItemsWithFees = [
            ...(0, order_1.deductFees)(considerationItems, fees),
            ...(currencies.length
                ? (_b = fees === null || fees === void 0 ? void 0 : fees.map(fee => (0, order_1.feeToConsiderationItem)({
                    fee,
                    token: currencies[0].token,
                    baseAmount: totalCurrencyAmount.startAmount,
                    baseEndAmount: totalCurrencyAmount.endAmount,
                }))) !== null && _b !== void 0 ? _b : []
                : []),
        ];
        const orderParameters = {
            offerer,
            zone,
            zoneHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
            // zoneHash: formatBytes32String(resolvedCounter.toString()),
            startTime,
            endTime,
            orderType,
            offer: offerItems,
            consideration: considerationItemsWithFees,
            totalOriginalConsiderationItems: considerationItemsWithFees.length,
            salt,
            conduitKey,
            counter: (counter !== null && counter !== void 0 ? counter : seaportContract.functionCall("getCounter", offerer).call()).toString(),
        };
        const checkBalancesAndApprovals = true;
        const insufficientApprovals = checkBalancesAndApprovals
            ? (0, balance_and_approval_check_1.validateOfferBalancesAndApprovals)({
                offer: offerItems,
                criterias: [],
                balancesAndApprovals,
                throwOnInsufficientBalances: checkBalancesAndApprovals,
                operator,
            })
            : [];
        const approvalActions = checkBalancesAndApprovals
            ? yield (0, approval_1.getApprovalActions)(ethereum, send, insufficientApprovals)
            : [];
        yield Promise.all(approvalActions);
        const signature = yield signOrder(ethereum, orderParameters, resolvedCounter);
        return {
            parameters: Object.assign(Object.assign({}, orderParameters), { counter: resolvedCounter }),
            signature,
        };
    });
}
exports.createOrder = createOrder;
function getOrderTypeFromOrderOptions({ allowPartialFills, restrictedByZone, }) {
    if (allowPartialFills) {
        return restrictedByZone ? constants_2.OrderType.PARTIAL_RESTRICTED : constants_2.OrderType.PARTIAL_OPEN;
    }
    return restrictedByZone ? constants_2.OrderType.FULL_RESTRICTED : constants_2.OrderType.FULL_OPEN;
}
exports.getOrderTypeFromOrderOptions = getOrderTypeFromOrderOptions;
function signOrder(ethereum, orderParameters, counter) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const orderComponents = Object.assign(Object.assign({}, orderParameters), { counter });
        const chainId = yield ethereum.getChainId();
        const domainData = {
            name: constants_2.SEAPORT_CONTRACT_NAME,
            version: constants_2.SEAPORT_CONTRACT_VERSION,
            chainId,
            verifyingContract: constants_1.CROSS_CHAIN_SEAPORT_V1_5_ADDRESS,
        };
        const signatureNew = yield ethereum.signTypedData({
            primaryType: "OrderComponents",
            domain: domainData,
            types: Object.assign(Object.assign({}, constants_1.EIP_712_ORDER_TYPE), { EIP712Domain: eip712_lazy_1.NFT_DOMAIN_TYPE }),
            message: Object.assign(Object.assign({}, orderComponents), { maker: yield ethereum.getFrom() }),
        });
        return (0, to_vrs_1.toVrs)(signatureNew).compact;
    });
}
exports.signOrder = signOrder;
