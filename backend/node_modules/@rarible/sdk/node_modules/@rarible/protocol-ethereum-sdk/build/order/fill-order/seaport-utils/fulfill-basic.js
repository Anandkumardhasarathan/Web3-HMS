"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getfulfillBasicOrderData = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const item_1 = require("./item");
const constants_1 = require("./constants");
function getfulfillBasicOrderData(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ order, timeBasedItemParams, tips = [], conduitKey = constants_1.NO_CONDUIT, seaportContract, }) {
        var _b, _c;
        const { offer, consideration } = order.parameters;
        const considerationIncludingTips = [...consideration, ...tips];
        const offerItem = offer[0];
        const [forOfferer, ...forAdditionalRecipients] = considerationIncludingTips;
        const basicOrderRouteType = (_b = offerAndConsiderationFulfillmentMapping[offerItem.itemType]) === null || _b === void 0 ? void 0 : _b[forOfferer.itemType];
        if (basicOrderRouteType === undefined) {
            throw new Error("Order parameters did not result in a valid basic fulfillment");
        }
        const additionalRecipients = forAdditionalRecipients.map(({ startAmount, recipient }) => ({
            amount: startAmount,
            recipient,
        }));
        const considerationWithoutOfferItemType = considerationIncludingTips.filter(item => item.itemType !== offer[0].itemType);
        const totalNativeAmount = (_c = (0, item_1.getSummedTokenAndIdentifierAmounts)({
            items: considerationWithoutOfferItemType,
            criterias: [],
            timeBasedItemParams: Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: true }),
        })[types_1.EVM_ZERO_ADDRESS]) === null || _c === void 0 ? void 0 : _c["0"];
        const basicOrderParameters = {
            offerer: order.parameters.offerer,
            offererConduitKey: order.parameters.conduitKey,
            zone: order.parameters.zone,
            basicOrderType: order.parameters.orderType + 4 * basicOrderRouteType,
            offerToken: offerItem.token,
            offerIdentifier: offerItem.identifierOrCriteria,
            offerAmount: offerItem.endAmount,
            considerationToken: forOfferer.token,
            considerationIdentifier: forOfferer.identifierOrCriteria,
            considerationAmount: forOfferer.endAmount,
            startTime: order.parameters.startTime,
            endTime: order.parameters.endTime,
            salt: order.parameters.salt,
            totalOriginalAdditionalRecipients: order.parameters.consideration.length - 1,
            signature: order.signature,
            fulfillerConduitKey: conduitKey,
            additionalRecipients,
            zoneHash: order.parameters.zoneHash,
        };
        // const seaportContract = createSeaportV14Contract(ethereum, toAddress(CROSS_CHAIN_SEAPORT_V1_4_ADDRESS))
        const functionCall = seaportContract.functionCall("fulfillBasicOrder", basicOrderParameters);
        return {
            functionCall,
            options: { value: totalNativeAmount === null || totalNativeAmount === void 0 ? void 0 : totalNativeAmount.toString() },
        };
    });
}
exports.getfulfillBasicOrderData = getfulfillBasicOrderData;
const offerAndConsiderationFulfillmentMapping = {
    [constants_1.ItemType.ERC20]: {
        [constants_1.ItemType.ERC721]: constants_1.BasicOrderRouteType.ERC721_TO_ERC20,
        [constants_1.ItemType.ERC1155]: constants_1.BasicOrderRouteType.ERC1155_TO_ERC20,
    },
    [constants_1.ItemType.ERC721]: {
        [constants_1.ItemType.NATIVE]: constants_1.BasicOrderRouteType.ETH_TO_ERC721,
        [constants_1.ItemType.ERC20]: constants_1.BasicOrderRouteType.ERC20_TO_ERC721,
    },
    [constants_1.ItemType.ERC1155]: {
        [constants_1.ItemType.NATIVE]: constants_1.BasicOrderRouteType.ETH_TO_ERC1155,
        [constants_1.ItemType.ERC20]: constants_1.BasicOrderRouteType.ERC20_TO_ERC1155,
    },
};
