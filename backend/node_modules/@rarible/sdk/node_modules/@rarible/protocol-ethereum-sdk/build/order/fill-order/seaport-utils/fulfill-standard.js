"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFulfillStandardOrderData = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const sign_typed_data_1 = require("@rarible/ethereum-provider/build/sign-typed-data");
const fulfill_1 = require("./fulfill");
const criteria_1 = require("./criteria");
const item_1 = require("./item");
const order_1 = require("./order");
const map_tips_1 = require("./map-tips");
function getFulfillStandardOrderData(_a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ order, unitsToFill = 0, totalSize, totalFilled, offerCriteria, considerationCriteria, tips = [], extraData, timeBasedItemParams, conduitKey, recipientAddress, seaportContract, }) {
        var _b;
        // If we are supplying units to fill, we adjust the order by the minimum of the amount to fill and
        // the remaining order left to be fulfilled
        const orderWithAdjustedFills = unitsToFill
            ? (0, order_1.mapOrderAmountsFromUnitsToFill)(order, {
                unitsToFill,
                totalSize,
            })
            : // Else, we adjust the order by the remaining order left to be fulfilled
                (0, order_1.mapOrderAmountsFromFilledStatus)(order, {
                    totalFilled,
                    totalSize,
                });
        const { parameters: { offer, consideration }, } = orderWithAdjustedFills;
        let adjustedTips = [];
        if (tips.length > 0) {
            adjustedTips = (0, map_tips_1.mapTipAmountsFromUnitsToFill)(tips, unitsToFill, totalSize);
            console.log("mapTipAmountsFromUnitsToFill", adjustedTips);
        }
        const considerationIncludingTips = [...consideration, ...adjustedTips];
        const offerCriteriaItems = offer.filter(({ itemType }) => (0, item_1.isCriteriaItem)(itemType));
        const considerationCriteriaItems = considerationIncludingTips.filter(({ itemType }) => (0, item_1.isCriteriaItem)(itemType));
        const hasCriteriaItems = offerCriteriaItems.length > 0 || considerationCriteriaItems.length > 0;
        if (offerCriteriaItems.length !== offerCriteria.length ||
            considerationCriteriaItems.length !== considerationCriteria.length) {
            throw new Error("You must supply the appropriate criterias for criteria based items");
        }
        const totalNativeAmount = (_b = (0, item_1.getSummedTokenAndIdentifierAmounts)({
            items: considerationIncludingTips,
            criterias: considerationCriteria,
            timeBasedItemParams: Object.assign(Object.assign({}, timeBasedItemParams), { isConsiderationItem: true }),
        })[types_1.EVM_ZERO_ADDRESS]) === null || _b === void 0 ? void 0 : _b["0"];
        const isGift = recipientAddress !== types_1.EVM_ZERO_ADDRESS;
        const useAdvanced = Boolean(unitsToFill) || hasCriteriaItems || isGift;
        const orderAccountingForTips = Object.assign(Object.assign({}, order), { parameters: Object.assign(Object.assign({}, order.parameters), { consideration: [...order.parameters.consideration, ...tips], totalOriginalConsiderationItems: consideration.length }) });
        const { numerator, denominator } = (0, fulfill_1.getAdvancedOrderNumeratorDenominator)(order, unitsToFill);
        if (useAdvanced) {
            let functionCall = yield seaportContract.functionCall("fulfillAdvancedOrder", Object.assign(Object.assign({}, orderAccountingForTips), { numerator,
                denominator, extraData: extraData !== null && extraData !== void 0 ? extraData : "0x" }), hasCriteriaItems
                ? (0, criteria_1.generateCriteriaResolvers)({
                    orders: [order],
                    offerCriterias: [offerCriteria],
                    considerationCriterias: [considerationCriteria],
                })
                : [], conduitKey, recipientAddress);
            try {
                yield functionCall.estimateGas({ value: (totalNativeAmount === null || totalNativeAmount === void 0 ? void 0 : totalNativeAmount.toFixed()) || "0" });
            }
            catch (e) {
                if ((0, sign_typed_data_1.hasMessage)(e) && e.message.includes("0xc63cf089")) {
                    const orderAccountingForTips = Object.assign(Object.assign({}, order), { parameters: Object.assign(Object.assign({}, order.parameters), { consideration: [...order.parameters.consideration], totalOriginalConsiderationItems: consideration.length }) });
                    functionCall = yield seaportContract.functionCall("fulfillAdvancedOrder", Object.assign(Object.assign({}, orderAccountingForTips), { numerator,
                        denominator, extraData: extraData !== null && extraData !== void 0 ? extraData : "0x" }), hasCriteriaItems
                        ? (0, criteria_1.generateCriteriaResolvers)({
                            orders: [order],
                            offerCriterias: [offerCriteria],
                            considerationCriterias: [considerationCriteria],
                        })
                        : [], conduitKey, recipientAddress);
                }
            }
            return {
                functionCall,
                options: { value: (totalNativeAmount === null || totalNativeAmount === void 0 ? void 0 : totalNativeAmount.toFixed()) || "0" },
            };
        }
        const functionCall = yield seaportContract.functionCall("fulfillOrder", orderAccountingForTips, conduitKey);
        return {
            functionCall,
            options: { value: (totalNativeAmount === null || totalNativeAmount === void 0 ? void 0 : totalNativeAmount.toFixed()) || "0" },
        };
    });
}
exports.getFulfillStandardOrderData = getFulfillStandardOrderData;
