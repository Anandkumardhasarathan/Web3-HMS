"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAdvancedOrderNumeratorDenominator = exports.generateFulfillOrdersFulfillments = exports.validateAndSanitizeFromOrderStatus = exports.shouldUseBasicFulfill = void 0;
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const constants_1 = require("./constants");
const criteria_1 = require("./criteria");
const item_1 = require("./item");
const order_1 = require("./order");
const gcd_1 = require("./gcd");
/**
 * We should use basic fulfill order if the order adheres to the following criteria:
 * 1. The order should not be partially filled.
 * 2. The order only contains a single offer item and contains at least one consideration item
 * 3. The order does not offer an item with Ether (or other native tokens) as its item type.
 * 4. The order only contains a single ERC721 or ERC1155 item and that item is not criteria-based
 * 5. All other items have the same Native or ERC20 item type and token
 * 6. All items have the same startAmount and endAmount
 * 7. First consideration item must contain the offerer as the recipient
 * 8. If the order has multiple consideration items and all consideration items other than the
 *    first consideration item have the same item type as the offered item, the offered item
 *    amount is not less than the sum of all consideration item amounts excluding the
 *    first consideration item amount
 * 9. The token on native currency items needs to be set to the null address and the identifier on
 *    currencies needs to be zero, and the amounts on the 721 item need to be 1
 */
const shouldUseBasicFulfill = ({ offer, consideration, offerer }, totalFilled) => {
    // 1. The order must not be partially filled
    if (!(0, utils_1.toBn)(totalFilled).eq(0)) {
        return false;
    }
    // 2. Must be single offer and at least one consideration
    if (offer.length > 1 || consideration.length === 0) {
        return false;
    }
    const allItems = [...offer, ...consideration];
    const nfts = allItems.filter(({ itemType }) => [constants_1.ItemType.ERC721, constants_1.ItemType.ERC1155].includes(itemType));
    const nftsWithCriteria = allItems.filter(({ itemType }) => (0, item_1.isCriteriaItem)(itemType));
    const offersNativeCurrency = (0, item_1.isNativeCurrencyItem)(offer[0]);
    // 3. The order does not offer an item with Ether (or other native tokens) as its item type.
    if (offersNativeCurrency) {
        return false;
    }
    // 4. The order only contains a single ERC721 or ERC1155 item and that item is not criteria-based
    if (nfts.length !== 1 || nftsWithCriteria.length !== 0) {
        return false;
    }
    // 5. All currencies need to have the same address and item type (Native, ERC20)
    if (!(0, order_1.areAllCurrenciesSame)({ offer, consideration })) {
        return false;
    }
    // 6. All individual items need to have the same startAmount and endAmount
    const differentStartAndEndAmount = allItems.some(({ startAmount, endAmount }) => startAmount !== endAmount);
    if (differentStartAndEndAmount) {
        return false;
    }
    const [firstConsideration, ...restConsideration] = consideration;
    // 7. First consideration item must contain the offerer as the recipient
    const firstConsiderationRecipientIsNotOfferer = firstConsideration.recipient.toLowerCase() !== offerer.toLowerCase();
    if (firstConsiderationRecipientIsNotOfferer) {
        return false;
    }
    // 8. If the order has multiple consideration items and all consideration items other than the
    // first consideration item have the same item type as the offered item, the offered item
    // amount is not less than the sum of all consideration item amounts excluding the
    // first consideration item amount
    if (consideration.length > 1 &&
        restConsideration.every(item => item.itemType === offer[0].itemType) &&
        (0, order_1.totalItemsAmount)(restConsideration).endAmount.gt(offer[0].endAmount)) {
        return false;
    }
    const currencies = allItems.filter(item_1.isCurrencyItem);
    //  9. The token on native currency items needs to be set to the null address and the identifier on
    //  currencies needs to be zero, and the amounts on the 721 item need to be 1
    const nativeCurrencyIsZeroAddress = currencies
        .filter(({ itemType }) => itemType === constants_1.ItemType.NATIVE)
        .every(({ token }) => token === types_1.EVM_ZERO_ADDRESS);
    const currencyIdentifiersAreZero = currencies.every(({ identifierOrCriteria }) => (0, utils_1.toBn)(identifierOrCriteria).eq(0));
    const erc721sAreSingleAmount = nfts
        .filter(({ itemType }) => itemType === constants_1.ItemType.ERC721)
        .every(({ endAmount }) => endAmount === "1");
    return nativeCurrencyIsZeroAddress && currencyIdentifiersAreZero && erc721sAreSingleAmount;
};
exports.shouldUseBasicFulfill = shouldUseBasicFulfill;
function validateAndSanitizeFromOrderStatus(order, orderStatus) {
    const { isValidated, isCancelled, totalFilled, totalSize } = orderStatus;
    if ((0, utils_1.toBn)(totalSize).gt(0) && (0, utils_1.toBn)(totalFilled).div(totalSize).eq(1)) {
        throw new Error("The order you are trying to fulfill is already filled");
    }
    if (isCancelled) {
        throw new Error("The order you are trying to fulfill is cancelled");
    }
    if (isValidated) {
        // If the order is already validated, manually wipe the signature off of the order to save gas
        return { parameters: Object.assign({}, order.parameters), signature: "0x" };
    }
    return order;
}
exports.validateAndSanitizeFromOrderStatus = validateAndSanitizeFromOrderStatus;
function generateFulfillOrdersFulfillments(ordersMetadata) {
    const hashAggregateKey = ({ sourceOrDestination, operator = "", token, identifier, }) => `${sourceOrDestination}-${operator}-${token}-${identifier}`;
    const offerAggregatedFulfillments = {};
    const considerationAggregatedFulfillments = {};
    ordersMetadata.forEach(({ order, offererOperator, offerCriteria }, orderIndex) => {
        const itemToCriteria = (0, criteria_1.getItemToCriteriaMap)(order.parameters.offer, offerCriteria);
        return order.parameters.offer.forEach((item, itemIndex) => {
            var _a, _b, _c;
            const aggregateKey = `${hashAggregateKey({
                sourceOrDestination: order.parameters.offerer,
                operator: offererOperator,
                token: item.token,
                identifier: (_b = (_a = itemToCriteria.get(item)) === null || _a === void 0 ? void 0 : _a.identifier) !== null && _b !== void 0 ? _b : item.identifierOrCriteria,
                // We tack on the index to ensure that erc721s can never be aggregated and instead must be in separate arrays
            })}${(0, item_1.isErc721Item)(item.itemType) ? itemIndex : ""}`;
            offerAggregatedFulfillments[aggregateKey] = [
                ...((_c = offerAggregatedFulfillments[aggregateKey]) !== null && _c !== void 0 ? _c : []),
                { orderIndex, itemIndex },
            ];
        });
    });
    ordersMetadata.forEach(({ order, considerationCriteria, tips }, orderIndex) => {
        const itemToCriteria = (0, criteria_1.getItemToCriteriaMap)(order.parameters.consideration, considerationCriteria);
        return [...order.parameters.consideration, ...tips].forEach((item, itemIndex) => {
            var _a, _b, _c;
            const aggregateKey = `${hashAggregateKey({
                sourceOrDestination: item.recipient,
                token: item.token,
                identifier: (_b = (_a = itemToCriteria.get(item)) === null || _a === void 0 ? void 0 : _a.identifier) !== null && _b !== void 0 ? _b : item.identifierOrCriteria,
            })}${(0, item_1.isErc721Item)(item.itemType) ? itemIndex : ""}`;
            considerationAggregatedFulfillments[aggregateKey] = [
                ...((_c = considerationAggregatedFulfillments[aggregateKey]) !== null && _c !== void 0 ? _c : []),
                { orderIndex, itemIndex },
            ];
        });
    });
    return {
        offerFulfillments: Object.values(offerAggregatedFulfillments),
        considerationFulfillments: Object.values(considerationAggregatedFulfillments),
    };
}
exports.generateFulfillOrdersFulfillments = generateFulfillOrdersFulfillments;
const getAdvancedOrderNumeratorDenominator = (order, unitsToFill) => {
    // Used for advanced order cases
    const maxUnits = (0, item_1.getMaximumSizeForOrder)(order);
    const unitsToFillBn = (0, utils_1.toBn)(unitsToFill);
    // Reduce the numerator/denominator as optimization
    const unitsGcd = (0, gcd_1.gcd)(unitsToFillBn, maxUnits);
    const numerator = unitsToFill ? unitsToFillBn.div(unitsGcd) : (0, utils_1.toBn)(1);
    const denominator = unitsToFill ? maxUnits.div(unitsGcd) : (0, utils_1.toBn)(1);
    return {
        numerator: `0x${numerator.toString(16)}`,
        denominator: `0x${denominator.toString(16)}`,
    };
};
exports.getAdvancedOrderNumeratorDenominator = getAdvancedOrderNumeratorDenominator;
