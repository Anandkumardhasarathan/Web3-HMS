"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseMatchForFulfill = exports.mapOrderAmountsFromUnitsToFill = exports.mapOrderAmountsFromFilledStatus = exports.totalItemsAmount = exports.areAllCurrenciesSame = exports.mapInputItemToOfferItem = exports.deductFees = exports.feeToConsiderationItem = void 0;
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const merkletree_1 = require("./merkletree");
const item_1 = require("./item");
const constants_1 = require("./constants");
const multiplyBasisPoints = (amount, basisPoints) => (0, utils_1.toBn)(amount).multipliedBy((0, utils_1.toBn)(basisPoints)).div(constants_1.ONE_HUNDRED_PERCENT_BP);
const feeToConsiderationItem = ({ fee, token, baseAmount, baseEndAmount = baseAmount, }) => {
    return {
        itemType: token === types_1.EVM_ZERO_ADDRESS ? constants_1.ItemType.NATIVE : constants_1.ItemType.ERC20,
        token,
        identifierOrCriteria: "0",
        startAmount: multiplyBasisPoints(baseAmount, fee.basisPoints).toString(),
        endAmount: multiplyBasisPoints(baseEndAmount, fee.basisPoints).toString(),
        recipient: fee.recipient,
    };
};
exports.feeToConsiderationItem = feeToConsiderationItem;
const deductFees = (items, fees) => {
    if (!fees) {
        return items;
    }
    const totalBasisPoints = fees.reduce((accBasisPoints, fee) => accBasisPoints + fee.basisPoints, 0);
    return items.map(item => (Object.assign(Object.assign({}, item), { startAmount: (0, item_1.isCurrencyItem)(item)
            ? (0, utils_1.toBn)(item.startAmount).minus(multiplyBasisPoints(item.startAmount, totalBasisPoints)).toString()
            : item.startAmount, endAmount: (0, item_1.isCurrencyItem)(item)
            ? (0, utils_1.toBn)(item.endAmount).minus(multiplyBasisPoints(item.endAmount, totalBasisPoints)).toString()
            : item.endAmount })));
};
exports.deductFees = deductFees;
const mapInputItemToOfferItem = (item) => {
    var _a, _b, _c, _d, _e, _f, _g;
    // Item is an NFT
    if ("itemType" in item) {
        // Convert this to a criteria based item
        if ("identifiers" in item || "criteria" in item) {
            const root = "criteria" in item ? item.criteria : new merkletree_1.MerkleTree(item.identifiers).getRoot();
            return {
                itemType: item.itemType === constants_1.ItemType.ERC721 ? constants_1.ItemType.ERC721_WITH_CRITERIA : constants_1.ItemType.ERC1155_WITH_CRITERIA,
                token: item.token,
                identifierOrCriteria: root,
                startAmount: (_a = item.amount) !== null && _a !== void 0 ? _a : "1",
                endAmount: (_c = (_b = item.endAmount) !== null && _b !== void 0 ? _b : item.amount) !== null && _c !== void 0 ? _c : "1",
            };
        }
        if ("amount" in item || "endAmount" in item) {
            return {
                itemType: item.itemType,
                token: item.token,
                identifierOrCriteria: item.identifier,
                // @ts-ignore
                startAmount: item.amount,
                // @ts-ignore
                endAmount: (_e = (_d = item.endAmount) !== null && _d !== void 0 ? _d : item.amount) !== null && _e !== void 0 ? _e : "1",
            };
        }
        return {
            itemType: item.itemType,
            token: item.token,
            identifierOrCriteria: item.identifier,
            startAmount: "1",
            endAmount: "1",
        };
    }
    // Item is a currency
    return {
        itemType: item.token && item.token !== types_1.EVM_ZERO_ADDRESS ? constants_1.ItemType.ERC20 : constants_1.ItemType.NATIVE,
        token: (_f = item.token) !== null && _f !== void 0 ? _f : types_1.EVM_ZERO_ADDRESS,
        identifierOrCriteria: "0",
        startAmount: item.amount,
        endAmount: (_g = item.endAmount) !== null && _g !== void 0 ? _g : item.amount,
    };
};
exports.mapInputItemToOfferItem = mapInputItemToOfferItem;
const areAllCurrenciesSame = ({ offer, consideration }) => {
    const allItems = [...offer, ...consideration];
    const currencies = allItems.filter(item_1.isCurrencyItem);
    return currencies.every(({ itemType, token }) => itemType === currencies[0].itemType && token.toLowerCase() === currencies[0].token.toLowerCase());
};
exports.areAllCurrenciesSame = areAllCurrenciesSame;
const totalItemsAmount = (items) => {
    const initialValues = {
        startAmount: (0, utils_1.toBn)(0),
        endAmount: (0, utils_1.toBn)(0),
    };
    return items
        .map(({ startAmount, endAmount }) => ({
        startAmount,
        endAmount,
    }))
        .reduce(({ startAmount: totalStartAmount, endAmount: totalEndAmount }, { startAmount, endAmount }) => ({
        startAmount: totalStartAmount.plus(startAmount),
        endAmount: totalEndAmount.plus(endAmount),
    }), {
        startAmount: (0, utils_1.toBn)(0),
        endAmount: (0, utils_1.toBn)(0),
    });
};
exports.totalItemsAmount = totalItemsAmount;
/**
 * Maps order offer and consideration item amounts based on the order's filled status
 * After applying the fraction, we can view this order as the "canonical" order for which we
 * check approvals and balances
 */
const mapOrderAmountsFromFilledStatus = (order, { totalFilled, totalSize }) => {
    if ((0, utils_1.toBn)(totalFilled).eq(0) || (0, utils_1.toBn)(totalSize).eq(0)) {
        return order;
    }
    // i.e if totalFilled is 3 and totalSize is 4, there are 1 / 4 order amounts left to fill.
    const basisPoints = (0, utils_1.toBn)(totalSize).minus(totalFilled).multipliedBy(constants_1.ONE_HUNDRED_PERCENT_BP).div(totalSize);
    return {
        parameters: Object.assign(Object.assign({}, order.parameters), { offer: order.parameters.offer.map(item => (Object.assign(Object.assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() }))), consideration: order.parameters.consideration.map(item => (Object.assign(Object.assign({}, item), { startAmount: multiplyBasisPoints(item.startAmount, basisPoints).toString(), endAmount: multiplyBasisPoints(item.endAmount, basisPoints).toString() }))) }),
        signature: order.signature,
    };
};
exports.mapOrderAmountsFromFilledStatus = mapOrderAmountsFromFilledStatus;
const multiplyDivision = (amount, numerator, denominator) => (0, utils_1.toBn)(amount).multipliedBy(numerator).div(denominator);
/**
 * Maps order offer and consideration item amounts based on the units needed to fulfill
 * After applying the fraction, we can view this order as the "canonical" order for which we
 * check approvals and balances
 * Returns the numerator and denominator as well, converting this to an AdvancedOrder
 */
const mapOrderAmountsFromUnitsToFill = (order, { unitsToFill, totalSize }) => {
    const unitsToFillBn = (0, utils_1.toBn)(unitsToFill);
    if (unitsToFillBn.lte(0)) {
        throw new Error("Units to fill must be greater than 1");
    }
    const maxUnits = (0, item_1.getMaximumSizeForOrder)(order);
    if ((0, utils_1.toBn)(totalSize).eq(0)) {
        totalSize = maxUnits;
    }
    return {
        parameters: Object.assign(Object.assign({}, order.parameters), { offer: order.parameters.offer.map(item => (Object.assign(Object.assign({}, item), { startAmount: multiplyDivision(item.startAmount, unitsToFillBn, totalSize).toString(), endAmount: multiplyDivision(item.endAmount, unitsToFillBn, totalSize).toString() }))), consideration: order.parameters.consideration.map(item => (Object.assign(Object.assign({}, item), { startAmount: multiplyDivision(item.startAmount, unitsToFillBn, totalSize).toString(), endAmount: multiplyDivision(item.endAmount, unitsToFillBn, totalSize).toString() }))) }),
        signature: order.signature,
    };
};
exports.mapOrderAmountsFromUnitsToFill = mapOrderAmountsFromUnitsToFill;
const shouldUseMatchForFulfill = () => true;
exports.shouldUseMatchForFulfill = shouldUseMatchForFulfill;
