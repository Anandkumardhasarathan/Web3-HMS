"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMarketIdByOpenseaContract = exports.prepareSeaportExchangeData = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@rarible/utils");
const types_1 = require("@rarible/types");
const types_2 = require("@rarible/types");
const types_3 = require("../types");
const origin_fees_utils_1 = require("../common/origin-fees-utils");
const compare_case_insensitive_1 = require("../../../common/compare-case-insensitive");
const common_1 = require("../../../nft/common");
const constants_1 = require("./constants");
const convert_to_seaport_order_1 = require("./convert-to-seaport-order");
const balance_and_approval_check_1 = require("./balance-and-approval-check");
const get_order_hash_1 = require("./get-order-hash");
const fulfill_1 = require("./fulfill");
const fulfill_advance_wrapper_1 = require("./fulfill-advance-wrapper");
const seaport_utils_1 = require("./seaport-utils");
function prepareSeaportExchangeData(ethereum_1, send_1, simpleOrder_1, _a) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (ethereum, send, simpleOrder, 
    // seaportContract: EthereumContract,
    { unitsToFill, encodedFeesValue, totalFeeBasisPoints, disableCheckingBalances, }) {
        const seaportContract = (0, seaport_utils_1.getSeaportContract)(ethereum, (0, types_1.toEVMAddress)(simpleOrder.data.protocol));
        const order = (0, convert_to_seaport_order_1.convertAPIOrderToSeaport)(simpleOrder);
        const fulfillerAddress = yield ethereum.getFrom();
        const { parameters: orderParameters } = order;
        const { offerer, offer, consideration } = orderParameters;
        // const conduitKey = OPENSEA_CONDUIT_KEY
        const conduitKey = constants_1.NO_CONDUIT;
        const offererOperator = (0, constants_1.getConduitByKey)(orderParameters.conduitKey, simpleOrder.data.protocol);
        // const offererOperator = wrapperAddress
        const fulfillerOperator = (0, constants_1.getConduitByKey)(conduitKey, simpleOrder.data.protocol);
        // const fulfillerOperator = wrapperAddress
        const extraData = "0x";
        const recipientAddress = fulfillerAddress;
        const offerCriteria = [];
        const considerationCriteria = [];
        const [offererBalancesAndApprovals, fulfillerBalancesAndApprovals, orderStatusRaw] = yield Promise.all([
            //check item owner balances
            (0, balance_and_approval_check_1.getBalancesAndApprovals)({
                ethereum,
                owner: offerer,
                items: offer,
                criterias: offerCriteria,
                operator: offererOperator,
            }),
            //check buyer balances
            (0, balance_and_approval_check_1.getBalancesAndApprovals)({
                ethereum,
                owner: fulfillerAddress,
                items: [...offer, ...consideration],
                criterias: [...offerCriteria, ...considerationCriteria],
                operator: fulfillerOperator,
                // operator: wrapperAddress,
            }),
            seaportContract.functionCall("getOrderStatus", (0, get_order_hash_1.getOrderHash)(orderParameters)).call(),
        ]);
        const orderStatus = {
            totalFilled: (0, utils_1.toBn)(orderStatusRaw.totalFilled),
            totalSize: (0, utils_1.toBn)(orderStatusRaw.totalSize),
            isValidated: orderStatusRaw.isValidated,
            isCancelled: orderStatusRaw.isCancelled,
        };
        const sanitizedOrder = (0, fulfill_1.validateAndSanitizeFromOrderStatus)(order, orderStatus);
        const timeBasedItemParams = {
            startTime: sanitizedOrder.parameters.startTime,
            endTime: sanitizedOrder.parameters.endTime,
            currentBlockTimestamp: Math.floor(Date.now() / 1000),
            ascendingAmountTimestampBuffer: 300,
        };
        const fulfillOrdersData = yield (0, fulfill_advance_wrapper_1.getFulfillAdvancedOrderWrapperData)({
            order: sanitizedOrder,
            unitsToFill,
            totalSize: orderStatus.totalSize,
            totalFilled: orderStatus.totalFilled,
            offerCriteria,
            considerationCriteria,
            tips: [],
            extraData,
            seaportAddress: (0, types_1.toEVMAddress)(constants_1.CROSS_CHAIN_SEAPORT_ADDRESS),
            offererBalancesAndApprovals,
            fulfillerBalancesAndApprovals,
            offererOperator,
            fulfillerOperator,
            timeBasedItemParams,
            conduitKey,
            recipientAddress,
            seaportContract,
            disableCheckingBalances,
        });
        const valueForSending = (0, origin_fees_utils_1.calcValueWithFees)((0, types_2.toBigNumber)(fulfillOrdersData.value), totalFeeBasisPoints);
        const totalPrice = (0, utils_1.toBn)(simpleOrder.take.value)
            .div(simpleOrder.make.value)
            .multipliedBy(unitsToFill || 1)
            .toFixed();
        return {
            data: {
                marketId: getMarketIdByOpenseaContract(simpleOrder.data.protocol),
                amount: (0, utils_1.toBn)(totalPrice).toFixed(),
                fees: encodedFeesValue,
                data: fulfillOrdersData.data,
            },
            options: {
                value: (0, common_1.isETH)(simpleOrder.take.assetType) ? valueForSending.toString() : "0",
            },
        };
    });
}
exports.prepareSeaportExchangeData = prepareSeaportExchangeData;
function getMarketIdByOpenseaContract(contract) {
    if ((0, compare_case_insensitive_1.compareCaseInsensitive)(contract, constants_1.CROSS_CHAIN_SEAPORT_V1_4_ADDRESS)) {
        return types_3.ExchangeWrapperOrderType.SEAPORT_V14;
    }
    else if ((0, compare_case_insensitive_1.compareCaseInsensitive)(contract, constants_1.CROSS_CHAIN_SEAPORT_ADDRESS)) {
        return types_3.ExchangeWrapperOrderType.SEAPORT_ADVANCED_ORDERS;
    }
    else if ((0, compare_case_insensitive_1.compareCaseInsensitive)(contract, constants_1.CROSS_CHAIN_SEAPORT_V1_5_ADDRESS)) {
        return types_3.ExchangeWrapperOrderType.SEAPORT_V15;
    }
    else if ((0, compare_case_insensitive_1.compareCaseInsensitive)(contract, constants_1.CROSS_CHAIN_SEAPORT_V1_6_ADDRESS)) {
        return types_3.ExchangeWrapperOrderType.SEAPORT_V16;
    }
    throw new Error("Unrecognized opensea protocol contract");
}
exports.getMarketIdByOpenseaContract = getMarketIdByOpenseaContract;
