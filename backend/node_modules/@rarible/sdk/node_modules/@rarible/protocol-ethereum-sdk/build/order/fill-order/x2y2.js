"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.X2Y2OrderHandler = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const exchange_wrapper_1 = require("../contracts/exchange-wrapper");
const types_2 = require("./types");
const get_order_sign_1 = require("./x2y2-utils/get-order-sign");
const origin_fees_utils_1 = require("./common/origin-fees-utils");
class X2Y2OrderHandler {
    constructor(ethereum, send, getConfig, getBaseOrderFeeConfig, getApis) {
        this.ethereum = ethereum;
        this.send = send;
        this.getConfig = getConfig;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.getApis = getApis;
    }
    fillOrder(order, request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const sendData = yield this.getTransactionData(request);
            return this.send(sendData.functionCall, sendData.options);
        });
    }
    getTransactionData(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            const wrapper = (0, exchange_wrapper_1.createExchangeWrapperContract)(this.ethereum, config.exchange.wrapper);
            if (!((_a = request.order.data) === null || _a === void 0 ? void 0 : _a.orderId)) {
                throw new Error("No x2y2 orderId provided");
            }
            if (request.originFees && request.originFees.length > 1) {
                throw new Error("x2y2 supports max up to 2 origin fee value");
            }
            const { totalFeeBasisPoints, encodedFeesValue, feeAddresses } = (0, origin_fees_utils_1.originFeeValueConvert)(request.originFees);
            const valueForSending = (0, origin_fees_utils_1.calcValueWithFees)((0, types_1.toBigNumber)(request.order.take.value), totalFeeBasisPoints);
            const data = yield this.getWrapperData(request, encodedFeesValue, valueForSending.toString());
            const functionCall = wrapper.functionCall("singlePurchase", data.data, feeAddresses[0], feeAddresses[1]);
            return {
                functionCall,
                options: data.options,
            };
        });
    }
    getTransactionDataForExchangeWrapper(request, originFees, feeValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { totalFeeBasisPoints } = (0, origin_fees_utils_1.originFeeValueConvert)(originFees);
            const valueForSending = (0, origin_fees_utils_1.calcValueWithFees)((0, types_1.toBigNumber)(request.order.take.value), totalFeeBasisPoints);
            return this.getWrapperData(request, feeValue, valueForSending.toString());
        });
    }
    getWrapperData(request, feeValue, totalValueForSending) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.ethereum) {
                throw new Error("Wallet undefined");
            }
            const config = yield this.getConfig();
            const apis = yield this.getApis();
            const x2y2Input = yield get_order_sign_1.X2Y2Utils.getOrderSign(apis, {
                sender: config.exchange.wrapper,
                orderId: request.order.data.orderId,
                currency: types_1.EVM_ZERO_ADDRESS,
                price: request.order.take.value,
            });
            return {
                data: {
                    marketId: types_2.ExchangeWrapperOrderType.X2Y2,
                    amount: request.order.take.value,
                    fees: feeValue,
                    data: x2y2Input,
                },
                options: { value: totalValueForSending },
            };
        });
    }
    getFillOrderBaseFee() {
        return this.getBaseOrderFeeConfig("X2Y2");
    }
    getOrderFee() {
        return 0;
    }
}
exports.X2Y2OrderHandler = X2Y2OrderHandler;
