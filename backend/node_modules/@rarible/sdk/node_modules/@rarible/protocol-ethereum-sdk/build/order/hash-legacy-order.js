"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashLegacyOrder = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const to_legacy_asset_type_1 = require("./to-legacy-asset-type");
function hashLegacyOrder(ethereum, order) {
    if (order.type !== "RARIBLE_V1") {
        throw new Error(`Not supported type: ${order.type}`);
    }
    const data = order.data;
    if (data.dataType !== "LEGACY") {
        throw new Error(`Not supported data type: ${data.dataType}`);
    }
    const makeType = (0, to_legacy_asset_type_1.toLegacyAssetType)(order.make.assetType);
    const takeType = (0, to_legacy_asset_type_1.toLegacyAssetType)(order.take.assetType);
    const struct = {
        key: {
            owner: order.maker,
            salt: order.salt,
            sellAsset: makeType,
            buyAsset: takeType,
        },
        selling: order.make.value,
        buying: order.take.value,
        sellerFee: data.fee,
    };
    const encodedOrder = ethereum.encodeParameter({ Order: ORDER }, struct);
    return `0x${(0, ethereumjs_util_1.keccak256)(Buffer.from(encodedOrder.substring(2), "hex")).toString("hex")}`;
}
exports.hashLegacyOrder = hashLegacyOrder;
const ASSET = {
    token: "address",
    tokenId: "uint256",
    assetType: "uint8",
};
const ORDER = {
    key: {
        owner: "address",
        salt: "uint256",
        sellAsset: ASSET,
        buyAsset: ASSET,
    },
    selling: "uint256",
    buying: "uint256",
    sellerFee: "uint256",
};
