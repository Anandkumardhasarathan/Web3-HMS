"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderSell = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const utils_1 = require("@rarible/utils");
const action_1 = require("@rarible/action");
const is_currency_1 = require("./is-currency");
class OrderSell {
    constructor(upserter, checkAssetType) {
        this.upserter = upserter;
        this.checkAssetType = checkAssetType;
        this.sell = action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const form = yield this.getSellForm(request);
                const checked = (yield this.upserter.checkLazyOrder(form));
                yield this.upserter.approve(checked, false);
                return checked;
            }),
        }).thenStep({
            id: "sign",
            run: (form) => this.upserter.upsertRequest(form),
        });
        this.update = action_1.Action.create({
            id: "approve",
            run: (request) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const order = yield this.upserter.getOrder(request);
                if (!(0, is_currency_1.isCurrency)(order.take.assetType)) {
                    throw new Error(`Make asset type should be either ETH or ERC-20 asset, received=${order.make.assetType.assetClass}`);
                }
                if (order.type === "CRYPTO_PUNK") {
                    return request;
                }
                else {
                    const price = yield this.upserter.getPrice(request, order.take.assetType);
                    const form = yield this.prepareOrderUpdateForm(order, request, price);
                    const checked = (yield this.upserter.checkLazyOrder(form));
                    yield this.upserter.approve(checked, false);
                    return checked;
                }
            }),
        }).thenStep({
            id: "sign",
            run: (form) => {
                if ("type" in form && (form.type === "RARIBLE_V1" || form.type === "RARIBLE_V2")) {
                    return this.upserter.upsertRequest(form);
                }
                return this.upserter.updateCryptoPunkOrder(form);
            },
        });
    }
    getSellForm(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const price = yield this.upserter.getPrice(request, request.takeAssetType);
            const form = yield this.upserter.prepareOrderForm(request, true);
            return Object.assign(Object.assign({}, form), { make: {
                    assetType: yield this.checkAssetType(request.makeAssetType),
                    value: (0, types_1.toBigNumber)(request.amount.toString()),
                }, take: {
                    assetType: request.takeAssetType,
                    value: (0, types_1.toBigNumber)((0, utils_1.toBn)(price).multipliedBy(request.amount).toString()),
                } });
        });
    }
    prepareOrderUpdateForm(order, request, price) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (order.type === "RARIBLE_V1" || order.type === "RARIBLE_V2") {
                if (!request.end && !order.end) {
                    throw new Error("Order should contains 'end' field");
                }
                return Object.assign(Object.assign({}, order), { take: {
                        assetType: order.take.assetType,
                        value: (0, types_1.toBigNumber)((0, utils_1.toBn)(price).multipliedBy(order.make.value).toString()),
                    }, salt: (0, types_1.toBigNumber)((0, utils_1.toBn)(order.salt, 16).toString(10)), signature: order.signature || (0, types_1.toBinary)("0x"), end: (request.end || order.end) });
            }
            throw new Error(`Unsupported order type: ${order.type}`);
        });
    }
}
exports.OrderSell = OrderSell;
