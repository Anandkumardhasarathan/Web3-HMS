"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderToStruct = exports.hashToSign = exports.signOrder = void 0;
const tslib_1 = require("tslib");
const types_1 = require("@rarible/types");
const eth_sig_util_1 = require("eth-sig-util");
const sdk_common_1 = require("@rarible/sdk-common");
const hash_legacy_order_1 = require("./hash-legacy-order");
const asset_type_to_struct_1 = require("./asset-type-to-struct");
const eip712_1 = require("./eip712");
const encode_rarible_v2_order_data_1 = require("./encode-rarible-v2-order-data");
function signOrder(ethereum, getConfig, order) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!ethereum) {
            throw new Error("Wallet undefined");
        }
        const config = yield getConfig();
        switch (order.type) {
            case "RARIBLE_V1": {
                const legacyHash = (0, hash_legacy_order_1.hashLegacyOrder)(ethereum, order);
                return (0, types_1.toBinary)(yield ethereum.personalSign(legacyHash.substring(2)));
            }
            case "RARIBLE_V2": {
                const domain = createEIP712Domain(config.chainId, config.exchange.v2);
                const structMessage = orderToStruct(ethereum, order);
                const signature = yield ethereum.signTypedData({
                    primaryType: eip712_1.EIP712_ORDER_TYPE,
                    domain,
                    types: eip712_1.EIP712_ORDER_TYPES,
                    message: structMessage,
                });
                if (!signature || typeof signature !== "string") {
                    throw new Error(`signOrder error: signature=${(0, sdk_common_1.getStringifiedData)(signature)}, data=${JSON.stringify(structMessage)}`);
                }
                return (0, types_1.toBinary)(signature);
            }
            default: {
                throw new Error(`Unsupported order type: ${order.type}`);
            }
        }
    });
}
exports.signOrder = signOrder;
function hashToSign(config, ethereum, order) {
    const domain = createEIP712Domain(config.chainId, config.exchange.v2);
    return eth_sig_util_1.TypedDataUtils.sign({
        primaryType: eip712_1.EIP712_ORDER_TYPE,
        domain,
        types: eip712_1.EIP712_ORDER_TYPES,
        message: orderToStruct(ethereum, order),
    });
}
exports.hashToSign = hashToSign;
function createEIP712Domain(chainId, verifyingContract) {
    return Object.assign(Object.assign({}, eip712_1.EIP712_DOMAIN_TEMPLATE), { verifyingContract: verifyingContract, chainId });
}
function orderToStruct(ethereum, order, wrongEncode = false) {
    var _a, _b, _c;
    const [dataType, data] = (0, encode_rarible_v2_order_data_1.encodeRaribleV2OrderData)(ethereum, order.data, wrongEncode);
    return {
        maker: order.maker,
        makeAsset: assetToStruct(ethereum, order.make),
        taker: (_a = order.taker) !== null && _a !== void 0 ? _a : types_1.EVM_ZERO_ADDRESS,
        takeAsset: assetToStruct(ethereum, order.take),
        salt: order.salt,
        start: (_b = order.start) !== null && _b !== void 0 ? _b : 0,
        end: (_c = order.end) !== null && _c !== void 0 ? _c : 0,
        dataType,
        data,
    };
}
exports.orderToStruct = orderToStruct;
function assetToStruct(ethereum, asset) {
    return {
        assetType: (0, asset_type_to_struct_1.assetTypeToStruct)(ethereum, asset.assetType),
        value: asset.value,
    };
}
