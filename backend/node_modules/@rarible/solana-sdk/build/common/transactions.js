"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendSignedTransaction = exports.sendTransactionWithRetry = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const solana_common_1 = require("@rarible/solana-common");
function sendTransactionWithRetry(connection, wallet, instructions, signers, commitment, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction({ feePayer: wallet.publicKey });
        instructions.forEach(instruction => transaction.add(instruction));
        transaction.recentBlockhash = (yield connection.getLatestBlockhash(commitment)).blockhash;
        if (signers.length > 0) {
            yield wallet.signTransaction(transaction);
            for (let signer of signers) {
                yield signer.signTransaction(transaction);
            }
        }
        else {
            yield wallet.signTransaction(transaction);
        }
        return yield sendSignedTransaction({
            connection,
            signedTransaction: transaction,
        }, logger);
    });
}
exports.sendTransactionWithRetry = sendTransactionWithRetry;
function sendSignedTransaction(_a, logger_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* ({ signedTransaction, connection, timeout = 1000 * 60, }, logger) {
        const rawTransaction = signedTransaction.serialize();
        const startTime = (0, solana_common_1.getUnixTs)();
        let slot = 0;
        const txId = yield connection.sendRawTransaction(rawTransaction, {
            skipPreflight: true,
        });
        logger === null || logger === void 0 ? void 0 : logger.log("Started awaiting confirmation for", txId);
        let done = false;
        (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            while (!done && (0, solana_common_1.getUnixTs)() - startTime < timeout) {
                connection.sendRawTransaction(rawTransaction, {
                    skipPreflight: true,
                });
                yield (0, solana_common_1.sleep)(500);
            }
        }))();
        try {
            const confirmation = yield awaitTransactionSignatureConfirmation(txId, timeout, connection, "processed", true, logger);
            if (!confirmation) {
                throw new Error("Timed out awaiting confirmation on transaction");
            }
            if (confirmation.err) {
                logger === null || logger === void 0 ? void 0 : logger.error(confirmation.err);
                throw new Error("Transaction failed: Custom instruction error");
            }
            slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;
        }
        catch (err) {
            logger === null || logger === void 0 ? void 0 : logger.error("Timeout Error caught", err);
            if (err.timeout) {
                throw new Error("Timed out awaiting confirmation on transaction");
            }
            let simulateResult = null;
            try {
                simulateResult = (yield simulateTransaction(connection, signedTransaction, "single", logger)).value;
            }
            catch (e) {
                logger === null || logger === void 0 ? void 0 : logger.error("Simulate Transaction error", e);
            }
            if (simulateResult && simulateResult.err) {
                if (simulateResult.logs) {
                    for (let i = simulateResult.logs.length - 1; i >= 0; --i) {
                        const line = simulateResult.logs[i];
                        if (line.startsWith("Program log: ")) {
                            logger === null || logger === void 0 ? void 0 : logger.log(simulateResult.logs);
                            throw new Error("Transaction failed: " + line.slice("Program log: ".length));
                        }
                    }
                }
                throw new Error(JSON.stringify(simulateResult.err));
            }
            logger === null || logger === void 0 ? void 0 : logger.error("Got this far.");
            // throw new Error("Transaction failed")
        }
        finally {
            done = true;
        }
        logger === null || logger === void 0 ? void 0 : logger.log("Latency (ms)", txId, (0, solana_common_1.getUnixTs)() - startTime);
        return { txId, slot };
    });
}
exports.sendSignedTransaction = sendSignedTransaction;
function simulateTransaction(connection, transaction, commitment, logger) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const anyConnection = connection;
        transaction.recentBlockhash = yield anyConnection._recentBlockhash(anyConnection._disableBlockhashCaching);
        const signData = transaction.serializeMessage();
        const anyTransaction = transaction;
        const wireTransaction = anyTransaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        const config = { encoding: "base64", commitment };
        const args = [encodedTransaction, config];
        const res = yield anyConnection._rpcRequest("simulateTransaction", args, logger);
        if (res.error) {
            throw new Error("failed to simulate transaction: " + res.error.message);
        }
        return res.result;
    });
}
function awaitTransactionSignatureConfirmation(txid_1, timeout_1, connection_1) {
    return tslib_1.__awaiter(this, arguments, void 0, function* (txid, timeout, connection, commitment = "recent", queryStatus = false, logger) {
        let done = false;
        let status = {
            slot: 0,
            confirmations: 0,
            err: null,
        };
        let subId = 0;
        status = yield new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            setTimeout(() => {
                if (done)
                    return;
                done = true;
                logger === null || logger === void 0 ? void 0 : logger.log("Rejecting for timeout...");
                reject({ timeout: true });
            }, timeout);
            try {
                subId = connection.onSignature(txid, (result, context) => {
                    done = true;
                    status = {
                        err: result.err,
                        slot: context.slot,
                        confirmations: 0,
                    };
                    if (result.err) {
                        logger === null || logger === void 0 ? void 0 : logger.log("Rejected via websocket", result.err);
                        reject(status);
                    }
                    else {
                        logger === null || logger === void 0 ? void 0 : logger.log("Resolved via websocket", result);
                        resolve(status);
                    }
                }, commitment);
            }
            catch (e) {
                done = true;
                logger === null || logger === void 0 ? void 0 : logger.error("WS error in setup", txid, e);
            }
            while (!done && queryStatus) {
                // eslint-disable-next-line no-loop-func
                ;
                (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    try {
                        const signatureStatuses = yield connection.getSignatureStatuses([txid]);
                        status = signatureStatuses && signatureStatuses.value[0];
                        if (!done) {
                            if (!status) {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST null result for", txid, status);
                            }
                            else if (status.err) {
                                logger === null || logger === void 0 ? void 0 : logger.error("REST error for", txid, status);
                                done = true;
                                reject(status.err);
                            }
                            else if (!status.confirmations) {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST no confirmations for", txid, status);
                            }
                            else {
                                logger === null || logger === void 0 ? void 0 : logger.log("REST confirmation for", txid, status);
                                done = true;
                                resolve(status);
                            }
                        }
                    }
                    catch (e) {
                        if (!done) {
                            logger === null || logger === void 0 ? void 0 : logger.error("REST connection error: txid", txid, e);
                        }
                    }
                }))();
                yield (0, solana_common_1.sleep)(2000);
            }
        }));
        const anyConnection = connection;
        if (anyConnection._signatureSubscriptions[subId]) {
            connection.removeSignatureListener(subId);
        }
        done = true;
        logger === null || logger === void 0 ? void 0 : logger.log("Returning status", status);
        return status;
    });
}
