import { BigMapAbstraction, OriginateParams, TezosToolkit, TransferParams } from "@taquito/taquito";
import { MichelsonData } from "@taquito/michel-codec";
import BigNumber from "bignumber.js";
import { Config } from "./types";
export interface StorageFA2 {
    ledger: BigMapAbstraction;
    operator: BigMapAbstraction;
    operators: BigMapAbstraction;
    operators_for_all: BigMapAbstraction;
    token_metadata: BigMapAbstraction;
}
export interface StorageFA1_2 {
    ledger: BigMapAbstraction;
    token_metadata: BigMapAbstraction;
    allowance: BigMapAbstraction;
}
export interface StorageSalesV2 {
    sales: BigMapAbstraction;
    bundle_sales: BigMapAbstraction;
}
export interface StorageAuctions {
    auctions: BigMapAbstraction;
    bundle_auctions: BigMapAbstraction;
}
export declare type AssetData = {
    contract?: string;
    token_id?: BigNumber;
};
export declare enum Platform {
    RARIBLE_V1 = "RARIBLE_V1",
    RARIBLE_V2 = "RARIBLE_V2",
    OBJKT_V1 = "OBJKT_V1",
    OBJKT_V2 = "OBJKT_V2",
    HEN = "HEN",
    TEIA_V1 = "TEIA_V1",
    VERSUM_V1 = "VERSUM_V1",
    FXHASH_V1 = "FXHASH_V1",
    FXHASH_V2 = "FXHASH_V2"
}
export declare enum OrderStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
    FILLED = "FILLED"
}
export interface XTZAssetType {
    asset_class: "XTZ";
}
export interface FTAssetType {
    asset_class: "FT";
    contract: string;
    token_id?: BigNumber;
}
export interface NFTAssetType {
    asset_class: "NFT";
    contract: string;
    token_id: BigNumber;
}
export interface MTAssetType {
    asset_class: "MT";
    contract: string;
    token_id: BigNumber;
}
export declare type TokenAssetType = FTAssetType | NFTAssetType | MTAssetType;
export declare type AssetType = XTZAssetType | TokenAssetType;
export declare enum AssetTypeV2 {
    XTZ = 0,
    FA12 = 1,
    FA2 = 2
}
export declare enum OrderType {
    V1 = 0,
    V2 = 1
}
export interface AssetBase<T> {
    asset_type: T;
    value: BigNumber;
}
export declare type Asset = AssetBase<AssetType>;
export interface OperationResult {
    hash: string;
    confirmation: () => Promise<void>;
}
export declare type MintResult = OperationResult & {
    token_id: BigNumber;
};
export declare type BatchMintResult = OperationResult & {
    token_ids: Array<BigNumber>;
};
export declare type DeployResult = OperationResult & {
    contract: string;
};
export interface TezosProvider {
    kind: 'in_memory' | "temple" | "beacon" | "kukai";
    transfer: (arg: TransferParams) => Promise<OperationResult>;
    originate: (arg: OriginateParams) => Promise<DeployResult>;
    batch: (args: TransferParams[]) => Promise<OperationResult>;
    sign: (bytes: string, type?: "operation" | "message") => Promise<{
        signature: string;
        prefix: string;
    }>;
    address: () => Promise<string>;
    public_key: () => Promise<string | undefined>;
    storage: (contract: string) => Promise<any>;
    balance: () => Promise<BigNumber>;
    chain_id: () => Promise<string>;
    tk: TezosToolkit;
}
export interface Provider {
    tezos: TezosProvider;
    config: Config;
}
export interface TransactionArg {
    destination: string;
    amount?: BigNumber;
    entrypoint?: string;
    parameter?: MichelsonData;
}
export interface SignatureResult {
    signature: string;
    edpk: string;
    prefix: string;
}
export declare function asset_type_to_json(a: AssetType): any;
export declare function asset_type_of_json(a: any): AssetType;
export declare function asset_to_json(a: Asset): any;
export declare function asset_of_json(a: any): Asset;
export declare function asset_type_contract(p: Provider, a: TokenAssetType): string;
export declare function get_address(p: Provider): Promise<string>;
export declare function get_public_key(p: Provider): Promise<string | undefined>;
export declare function get_storage(p: Provider, contract: string): Promise<any>;
export declare function get_sign(provider: Provider, bytes: string, type?: "operation" | "message"): Promise<{
    signature: string;
    prefix: string;
}>;
export declare function get_originate(provider: Provider, arg: OriginateParams): Promise<DeployResult>;
export declare function send(provider: Provider, arg: TransactionArg): Promise<OperationResult>;
export declare class TezosProviderError extends Error {
    error: any;
    args: any;
    method: string;
    constructor(data: {
        error?: any;
        args?: any;
        method: string;
    });
    static getErrorMessage(error: any): any;
}
export declare function send_batch(provider: Provider, args: TransactionArg[]): Promise<OperationResult>;
export declare function wrap_confirmation<T extends OperationResult>(op: T, args?: any): T & {
    confirmation: () => Promise<void>;
};
export declare function get_royalties(provider: Provider, token_contract: string, tokenId: BigNumber): Promise<Array<Part>>;
export declare function are_royalties_on_chain(provider: Provider, token_contract: string, token_id: BigNumber): Promise<boolean>;
export declare function uint8array_to_hex(a: Uint8Array): string;
export declare function hex_to_uint8array(s: string): Uint8Array;
export declare function to_hex(s: string): string;
export declare function pack_string(s: string): string;
export declare function of_hex(s: string): string;
export declare function tezos_signed_message_prefix(domain?: string): string;
export declare function sign(p: TezosProvider, message: string, type: "operation" | "message"): Promise<SignatureResult>;
export declare const tz1_prefix: Uint8Array;
export declare const tz2_prefix: Uint8Array;
export declare const tz3_prefix: Uint8Array;
export declare const edpk_prefix: Uint8Array;
export declare const sppk_prefix: Uint8Array;
export declare const p2pk_prefix: Uint8Array;
export declare const edsk_prefix: Uint8Array;
export declare const spsk_prefix: Uint8Array;
export declare const p2sk_prefix: Uint8Array;
export declare const edsig_prefix: Uint8Array;
export declare const spsig1_prefix: Uint8Array;
export declare const p2sig_prefix: Uint8Array;
export declare const sig_prefix: Uint8Array;
export declare const op_prefix: Uint8Array;
export declare const kt1_prefix: Uint8Array;
export declare function b58enc(payload: Uint8Array, prefix: Uint8Array): string;
export declare function b58dec(enc: string, prefix: Uint8Array): Uint8Array;
export declare function pk_to_pkh(pk: string): string;
export declare function op_to_kt1(hash: string): string;
export declare function asset_factor(config: Config, asset_type: AssetTypeV2, asset_contract?: string, asset_token_id?: BigNumber): Promise<BigNumber>;
export declare function absolute_amount(config: Config, amount: BigNumber, asset_type: AssetTypeV2, asset_contract?: string, asset_token_id?: BigNumber): Promise<BigNumber>;
export declare function packFA2Asset(assetContract: String, assetId: BigNumber): import("@taquito/michel-codec").BytesLiteral;
export declare function unpackFA2Asset(data: string): AssetData;
export declare function packFA12Asset(assetContract: string): import("@taquito/michel-codec").BytesLiteral;
export declare function unpackFA12Asset(data: string): AssetData;
export declare function getAsset(sale_type: AssetTypeV2, assetContract?: string, assetId?: BigNumber): string;
export declare function get_ft_type(config: Config, assetContract: string): Promise<AssetTypeV2 | undefined>;
export declare function get_decimals(config: Config, contract: string, token_id?: BigNumber): Promise<BigNumber>;
export declare function process_token_id(sale_type: AssetTypeV2, token_id: BigNumber | undefined): BigNumber | undefined;
export interface Part {
    account: string;
    value: BigNumber;
}
export declare function parts_to_micheline(p: Array<Part>): MichelsonData[];
export declare function objkt_parts_to_micheline(p: Array<Part>): MichelsonData[];
export declare function optional_date_arg(date?: number): MichelsonData;
export declare function delay(num: number): Promise<void>;
export declare function retry<T>(num: number, del: number, thunk: () => Promise<T>): Promise<T>;
export declare type TezosNetwork = "mainnet" | "dev" | "testnet";
