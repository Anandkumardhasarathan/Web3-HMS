"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomEVMAddress = exports.EVM_ZERO_ADDRESS = exports.toEVMAddressSafe = exports.toEVMAddressStrict = exports.toEVMAddress = exports.evmAddressValidator = exports.isEVMAddress = exports.evmAddressRegExp = void 0;
const index_js_1 = require("../../../common/binary/index.js");
const address_js_1 = require("../../common/address.js");
const common_js_1 = require("../../common/common.js");
const index_js_2 = require("../../union/enum/index.js");
exports.evmAddressRegExp = new RegExp(/^0x[a-fA-F0-9]{40}$/);
function isEVMAddress(raw) {
    return exports.evmAddressRegExp.test(raw);
}
exports.isEVMAddress = isEVMAddress;
exports.evmAddressValidator = (0, common_js_1.createLayer1fulValidator)(index_js_2.BlockchainLayer1Enum.ETHEREUM, isEVMAddress);
/**
 * Check and convert EVM-compatible addresses
 * @note it also convert it to lowercase
 */
function toEVMAddress(value) {
    const parsed = toEVMAddressSafe(value);
    if (!parsed)
        throw new address_js_1.InvalidAddressError(index_js_2.BlockchainLayer1Enum.ETHEREUM, value);
    return parsed;
}
exports.toEVMAddress = toEVMAddress;
function normalizeEVMAddress(str) {
    return str.toLowerCase();
}
/**
 * Check and convert EVM-compatible addresses
 * @deprecated please use toEVMAddress instead
 */
exports.toEVMAddressStrict = toEVMAddress;
function toEVMAddressSafe(raw) {
    if (isEVMAddress(raw))
        return normalizeEVMAddress(raw);
    return undefined;
}
exports.toEVMAddressSafe = toEVMAddressSafe;
exports.EVM_ZERO_ADDRESS = toEVMAddress("0x0000000000000000000000000000000000000000");
function randomEVMAddress() {
    return toEVMAddress((0, index_js_1.randomBinary)(20));
}
exports.randomEVMAddress = randomEVMAddress;
