"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidUnionAddressError = exports.isUnionAddress = exports.toUnionAddressSafe = exports.toUnionAddress = void 0;
const utils_1 = require("@rarible/utils");
const utils_js_1 = require("../enum/utils.js");
const validators_js_1 = require("./validators.js");
/**
 * Address format of union service
 * Will convert raw address to UnionAddress
 * @note that all blockchains will be converted to layer-1 blockchain
 *
 * @example
 * ETHEREUM:0xd07dc4262bcdbf85190c01c996b4c06a461d2430 -> ETHEREUM:0xd07dc4262bcdbf85190c01c996b4c06a461d2430
 * POLYGON:0xd07dc4262bcdbf85190c01c996b4c06a461d2430 -> ETHEREUM:0xd07dc4262bcdbf85190c01c996b4c06a461d2430
 * FLOW:0x01658d9b94068f3c -> FLOW:0x01658d9b94068f3c
 */
function toUnionAddress(value) {
    const safe = toUnionAddressSafe(value);
    if (!safe)
        throw new InvalidUnionAddressError(value);
    return safe;
}
exports.toUnionAddress = toUnionAddress;
function toUnionAddressSafe(value) {
    if (isUnionAddress(value)) {
        const [blockchain, address] = (0, utils_js_1.parseBlockchain)(value);
        return (0, utils_js_1.withLayer1Blockchain)((0, utils_js_1.toLayerOneBlockchain)(blockchain), address);
    }
    return undefined;
}
exports.toUnionAddressSafe = toUnionAddressSafe;
function isUnionAddress(value) {
    const parsed = (0, utils_js_1.parseBlockchainSafe)(value);
    if (!parsed)
        return false;
    const [blockchain, address] = parsed;
    const layer1 = (0, utils_js_1.toLayerOneBlockchain)(blockchain);
    const validator = validators_js_1.addressValidators[layer1];
    return validator.validate(address);
}
exports.isUnionAddress = isUnionAddress;
class InvalidUnionAddressError extends utils_1.CustomError {
    constructor(address) {
        super(`Not a UnionAddress: ${address}`);
    }
}
exports.InvalidUnionAddressError = InvalidUnionAddressError;
