import type { Contract, ContractSendMethod } from "web3-eth-contract";
import Web3 from "web3";
import type { TransactionReceipt } from "web3-core";
import type * as EthereumProvider from "@rarible/ethereum-provider";
import type { MessageTypes, TypedMessage, EthereumSendTransactionOptions } from "@rarible/ethereum-provider";
import type { Address, BigNumber, Binary, Word } from "@rarible/types";
import type { AbiItem } from "web3-utils";
import { DappType } from "@rarible/sdk-common";
import type { Web3EthereumConfig } from "./domain";
export declare class Web3Ethereum implements EthereumProvider.Ethereum {
    private readonly config;
    constructor(config: Web3EthereumConfig);
    static isWeb3v1(web3Instance: unknown): web3Instance is Web3;
    createContract(abi: any, address?: string): EthereumProvider.EthereumContract;
    send(method: string, params: unknown[]): Promise<any>;
    personalSign(message: string): Promise<string>;
    sendTransaction(options: EthereumSendTransactionOptions): Promise<Web3Transaction>;
    signTypedData<T extends MessageTypes>(data: TypedMessage<T>): Promise<string>;
    getFrom(): Promise<string>;
    encodeParameter(type: any, parameter: any): string;
    decodeParameter(type: any, data: string): any;
    getBalance(address: Address): Promise<BigNumber>;
    getChainId(): Promise<number>;
    getWeb3Instance(): Web3;
    getCurrentProvider(): any;
}
export declare class Web3Contract implements EthereumProvider.EthereumContract {
    private readonly config;
    private readonly contract;
    constructor(config: Web3EthereumConfig, contract: Contract);
    functionCall(name: string, ...args: any): EthereumProvider.EthereumFunctionCall;
}
export declare class Web3FunctionCall implements EthereumProvider.EthereumFunctionCall {
    private readonly config;
    private readonly contract;
    private readonly methodName;
    private readonly args;
    private readonly sendMethod;
    private readonly contractAddress;
    constructor(config: Web3EthereumConfig, contract: Contract, methodName: string, args: any[]);
    getCallInfo(): Promise<EthereumProvider.EthereumFunctionCallInfo>;
    getData(): Promise<string>;
    getMethodWithReserveNode(): Promise<ContractSendMethod | undefined>;
    getReserveNode(): Promise<string | undefined>;
    estimateGas(options?: EthereumProvider.EthereumEstimateGasOptions): Promise<number>;
    private callWithRetry;
    call(options?: EthereumProvider.EthereumSendOptions): Promise<any>;
    private _send;
    send(options?: EthereumProvider.EthereumSendOptions): Promise<EthereumProvider.EthereumTransaction>;
    getFrom(): Promise<string>;
}
export declare class Web3Transaction implements EthereumProvider.EthereumTransaction {
    private readonly receipt;
    readonly hash: Word;
    readonly data: Binary;
    readonly from: Address;
    readonly to?: Address | undefined;
    private readonly contractAbi?;
    constructor(receipt: Promise<TransactionReceipt>, hash: Word, data: Binary, from: Address, to?: Address | undefined, contractAbi?: AbiItem[] | undefined);
    wait(): Promise<EthereumProvider.EthereumTransactionReceipt>;
    getEvents(): Promise<EthereumProvider.EthereumTransactionEvent[]>;
}
export declare function getCurrentProviderId(web3: Web3 | undefined): DappType;
export { Web3 };
