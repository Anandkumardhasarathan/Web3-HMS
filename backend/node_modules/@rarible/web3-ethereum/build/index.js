"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3 = exports.getCurrentProviderId = exports.Web3Transaction = exports.Web3FunctionCall = exports.Web3Contract = exports.Web3Ethereum = void 0;
const tslib_1 = require("tslib");
const web3_1 = tslib_1.__importDefault(require("web3"));
exports.Web3 = web3_1.default;
const ethereum_provider_1 = require("@rarible/ethereum-provider");
const types_1 = require("@rarible/types");
const sdk_common_1 = require("@rarible/sdk-common");
const sign_typed_data_1 = require("@rarible/ethereum-provider/build/sign-typed-data");
const provider_request_1 = require("./utils/provider-request");
const to_promises_1 = require("./utils/to-promises");
const log_parser_1 = require("./utils/log-parser");
class Web3Ethereum {
    constructor(config) {
        this.config = config;
        if (!Web3Ethereum.isWeb3v1(config.web3)) {
            throw new Error(`Passed version web3=${(0, sdk_common_1.getWeb3Version)(config.web3)}, expected v1`);
        }
        this.send = this.send.bind(this);
        this.getFrom = this.getFrom.bind(this);
    }
    static isWeb3v1(web3Instance) {
        return (0, sdk_common_1.isWeb3v1)(web3Instance);
    }
    createContract(abi, address) {
        return new Web3Contract(this.config, new this.config.web3.eth.Contract(abi, address));
    }
    send(method, params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield (0, provider_request_1.providerRequest)(this.config.web3.currentProvider, method, params);
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { error, method: "Web3Ethereum.send", data: {
                        method,
                        params,
                    } }));
            }
        });
    }
    personalSign(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let signer;
            try {
                signer = yield this.getFrom();
                const signature = yield this.config.web3.eth.personal.sign(message, signer, "");
                (0, ethereum_provider_1.filterErrors)(signature);
                return signature;
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { error, method: "Web3Ethereum.personalSign", data: { message } }));
            }
        });
    }
    sendTransaction(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let enrichedData = options.data || "0x";
                if (options.additionalData) {
                    const additionalData = (0, types_1.toBinary)(options.additionalData).slice(2);
                    enrichedData = `0x${enrichedData}${additionalData}`;
                }
                const gasOptions = getGasOptions(this.config, options);
                const from = yield this.getFrom();
                const transactionOptions = Object.assign({ from, to: options.to, data: enrichedData, value: options.value }, gasOptions);
                const promiEvent = this.config.web3.eth.sendTransaction(transactionOptions);
                const promises = (0, to_promises_1.toPromises)(promiEvent);
                return new Web3Transaction(promises.receipt, (0, types_1.toWord)(yield promises.hash), (0, types_1.toBinary)(enrichedData), (0, types_1.toAddress)(from));
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { error, method: "Web3Ethereum.sendTransaction", data: { options } }));
            }
        });
    }
    signTypedData(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let signer;
            try {
                signer = yield this.getFrom();
                return yield (0, ethereum_provider_1.signTypedData)(this.send, signer, data);
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3Ethereum.signTypedData", error,
                    data }));
            }
        });
    }
    getFrom() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield getFrom(this.config.web3, this.config.from);
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3Ethereum.getFrom", error, data: null }));
            }
        });
    }
    encodeParameter(type, parameter) {
        try {
            return this.config.web3.eth.abi.encodeParameter(type, parameter);
        }
        catch (error) {
            throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, getProvidersData(this.config)), { method: "Web3Ethereum.encodeParameter", error, data: { type, parameter } }));
        }
    }
    decodeParameter(type, data) {
        try {
            return this.config.web3.eth.abi.decodeParameters([type], data);
        }
        catch (error) {
            throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, getProvidersData(this.config)), { method: "Web3Ethereum.decodeParameter", error, data: { type, data } }));
        }
    }
    getBalance(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const amount = yield (0, sdk_common_1.conditionalRetry)(5, 3000, () => this.config.web3.eth.getBalance(address), error => (error === null || error === void 0 ? void 0 : error.message) === sdk_common_1.FAILED_TO_FETCH_ERROR);
                return (0, types_1.toBigNumber)(amount);
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3Ethereum.getBalance", error, data: { address } }));
            }
        });
    }
    getChainId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return +(yield this.config.web3.eth.getChainId());
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, getProvidersData(this.config)), { method: "Web3Ethereum.getChainId", error, data: null }));
            }
        });
    }
    getWeb3Instance() {
        return this.config.web3;
    }
    getCurrentProvider() {
        return this.config.web3.currentProvider;
    }
}
exports.Web3Ethereum = Web3Ethereum;
class Web3Contract {
    constructor(config, contract) {
        this.config = config;
        this.contract = contract;
    }
    functionCall(name, ...args) {
        return new Web3FunctionCall(this.config, this.contract, name, args);
    }
}
exports.Web3Contract = Web3Contract;
class Web3FunctionCall {
    constructor(config, contract, methodName, args) {
        this.config = config;
        this.contract = contract;
        this.methodName = methodName;
        this.args = args;
        try {
            this.sendMethod = this.contract.methods[this.methodName](...this.args);
            this.contractAddress = (0, types_1.toAddress)(this.contract.options.address);
        }
        catch (error) {
            throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, getProvidersData(this.config)), { method: "Web3FunctionCall.constructor", error, data: {
                    contract: this.contract.options.address,
                    methodName: this.methodName,
                    args: this.args,
                } }));
        }
    }
    getCallInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return {
                method: this.methodName,
                contract: this.contract.options.address,
                args: this.args,
                from: yield this.getFrom(),
                provider: ethereum_provider_1.Provider.WEB3,
            };
        });
    }
    getData() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.sendMethod.encodeABI();
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3FunctionCall.getData", error, data: {
                        contract: this.contract.options.address,
                        methodName: this.methodName,
                        args: this.args,
                    } }));
            }
        });
    }
    getMethodWithReserveNode() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const reserveNode = yield this.getReserveNode();
            if (reserveNode) {
                return getMethodWithNewWeb3Node(reserveNode, {
                    contract: this.contract,
                    methodName: this.methodName,
                    args: this.args,
                });
            }
        });
    }
    getReserveNode() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.config.reserveNodes && this.config.reserveNodes[+(yield this.config.web3.eth.getChainId())];
        });
    }
    estimateGas() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (options = {}) {
            var _a;
            try {
                try {
                    return yield (0, sdk_common_1.conditionalRetry)(5, 3000, () => this.sendMethod.estimateGas(options), error => (error === null || error === void 0 ? void 0 : error.message) === sdk_common_1.FAILED_TO_FETCH_ERROR);
                }
                catch (e) {
                    //Try to call estimateGas with reserve node
                    if ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(sdk_common_1.OUT_OF_GAS_ERROR)) {
                        const method = yield this.getMethodWithReserveNode();
                        if (method) {
                            return yield (0, sdk_common_1.conditionalRetry)(5, 3000, () => method.estimateGas(options), error => (error === null || error === void 0 ? void 0 : error.message) === sdk_common_1.FAILED_TO_FETCH_ERROR);
                        }
                    }
                    throw e;
                }
            }
            catch (error) {
                let callInfo = null, data = null, chainId = undefined;
                try {
                    ;
                    [callInfo, chainId, data] = yield (0, sdk_common_1.promiseSettledRequest)([
                        this.getCallInfo(),
                        this.config.web3.eth.getChainId(),
                        yield this.getData(),
                    ]);
                }
                catch (_) { }
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3FunctionCall.estimateGas", chainId,
                    error, data: Object.assign(Object.assign({}, callInfo), { options,
                        data }) }));
            }
        });
    }
    callWithRetry(sendMethod_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (sendMethod, options = {}) {
            const gasOptions = getGasOptions(this.config, options);
            return yield (0, sdk_common_1.conditionalRetry)(5, 3000, () => sendMethod.call(Object.assign({ from: this.config.from }, gasOptions)), error => (error === null || error === void 0 ? void 0 : error.message) === sdk_common_1.FAILED_TO_FETCH_ERROR);
        });
    }
    call() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (options = {}) {
            var _a;
            let gasOptions;
            try {
                gasOptions = getGasOptions(this.config, options);
                try {
                    return yield this.callWithRetry(this.sendMethod, options);
                }
                catch (e) {
                    //Try to invoke call method with reserve node
                    if ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(sdk_common_1.OUT_OF_GAS_ERROR)) {
                        const method = yield this.getMethodWithReserveNode();
                        if (method) {
                            return yield this.callWithRetry(method, options);
                        }
                    }
                    throw e;
                }
            }
            catch (error) {
                let info = null;
                let data = null;
                try {
                    ;
                    [info, data] = yield (0, sdk_common_1.promiseSettledRequest)([this.getCallInfo(), this.getData()]);
                }
                catch (_) { }
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), { method: "Web3FunctionCall.call", error, data: Object.assign(Object.assign({}, (info || {})), { data,
                        options,
                        gasOptions }) }));
            }
        });
    }
    _send() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (options = {}, gasOptions = getGasOptions(this.config, options)) {
            const [callInfo, chainId] = yield Promise.all([this.getCallInfo(), this.config.web3.eth.getChainId()]);
            let hash;
            let data;
            try {
                data = yield this.getData();
                const from = (0, types_1.toAddress)(callInfo.from);
                if (options.additionalData) {
                    const additionalData = (0, types_1.toBinary)(options.additionalData).slice(2);
                    const sourceData = (0, types_1.toBinary)(data).slice(2);
                    const enhancedData = `0x${sourceData}${additionalData}`;
                    const transactionOptions = Object.assign({ from, to: this.contractAddress, data: enhancedData, value: options.value }, gasOptions);
                    const promiEvent = this.config.web3.eth.sendTransaction(transactionOptions);
                    const promises = (0, to_promises_1.toPromises)(promiEvent);
                    return new Web3Transaction(promises.receipt, (0, types_1.toWord)(yield promises.hash), (0, types_1.toBinary)(enhancedData), from, this.contractAddress, this.contract.options.jsonInterface);
                }
                const sendMethodConfig = Object.assign({ from, value: options.value }, gasOptions);
                const promiEvent = this.sendMethod.send(sendMethodConfig);
                const promises = (0, to_promises_1.toPromises)(promiEvent);
                return new Web3Transaction(promises.receipt, (0, types_1.toWord)(yield promises.hash), (0, types_1.toBinary)(data), from, this.contractAddress);
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError(Object.assign(Object.assign(Object.assign({}, (yield getCommonErrorData(this.config))), getProvidersData(this.config)), { method: "Web3FunctionCall.send", error,
                    chainId, data: Object.assign(Object.assign({}, callInfo), { options,
                        gasOptions,
                        data,
                        hash }) }));
            }
        });
    }
    send() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (options = {}) {
            var _a;
            try {
                return yield this._send(options);
            }
            catch (e) {
                //todo remove this hack for Phantom wallet after fixing issue with gasPrice=null for web3/Metamask
                if ((0, sign_typed_data_1.hasMessage)(e) && ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes("missing or invalid parameters"))) {
                    return yield this._send(options, {});
                }
                throw e;
            }
        });
    }
    getFrom() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return getFrom(this.config.web3, this.config.from);
        });
    }
}
exports.Web3FunctionCall = Web3FunctionCall;
class Web3Transaction {
    constructor(receipt, hash, data, from, to, contractAbi) {
        this.receipt = receipt;
        this.hash = hash;
        this.data = data;
        this.from = from;
        this.to = to;
        this.contractAbi = contractAbi;
    }
    wait() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.receipt;
            }
            catch (error) {
                throw new ethereum_provider_1.EthereumProviderError({
                    provider: ethereum_provider_1.Provider.WEB3,
                    method: "Web3Transaction.wait",
                    error,
                    data: {
                        hash: this.hash,
                        data: this.data,
                        from: this.from,
                        to: this.to,
                    },
                });
            }
        });
    }
    getEvents() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.wait();
            if (this.to && this.contractAbi) {
                return (0, log_parser_1.getTransactionReceiptEvents)(this.receipt, this.to, this.contractAbi);
            }
            return (yield (0, log_parser_1.getContractMethodReceiptEvents)(this.receipt)) || [];
        });
    }
}
exports.Web3Transaction = Web3Transaction;
function getFrom(web3, from) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (from)
            return from;
        const [first] = yield web3.eth.getAccounts();
        if (!first)
            throw new Error("Wallet is not connected");
        return first;
    });
}
function getCommonErrorData(config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const [signer, chainId, blockNumber] = yield (0, sdk_common_1.promiseSettledRequest)([
            getFrom(config.web3, config.from),
            config.web3.eth.getChainId(),
            config.web3.eth.getBlockNumber(),
        ]);
        return Object.assign(Object.assign({}, getProvidersData(config)), { chainId,
            signer,
            blockNumber });
    });
}
function getProvidersData(config) {
    return {
        provider: ethereum_provider_1.Provider.WEB3,
        providerId: getCurrentProviderId(config.web3),
    };
}
function getCurrentProviderId(web3) {
    if (web3)
        return (0, sdk_common_1.getDappType)(web3.currentProvider) || sdk_common_1.DappType.Unknown;
    return sdk_common_1.DappType.Unknown;
}
exports.getCurrentProviderId = getCurrentProviderId;
function getMethodWithNewWeb3Node(nodeUrl, callOptions) {
    const web3 = new web3_1.default(new web3_1.default.providers.HttpProvider(nodeUrl));
    const updatedContract = new web3.eth.Contract(callOptions.contract.options.jsonInterface, callOptions.contract.options.address);
    return updatedContract.methods[callOptions.methodName](...callOptions.args);
}
function getGasOptions(config, options) {
    var _a, _b, _c;
    const gasOptions = {};
    const gasPrice = (_b = (_a = options.gasPrice) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : config.gasPrice;
    if (typeof gasPrice === "string" || typeof gasPrice === "number") {
        gasOptions.gasPrice = gasPrice;
    }
    const gas = (_c = options.gas) !== null && _c !== void 0 ? _c : config.gas;
    if (typeof gas === "number" || typeof gas === "string") {
        gasOptions.gas = gas;
    }
    return gasOptions;
}
