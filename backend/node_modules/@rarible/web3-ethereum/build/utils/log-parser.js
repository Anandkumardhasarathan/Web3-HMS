"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseReceiptEvents = exports.getTransactionReceiptEvents = exports.getContractMethodReceiptEvents = void 0;
const tslib_1 = require("tslib");
const web3_eth_abi_1 = tslib_1.__importDefault(require("web3-eth-abi"));
const web3Utils = tslib_1.__importStar(require("web3-utils"));
function getContractMethodReceiptEvents(receiptPromise) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const receipt = yield receiptPromise;
        return receipt.events
            ? Object.keys(receipt.events)
                .map(ev => receipt.events[ev])
                .map(ev => (Object.assign(Object.assign({}, ev), { args: ev.returnValues })))
            : [];
    });
}
exports.getContractMethodReceiptEvents = getContractMethodReceiptEvents;
function getTransactionReceiptEvents(receiptPromise, address, abi) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const eventsResponse = parseReceiptEvents(abi, address, yield receiptPromise);
        return Object.values(eventsResponse) || [];
    });
}
exports.getTransactionReceiptEvents = getTransactionReceiptEvents;
/**
 * Parse receipt events of the given contract.
 *
 * Web3 only parses the events of the contract that is returning the receipt. If
 * there are additional events logged by other contracts that were called during
 * the execution of the transaction, those will not be parsed automatically. For
 * those cases, additional parsing effort is required.
 *
 * @param {AbiItem[]} abi The ABI of the contract.
 * @param {string} address The address of the contract.
 * @param {TransactionReceipt} receipt The receipt to parse.
 * @returns {TransactionReceipt} The patched receipt.
 */
function parseReceiptEvents(abi, address, receipt) {
    // @ts-ignore
    const events = [];
    if (receipt.logs) {
        receipt.events = {};
        receipt.logs.forEach(function (log) {
            // @ts-ignore
            log.returnValues = {};
            // @ts-ignore
            log.signature = null;
            // @ts-ignore
            log.raw = {
                data: log.data,
                topics: log.topics,
            };
            // @ts-ignore
            delete log.data;
            // @ts-ignore
            delete log.topics;
            const eventNumber = log.logIndex;
            // @ts-ignore
            receipt.events[eventNumber] = log;
        });
        // @ts-ignore
        delete receipt.logs;
    }
    // @ts-ignore
    Object.keys(receipt.events).forEach(function (n) {
        // @ts-ignore
        const event = receipt.events[n];
        // @ts-ignore
        if (web3Utils.toChecksumAddress(event.address) !== web3Utils.toChecksumAddress(address) || event.signature) {
            return;
        }
        const descriptor = abi
            .filter(desc => desc.type === "event")
            .map(desc => (Object.assign(Object.assign({}, desc), { 
            // @ts-ignore
            signature: desc.signature || web3_eth_abi_1.default.encodeEventSignature(desc) })))
            // @ts-ignore
            .find(desc => desc.signature === event.raw.topics[0]);
        // @ts-ignore
        event.event = descriptor.name;
        // @ts-ignore
        event.signature = descriptor.signature;
        event.returnValues = web3_eth_abi_1.default.decodeLog(
        // @ts-ignore
        descriptor.inputs, 
        // @ts-ignore
        event.raw.data, 
        // @ts-ignore
        event.raw.topics.slice(1));
        events.push(event);
        delete event.returnValues.__length__;
        // @ts-ignore
        delete receipt.events[n];
    });
    let count = 0;
    // @ts-ignore
    events.forEach(function (ev) {
        if (ev.event) {
            // @ts-ignore
            if (receipt.events[ev.event]) {
                // @ts-ignore
                if (Array.isArray(receipt.events[ev.event])) {
                    // @ts-ignore
                    receipt.events[ev.event].push(ev);
                }
                else {
                    // @ts-ignore
                    receipt.events[ev.event] = [receipt.events[ev.event], ev];
                }
            }
            else {
                // @ts-ignore
                receipt.events[ev.event] = ev;
            }
        }
        else {
            // @ts-ignore
            receipt.events[count] = ev;
            // @ts-ignore
            count += 1;
        }
    });
    return receipt === null || receipt === void 0 ? void 0 : receipt.events;
}
exports.parseReceiptEvents = parseReceiptEvents;
