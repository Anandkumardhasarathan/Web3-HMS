import Web3 from "web3";
import type { types, eth, ContractAbi } from "web3";
import type * as EthereumProvider from "@rarible/ethereum-provider";
import type { MessageTypes, TypedMessage, EthereumSendTransactionOptions } from "@rarible/ethereum-provider";
import type { Address, BigNumber, Binary, Word } from "@rarible/types";
import { DappType } from "@rarible/sdk-common";
import { FMT_BYTES, FMT_NUMBER } from "web3-types";
import type { AbiFunctionFragment, FilterAbis } from "web3-types";
import type { ContractMethodsInterface, NonPayableMethodObject, PayableMethodObject } from "web3-eth-contract";
import type { Web3EthereumConfig, NumberHexReceipt } from "./domain";
export declare class Web3v4Ethereum implements EthereumProvider.Ethereum {
    private readonly config;
    constructor(config: Web3EthereumConfig);
    static isWeb3v4(web3Instance: unknown): web3Instance is Web3;
    createContract(abi: any, address?: string): EthereumProvider.EthereumContract;
    send(method: string, params: unknown[]): Promise<any>;
    personalSign(message: string): Promise<string>;
    sendTransaction(options: EthereumSendTransactionOptions): Promise<Web3Transaction>;
    signTypedData<T extends MessageTypes>(data: TypedMessage<T>): Promise<string>;
    getFrom(): Promise<string>;
    encodeParameter(type: any, parameter: any): string;
    decodeParameter(type: any, data: string): any;
    getBalance(address: Address): Promise<BigNumber>;
    getChainId(): Promise<number>;
    getWeb3Instance(): Web3;
    getCurrentProvider(): any;
}
export declare class Web3Contract<Abi extends ContractAbi> implements EthereumProvider.EthereumContract {
    private readonly config;
    private readonly contract;
    constructor(config: Web3EthereumConfig, contract: eth.contract.Contract<Abi>);
    functionCall(name: FilterAbis<Abi, AbiFunctionFragment & {
        type: "function";
    }>["name"], ...args: any): EthereumProvider.EthereumFunctionCall;
}
export declare class Web3FunctionCall<Abi extends ContractAbi, Contract extends eth.contract.Contract<Abi> = eth.contract.Contract<Abi>> implements EthereumProvider.EthereumFunctionCall {
    private readonly config;
    private readonly contract;
    private readonly methodName;
    private readonly args;
    private readonly sendMethod;
    private readonly contractAddress;
    constructor(config: Web3EthereumConfig, contract: Contract, methodName: FilterAbis<Abi, AbiFunctionFragment & {
        type: "function";
    }>["name"], args: Parameters<ContractMethodsInterface<Abi>["name"]>);
    getCallInfo(): Promise<EthereumProvider.EthereumFunctionCallInfo>;
    getData(): Promise<string>;
    getMethodWithReserveNode(): Promise<PayableMethodObject<any> | NonPayableMethodObject<any> | undefined>;
    getReserveNode(): Promise<string | undefined>;
    estimateGas(options?: EthereumProvider.EthereumEstimateGasOptions): Promise<number>;
    private callWithRetry;
    call(options?: EthereumProvider.EthereumSendOptions): Promise<any>;
    private _send;
    send(options?: EthereumProvider.EthereumSendOptions): Promise<EthereumProvider.EthereumTransaction>;
    getFrom(): Promise<string>;
}
export declare class Web3Transaction implements EthereumProvider.EthereumTransaction {
    private readonly receipt;
    readonly hash: Word;
    readonly data: Binary;
    readonly from: Address;
    readonly to?: Address | undefined;
    private readonly contractAbi?;
    constructor(receipt: Promise<NumberHexReceipt>, hash: Word, data: Binary, from: Address, to?: Address | undefined, contractAbi?: types.ContractAbi | undefined);
    wait(): Promise<EthereumProvider.EthereumTransactionReceipt>;
    getEvents(): Promise<EthereumProvider.EthereumTransactionEvent[]>;
}
export declare function getCurrentProviderId(web3: Web3 | undefined): DappType;
export { Web3, FMT_BYTES, FMT_NUMBER };
export { types as Web3Types } from "web3";
export * as Web3EthContractTypes from "web3-eth-contract";
